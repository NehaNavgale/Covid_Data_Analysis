{"ast":null,"code":"/**\n * Category axis module\n */\nimport * as tslib_1 from \"tslib\";\n/**\n * ============================================================================\n * IMPORTS\n * ============================================================================\n * @hidden\n */\n\nimport { Axis, AxisDataItem } from \"./Axis\";\nimport { registry } from \"../../core/Registry\";\nimport { Dictionary } from \"../../core/utils/Dictionary\";\nimport { CategoryAxisBreak } from \"./CategoryAxisBreak\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport { Adapter } from \"../../core/utils/Adapter\";\n/**\n * ============================================================================\n * DATA ITEM\n * ============================================================================\n * @hidden\n */\n\n/**\n * Defines a [[DataItem]] for [[CategoryAxis]].\n *\n * @see {@link DataItem}\n */\n\nvar CategoryAxisDataItem =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(CategoryAxisDataItem, _super);\n  /**\n   * Constructor\n   */\n\n\n  function CategoryAxisDataItem() {\n    var _this = _super.call(this) || this;\n    /**\n     * Holds Adapter.\n     */\n\n\n    _this.adapter = new Adapter(_this);\n    _this.seriesDataItems = {};\n    _this.className = \"CategoryAxisDataItem\";\n    _this.text = \"{category}\";\n    _this.locations.category = 0;\n    _this.locations.endCategory = 1;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(CategoryAxisDataItem.prototype, \"category\", {\n    /**\n     * @return Category\n     */\n    get: function get() {\n      if (this.adapter.isEnabled(\"category\")) {\n        return this.adapter.apply(\"category\", this.properties.category);\n      }\n\n      return this.properties.category;\n    },\n\n    /**\n     * Category.\n     *\n     * @param value  Category\n     */\n    set: function set(value) {\n      this.setProperty(\"category\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CategoryAxisDataItem.prototype, \"endCategory\", {\n    /**\n     * @return End category\n     */\n    get: function get() {\n      return this.properties.endCategory;\n    },\n\n    /**\n     * End category.\n     *\n     * Used for items that span several categories, like [[CategoryAxisBreak]].\n     *\n     * @param value  End category\n     */\n    set: function set(value) {\n      this.setProperty(\"endCategory\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return CategoryAxisDataItem;\n}(AxisDataItem);\n\nexport { CategoryAxisDataItem };\n/**\n * ============================================================================\n * MAIN CLASS\n * ============================================================================\n * @hidden\n */\n\n/**\n * Used to create a category-based axis for the chart.\n *\n * ```TypeScript\n * // Create the axis\n * let xAxis = chart.xAxes.push(new am4charts.CategoryAxis());\n *\n * // Set settings\n * xAxis.title.text = \"Clients\";\n * ```\n * ```JavaScript\n * // Create the axis\n * var valueAxis = chart.xAxes.push(new am4charts.CategoryAxis());\n *\n * // Set settings\n * valueAxis.title.text = \"Clients\";\n * ```\n * ```JSON\n * \"xAxes\": [{\n *   \"type\": \"CategoryAxis\",\n *   \"title\": {\n *     \"text\": \"Clients\"\n *   }\n * }]\n * ```\n *\n * @see {@link ICategoryAxisEvents} for a list of available Events\n * @see {@link ICategoryAxisAdapters} for a list of available Adapters\n * @important\n */\n\nvar CategoryAxis =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(CategoryAxis, _super);\n  /**\n   * Constructor\n   */\n\n\n  function CategoryAxis() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\n     * A collection that holds Axis' data items sorted by each category.\n     */\n\n\n    _this.dataItemsByCategory = new Dictionary();\n    _this.className = \"CategoryAxis\"; // Set field name\n\n    _this.axisFieldName = \"category\";\n    _this._lastDataItem = _this.createDataItem();\n    _this._lastDataItem.component = _this;\n\n    _this._disposers.push(_this._lastDataItem); // Apply theme\n\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\n   * Returns a new/empty [[DataItem]] of the type appropriate for this object.\n   *\n   * @see {@link DataItem}\n   * @return Data Item\n   */\n\n\n  CategoryAxis.prototype.createDataItem = function () {\n    return new CategoryAxisDataItem();\n  };\n  /**\n   * Returns a new/empty [[AxisBreak]] of the appropriate type.\n   *\n   * @return Axis break\n   */\n\n\n  CategoryAxis.prototype.createAxisBreak = function () {\n    return new CategoryAxisBreak();\n  };\n  /**\n   * Processes a related series' data item.\n   *\n   * @ignore Exclude from docs\n   * @todo Description\n   * @param dataItem  Data item\n   */\n\n\n  CategoryAxis.prototype.processSeriesDataItem = function (dataItem, axisLetter) {\n    _super.prototype.processSeriesDataItem.call(this, dataItem, axisLetter);\n\n    var category = dataItem[\"category\" + this.axisLetter];\n    var categoryAxisDataItem = this.dataItemsByCategory.getKey(category);\n\n    if (categoryAxisDataItem) {\n      var seriesId = dataItem.component.uid;\n      var seriesDataItems = categoryAxisDataItem.seriesDataItems[seriesId];\n\n      if (!seriesDataItems) {\n        seriesDataItems = [];\n        categoryAxisDataItem.seriesDataItems[seriesId] = seriesDataItems;\n      }\n\n      seriesDataItems.push(dataItem);\n    }\n  };\n  /**\n   * Validates the data range.\n   *\n   * @ignore Exclude from docs\n   * @todo Description (review)\n   */\n\n\n  CategoryAxis.prototype.validateDataRange = function () {\n    var _this = this;\n\n    _super.prototype.validateDataRange.call(this);\n\n    $iter.each(this._series.iterator(), function (series) {\n      if (series.xAxis instanceof CategoryAxis && series.yAxis instanceof CategoryAxis) {\n        series.invalidateDataRange();\n      } else {\n        var startIndex = _this.positionToIndex(_this.start);\n\n        var endIndex = _this.positionToIndex(_this.end);\n\n        var seriesId = series.uid;\n        var minIndex = void 0;\n        var maxIndex = void 0;\n\n        for (var i = startIndex; i <= endIndex; i++) {\n          var axisDataItem = _this.dataItems.getIndex(i);\n\n          if (axisDataItem) {\n            var seriesDataItems = axisDataItem.seriesDataItems[seriesId];\n\n            if (seriesDataItems) {\n              for (var i_1 = 0; i_1 < seriesDataItems.length; i_1++) {\n                var seriesDataItem = seriesDataItems[i_1];\n\n                if (seriesDataItem) {\n                  var index = seriesDataItem.index;\n\n                  if (!$type.isNumber(minIndex) || index < minIndex) {\n                    minIndex = index;\n                  }\n\n                  if (!$type.isNumber(maxIndex) || index > maxIndex) {\n                    maxIndex = index;\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if ($type.isNumber(minIndex)) {\n          series.startIndex = minIndex;\n        } else {\n          series.start = _this.start;\n        }\n\n        if ($type.isNumber(maxIndex)) {\n          series.endIndex = maxIndex + 1;\n        } else {\n          series.end = _this.end;\n        } // range might not change, but axis breaks might.\n\n\n        if (_this.axisBreaks.length > 0) {\n          series.invalidateDataRange();\n        }\n      }\n    });\n  };\n  /**\n   * Validates the whole axis. Causes it to redraw.\n   *\n   * @ignore Exclude from docs\n   * @todo Description (review)\n   */\n\n\n  CategoryAxis.prototype.validate = function () {\n    var _this = this;\n\n    _super.prototype.validate.call(this);\n\n    var dataCount = this.dataItems.length;\n    var startIndex = $math.fitToRange(Math.floor(this.start * dataCount - 1), 0, dataCount);\n    var endIndex = $math.fitToRange(Math.ceil(this.end * dataCount), 0, dataCount);\n\n    if (this.renderer.invalid) {\n      this.renderer.validate();\n    } // find frequency at which we'll show items\n\n\n    var maxCount = this.renderer.axisLength / this.renderer.minGridDistance;\n    var frequency = Math.min(this.dataItems.length, Math.ceil((endIndex - startIndex) / maxCount));\n    this._startIndex = Math.floor(startIndex / frequency) * frequency;\n    this._endIndex = Math.ceil(this.end * dataCount);\n    this.fixAxisBreaks();\n\n    if (this._startIndex == this._endIndex) {\n      this._endIndex++;\n    }\n\n    this._frequency = frequency;\n\n    if (this.axisLength <= 0) {\n      return;\n    }\n\n    this.maxZoomFactor = this.dataItems.length;\n\n    if (this.dataItems.length <= 0) {\n      this.maxZoomFactor = 1;\n    }\n\n    this.resetIterators(); // it's important to use protected variables here, as getters will return 0 - length\n    // TODO use iterator instead\n    // @ todo: not solved cat axis item fading\n\n    startIndex = $math.max(0, this._startIndex - this._frequency);\n    endIndex = $math.min(this.dataItems.length, this._endIndex + this._frequency);\n    var itemIndex = 0;\n\n    for (var i = 0; i < startIndex; i++) {\n      var dataItem = this.dataItems.getIndex(i);\n      dataItem.__disabled = true;\n    }\n\n    for (var i = endIndex, len = this.dataItems.length; i < len; i++) {\n      var dataItem = this.dataItems.getIndex(i);\n      dataItem.__disabled = true;\n    }\n\n    for (var i = startIndex; i < endIndex; i++) {\n      if (i < this.dataItems.length) {\n        var dataItem = this.dataItems.getIndex(i);\n\n        if (i / this._frequency == Math.round(i / this._frequency)) {\n          var axisBreak = this.isInBreak(i);\n\n          if (!axisBreak) {\n            this.appendDataItem(dataItem);\n            this.validateDataElement(dataItem, itemIndex);\n          }\n\n          itemIndex++;\n        } else {\n          //previously we disabled all before, but this is better for cpu\n          //this.validateDataElement(dataItem, itemIndex); // helps to solve shrinking // not good - creates all items\n          dataItem.__disabled = true;\n        }\n      }\n    }\n\n    this.appendDataItem(this._lastDataItem);\n    this.validateDataElement(this._lastDataItem, itemIndex + 1, this.dataItems.length);\n    var axisBreaks = this.axisBreaks;\n    axisBreaks.each(function (axisBreak) {\n      var adjustedStartValue = axisBreak.adjustedStartValue;\n      var adjustedEndValue = axisBreak.adjustedEndValue;\n\n      if ($math.intersect({\n        start: adjustedStartValue,\n        end: adjustedEndValue\n      }, {\n        start: _this._startIndex,\n        end: _this._endIndex\n      })) {\n        var frequency_1 = $math.fitToRange(Math.ceil(_this._frequency / axisBreak.breakSize), 1, adjustedEndValue - adjustedStartValue);\n        var itemIndex_1 = 0; // TODO use iterator instead\n\n        for (var b = adjustedStartValue; b <= adjustedEndValue; b = b + frequency_1) {\n          var dataItem = _this.dataItems.getIndex(b);\n\n          _this.appendDataItem(dataItem);\n\n          _this.validateDataElement(dataItem, itemIndex_1);\n\n          itemIndex_1++;\n        }\n      }\n    });\n    this.validateBreaks();\n    this.validateAxisRanges();\n    this.ghostLabel.invalidate(); // solves font issue\n\n    this.renderer.invalidateLayout();\n  };\n  /**\n   * [validateDataElement description]\n   *\n   * @ignore Exclude from docs\n   * @todo Description\n   * @param dataItem   [description]\n   * @param itemIndex  [description]\n   */\n\n\n  CategoryAxis.prototype.validateDataElement = function (dataItem, itemIndex, index) {\n    _super.prototype.validateDataElement.call(this, dataItem); //dataItem.__disabled = false;\n\n\n    var renderer = this.renderer;\n\n    if (!$type.isNumber(index)) {\n      index = this.categoryToIndex(dataItem.category);\n    }\n\n    var endIndex = this.categoryToIndex(dataItem.endCategory);\n\n    if (!$type.isNumber(endIndex)) {\n      endIndex = index;\n    }\n\n    var position = this.indexToPosition(index, dataItem.locations.category);\n    var endPosition = this.indexToPosition(endIndex, dataItem.locations.endCategory);\n    dataItem.position = position;\n    var fillEndIndex;\n    var fillPosition;\n    var fillEndPosition;\n\n    if (dataItem.isRange) {\n      fillEndIndex = endIndex;\n      fillPosition = this.indexToPosition(index, dataItem.locations.category);\n      fillEndPosition = this.indexToPosition(fillEndIndex, dataItem.locations.endCategory);\n    }\n\n    dataItem.point = renderer.positionToPoint(position);\n    var tick = dataItem.tick;\n\n    if (tick && !tick.disabled) {\n      renderer.updateTickElement(tick, position, endPosition);\n    }\n\n    var grid = dataItem.grid;\n\n    if (grid && !grid.disabled) {\n      renderer.updateGridElement(grid, position, endPosition);\n    }\n\n    var label = dataItem.label;\n\n    if (label && !label.disabled) {\n      // theorethically this might result problems if category text changes, the range text won't change. But otherwise range.label.text = \"custom text\" wont' work, which is not intuitive.\n      if (!dataItem.isRange || label.text == undefined) {\n        dataItem.text = dataItem.text;\n      }\n\n      renderer.updateLabelElement(label, position, endPosition);\n\n      if (dataItem.label.measuredWidth > this.ghostLabel.measuredWidth || dataItem.label.measuredHeight > this.ghostLabel.measuredHeight) {\n        this.ghostLabel.text = dataItem.label.currentText;\n      }\n    }\n\n    var fill = dataItem.axisFill;\n\n    if (fill && !fill.disabled) {\n      if (!dataItem.isRange) {\n        fillEndIndex = index + this._frequency;\n        fillPosition = this.indexToPosition(index, fill.location);\n        fillEndPosition = this.indexToPosition(fillEndIndex, fill.location);\n      }\n\n      renderer.updateFillElement(fill, fillPosition, fillEndPosition);\n\n      if (!dataItem.isRange) {\n        this.fillRule(dataItem, itemIndex);\n      }\n    }\n\n    var mask = dataItem.mask;\n\n    if (mask) {\n      renderer.updateFillElement(mask, fillPosition, fillEndPosition);\n    }\n  };\n  /**\n   * @ignore\n   */\n\n\n  CategoryAxis.prototype.disposeData = function () {\n    this.dataItemsByCategory.clear();\n\n    _super.prototype.disposeData.call(this);\n  };\n  /**\n   * Processes the axis data item.\n   *\n   * @ignore Exclude from docs\n   * @param dataItem     Data item\n   * @param dataContext  The raw data that corresponds to this data item\n   */\n\n\n  CategoryAxis.prototype.processDataItem = function (dataItem, dataContext) {\n    // creat a collection for fast access\n    _super.prototype.processDataItem.call(this, dataItem, dataContext); // check if such category already exists\n    //let existingDataItem: CategoryAxisDataItem = this.dataItemsByCategory.getKey(dataItem.category);\n    //if (existingDataItem && existingDataItem != dataItem) {\n    //\tthis.dataItems.remove(existingDataItem);\n    //}\n\n\n    this.dataItemsByCategory.setKey(dataItem.category, dataItem);\n  };\n\n  CategoryAxis.prototype.getDataItem = function (dataContext) {\n    var category = dataContext[this.dataFields.category];\n    var dataItem = this.dataItemsByCategory.getKey(category);\n\n    if (dataItem) {\n      return dataItem;\n    } else {\n      return this.dataItems.create();\n    }\n  };\n  /**\n   * Converts a category index to an actual screen coordinate on the axis.\n   *\n   * `location` identifies relative location within category. 0 - beginning,\n   * 0.5 - middle, 1 - end, and anything inbetween.\n   *\n   * @param index     Index\n   * @param location  Location (0-1)\n   * @return Position (px)\n   */\n\n\n  CategoryAxis.prototype.indexToPosition = function (index, location) {\n    if (!$type.isNumber(location)) {\n      location = 0.5;\n    }\n\n    var startIndex = this.startIndex;\n    var endIndex = this.endIndex;\n    var difference = this.adjustDifference(startIndex, endIndex);\n    var startLocation = this.startLocation;\n    var endLocation = this.endLocation;\n    difference -= startLocation;\n    difference -= 1 - endLocation;\n    var axisBreaks = this.axisBreaks;\n    $iter.eachContinue(axisBreaks.iterator(), function (axisBreak) {\n      var breakStartIndex = axisBreak.adjustedStartValue;\n      var breakEndIndex = axisBreak.adjustedEndValue;\n\n      if (index < startIndex) {\n        return false;\n      }\n\n      if ($math.intersect({\n        start: breakStartIndex,\n        end: breakEndIndex\n      }, {\n        start: startIndex,\n        end: endIndex\n      })) {\n        breakStartIndex = Math.max(startIndex, breakStartIndex);\n        breakEndIndex = Math.min(endIndex, breakEndIndex);\n        var breakSize = axisBreak.breakSize; // value to the right of break end\n\n        if (index > breakEndIndex) {\n          startIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\n        } // value to the left of break start\n        else if (index < breakStartIndex) {} // value within break\n          else {\n              index = breakStartIndex + (index - breakStartIndex) * breakSize;\n            }\n      }\n\n      return true;\n    });\n    return $math.round((index + location - startLocation - startIndex) / difference, 5);\n  };\n  /**\n   * Converts a string category name to relative position on axis.\n   *\n   * `location` identifies relative location within category. 0 - beginning,\n   * 0.5 - middle, 1 - end, and anything inbetween.\n   *\n   * @param category  Category name\n   * @param location  Location (0-1)\n   * @return Position\n   */\n\n\n  CategoryAxis.prototype.categoryToPosition = function (category, location) {\n    var index = this.categoryToIndex(category);\n    return this.indexToPosition(index, location);\n  };\n  /**\n   * Converts a string category name to a orientation point (x, y, angle) on axis\n   *\n   * `location` identifies relative location within category. 0 - beginning,\n   * 0.5 - middle, 1 - end, and anything inbetween.\n   * @param category  Category name\n   * @param location  Location (0-1)\n   * @return Orientation point\n   */\n\n\n  CategoryAxis.prototype.categoryToPoint = function (category, location) {\n    var position = this.categoryToPosition(category, location);\n    var point = this.renderer.positionToPoint(position);\n    var angle = this.renderer.positionToAngle(position);\n    return {\n      x: point.x,\n      y: point.y,\n      angle: angle\n    };\n  };\n  /**\n   * Converts a string category name to a orientation point (x, y, angle) on axis\n   *\n   * `location` identifies relative location within category. 0 - beginning,\n   * 0.5 - middle, 1 - end, and anything inbetween.\n   * @param category  Category name\n   * @param location  Location (0-1)\n   * @return Orientation point\n   */\n\n\n  CategoryAxis.prototype.anyToPoint = function (category, location) {\n    return this.categoryToPoint(category, location);\n  };\n  /**\n   * Converts a string category name to relative position on axis.\n   *\n   * An alias to `categoryToPosition()`.\n   *\n   * @param category  Category name\n   * @param location  Location (0-1)\n   * @return Relative position\n   */\n\n\n  CategoryAxis.prototype.anyToPosition = function (category, location) {\n    return this.categoryToPosition(category, location);\n  };\n  /**\n   * Converts named category to an index of data item it corresponds to.\n   *\n   * @param category  Category\n   * @return Data item index\n   */\n\n\n  CategoryAxis.prototype.categoryToIndex = function (category) {\n    if ($type.hasValue(category)) {\n      var dataItem = this.dataItemsByCategory.getKey(category);\n\n      if (dataItem) {\n        return dataItem.index;\n      }\n    }\n  };\n  /**\n   * Zooms the axis to specific named ctaegories.\n   *\n   * @param startCategory  Start category\n   * @param endCategory    End category\n   */\n\n\n  CategoryAxis.prototype.zoomToCategories = function (startCategory, endCategory) {\n    this.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1);\n  };\n  /**\n   * [getAnyRangePath description]\n   *\n   * @ignore Exclude from docs\n   * @todo Description\n   * @param start         [description]\n   * @param end           [description]\n   * @param startLocation [description]\n   * @param endLocation   [description]\n   * @return [description]\n   */\n\n\n  CategoryAxis.prototype.getAnyRangePath = function (start, end, startLocation, endLocation) {\n    var startPos = this.categoryToPosition(start, startLocation);\n    var endPos = this.categoryToPosition(end, endLocation);\n    return this.getPositionRangePath(startPos, endPos); // Base class (Axis) gets range shape from AxisRenderer\n  };\n  /**\n   * Takes an absolute position (px) within axis and adjust it to a specific\n   * `location` within category it corresponds to.\n   *\n   * @param position  Source position (px)\n   * @param location  Location within category (0-1)\n   * @return Adjusted position (px)\n   */\n\n\n  CategoryAxis.prototype.roundPosition = function (position, location) {\n    var index = this.positionToIndex(position);\n    return this.indexToPosition(index, location);\n  };\n  /**\n   * Finds and returns first series data item with specific category\n   * @param series    Target series\n   * @param category  Category\n   * @return XYSeriesDataItem data item\n   */\n\n\n  CategoryAxis.prototype.getFirstSeriesDataItem = function (series, category) {\n    for (var i = 0; i < series.dataItems.length; i++) {\n      var dataItem = series.dataItems.getIndex(i);\n\n      if (series.xAxis == this) {\n        if (dataItem.categoryX == category) {\n          return dataItem;\n        }\n      }\n\n      if (series.yAxis == this) {\n        if (dataItem.categoryY == category) {\n          return dataItem;\n        }\n      }\n    }\n  };\n  /**\n   * Finds and returns last series data item with specific category.\n   * @param series    Target series\n   * @param category  Category\n   * @return XYSeriesDataItem data item\n   */\n\n\n  CategoryAxis.prototype.getLastSeriesDataItem = function (series, category) {\n    for (var i = series.dataItems.length - 1; i >= 0; i--) {\n      var dataItem = series.dataItems.getIndex(i);\n\n      if (series.xAxis == this) {\n        if (dataItem.categoryX == category) {\n          return dataItem;\n        }\n      }\n\n      if (series.yAxis == this) {\n        if (dataItem.categoryY == category) {\n          return dataItem;\n        }\n      }\n    }\n  };\n  /**\n   * Returns a data item from Series that corresponds to a specific absolute\n   * position on the Axis.\n   *\n   * @param series    Target series\n   * @param position  Position (px)\n   * @return XYSeriesDataItem data item\n   */\n\n\n  CategoryAxis.prototype.getSeriesDataItem = function (series, position, findNearest) {\n    var _this = this;\n\n    if ($type.isNumber(position)) {\n      var index_1 = this.positionToIndex(position);\n      var dataItem = this.dataItems.getIndex(index_1);\n\n      if (dataItem) {\n        var category_1 = dataItem.category;\n        var sdi_1;\n        var seriesDataItem = series.dataItems.getIndex(index_1);\n\n        if (seriesDataItem) {\n          if (series.xAxis == this) {\n            if (seriesDataItem.categoryX == category_1) {\n              return seriesDataItem;\n            }\n          }\n\n          if (series.yAxis == this) {\n            if (seriesDataItem.categoryY == category_1) {\n              return seriesDataItem;\n            }\n          }\n        }\n\n        series.dataItems.each(function (dataItem) {\n          if (series.xAxis == _this) {\n            if (dataItem.categoryX == category_1) {\n              if (!sdi_1) {\n                sdi_1 = dataItem;\n              }\n\n              if (Math.abs(index_1 - sdi_1.index) > Math.abs(index_1 - dataItem.index)) {\n                sdi_1 = dataItem;\n              }\n            }\n          }\n\n          if (series.yAxis == _this) {\n            if (dataItem.categoryY == category_1) {\n              if (!sdi_1) {\n                sdi_1 = dataItem;\n              }\n\n              if (Math.abs(index_1 - sdi_1.index) > Math.abs(index_1 - dataItem.index)) {\n                sdi_1 = dataItem;\n              }\n            }\n          }\n        }); //@todo\n\n        if (findNearest) {}\n\n        return sdi_1;\n      }\n    }\n  };\n  /**\n   * Returns the X coordinate for series' data item.\n   *\n   * @ignore Exclude from docs\n   * @todo Description (review)\n   * @param dataItem  Data item\n   * @param key       Category\n   * @param location  Location (0-1)\n   * @return X coordinate (px)\n   */\n\n\n  CategoryAxis.prototype.getX = function (dataItem, key, location) {\n    var position;\n\n    if ($type.hasValue(key)) {\n      position = this.categoryToPosition(dataItem.categories[key], location);\n    }\n\n    if ($type.isNaN(position)) {\n      return this.basePoint.x;\n    } else {\n      return this.renderer.positionToPoint(position).x;\n    }\n  };\n  /**\n   * Returns the Y coordinate for series' data item.\n   *\n   * @ignore Exclude from docs\n   * @todo Description (review)\n   * @param dataItem  Data item\n   * @param key       Category\n   * @param location  Location (0-1)\n   * @return Y coordinate (px)\n   */\n\n\n  CategoryAxis.prototype.getY = function (dataItem, key, location) {\n    var position;\n\n    if ($type.hasValue(key)) {\n      position = this.categoryToPosition(dataItem.categories[key], location);\n    }\n\n    if ($type.isNaN(position)) {\n      return this.basePoint.y;\n    } else {\n      return this.renderer.positionToPoint(position).y;\n    }\n  };\n  /**\n   * Returns an angle for series data item.\n   *\n   * @ignore Exclude from docs\n   * @todo Description (review)\n   * @param dataItem  Data item\n   * @param key       Category\n   * @param location  Location (0-1)\n   * @param stackKey  Stack key (?)\n   * @return Angle\n   */\n\n\n  CategoryAxis.prototype.getAngle = function (dataItem, key, location, stackKey) {\n    return this.positionToAngle(this.categoryToPosition(dataItem.categories[key], location));\n  };\n  /**\n   * Returns an absolute pixel coordinate of the start of the cell (category),\n   * that specific position value falls into.\n   *\n   * @ignore Exclude from docs\n   * @todo Description (review)\n   * @param position  Position (px)\n   * @return Cell start position (px)\n   */\n\n\n  CategoryAxis.prototype.getCellStartPosition = function (position) {\n    return this.roundPosition(position, 0);\n  };\n  /**\n   * Returns an absolute pixel coordinate of the end of the cell (category),\n   * that specific position value falls into.\n   *\n   * @ignore Exclude from docs\n   * @todo Description (review)\n   * @param position  Position (px)\n   * @return Cell end position (px)\n   */\n\n\n  CategoryAxis.prototype.getCellEndPosition = function (position) {\n    return this.roundPosition(position, 1);\n  };\n  /**\n   * Returns text to show in a category tooltip, based on specific position\n   * within axis.\n   *\n   * @ignore Exclude from docs\n   * @param position  Position (px)\n   * @return Label (category)\n   */\n\n\n  CategoryAxis.prototype.getTooltipText = function (position) {\n    var dataItem = this.dataItems.getIndex(this.positionToIndex(position));\n\n    if (dataItem) {\n      return this.adapter.apply(\"getTooltipText\", dataItem.category);\n    }\n  };\n  /**\n   * Returns an index of the category that corresponds to specific pixel\n   * position within axis.\n   *\n   * @param position  Position (px)\n   * @return Category index\n   */\n\n\n  CategoryAxis.prototype.positionToIndex = function (position) {\n    position = $math.round(position, 10);\n\n    if (position < 0) {\n      position = 0;\n    }\n\n    var startIndex = this.startIndex;\n    var endIndex = this.endIndex;\n    var difference = endIndex - startIndex;\n    var axisBreaks = this.axisBreaks;\n    var index = null; // in case we have some axis breaks\n\n    $iter.eachContinue(axisBreaks.iterator(), function (axisBreak) {\n      var breakStartPosition = axisBreak.startPosition;\n      var breakEndPosition = axisBreak.endPosition;\n      var breakStartIndex = axisBreak.adjustedStartValue;\n      var breakEndIndex = axisBreak.adjustedEndValue;\n      breakStartIndex = $math.max(breakStartIndex, startIndex);\n      breakEndIndex = $math.min(breakEndIndex, endIndex);\n      var breakSize = axisBreak.breakSize;\n      difference -= (breakEndIndex - breakStartIndex) * (1 - breakSize); // position to the right of break end\n\n      if (position > breakEndPosition) {\n        startIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\n      } // position to the left of break start\n      else if (position < breakStartPosition) {} // value within break\n        else {\n            var breakPosition = (position - breakStartPosition) / (breakEndPosition - breakStartPosition);\n            index = breakStartIndex + Math.round(breakPosition * (breakEndIndex - breakStartIndex));\n            return false;\n          }\n\n      return true;\n    });\n\n    if (!$type.isNumber(index)) {\n      index = Math.floor(position * difference + startIndex);\n    }\n\n    if (index >= endIndex) {\n      index--;\n    }\n\n    return index;\n  };\n  /**\n   * Returns category based on position.\n   *\n   * Please note that `position` represents position within axis which may be\n   * zoomed and not correspond to Cursor's `position`.\n   *\n   * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\n   *\n   * This is a synonim of `getPositionLabel()` implemented here for consistentcy.\n   *\n   * @since 4.3.8\n   * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\n   * @param position  Relative position on axis (0-1)\n   * @return Position label\n   */\n\n\n  CategoryAxis.prototype.positionToCategory = function (position) {\n    return this.getPositionLabel(position);\n  };\n  /**\n   * Returns category based on position.\n   *\n   * Please note that `position` represents position within axis which may be\n   * zoomed and not correspond to Cursor's `position`.\n   *\n   * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\n   *\n   * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\n   * @param position  Relative position on axis (0-1)\n   * @return Position label\n   */\n\n\n  CategoryAxis.prototype.getPositionLabel = function (position) {\n    var dataItem = this.dataItems.getIndex(this.positionToIndex(position));\n\n    if (dataItem) {\n      return dataItem.category;\n    }\n  };\n\n  Object.defineProperty(CategoryAxis.prototype, \"basePoint\", {\n    /**\n     * Coordinates of the actual axis start.\n     *\n     * @ignore Exclude from docs\n     * @return Base point\n     */\n    get: function get() {\n      // This makes base grid to be drawn at the end of the axis and adds extra\n      // grid which we need to nicely close the chart.\n      return this.renderer.positionToPoint(1);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Initializes Axis' renderer.\n   *\n   * @ignore Exclude from docs\n   */\n\n  CategoryAxis.prototype.initRenderer = function () {\n    _super.prototype.initRenderer.call(this);\n\n    var renderer = this.renderer;\n    renderer.baseGrid.disabled = true;\n  };\n\n  Object.defineProperty(CategoryAxis.prototype, \"frequency\", {\n    /**\n     * Current frequency of labels of the axis.\n     *\n     * Normally it would be 1, but when labels start to be hidden due\n     * to `minGridDistance` this read-only property will increase.\n     *\n     * @readonly\n     * @since 4.2.0\n     * @return Label frequency\n     */\n    get: function get() {\n      return this._frequency;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return CategoryAxis;\n}(Axis);\n\nexport { CategoryAxis };\n/**\n * Register class, so that it can be instantiated using its name from\n * anywhere.\n *\n * @ignore\n */\n\nregistry.registeredClasses[\"CategoryAxis\"] = CategoryAxis;\nregistry.registeredClasses[\"CategoryAxisDataItem\"] = CategoryAxisDataItem;","map":{"version":3,"sources":["../../../../../src/.internal/charts/axes/CategoryAxis.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Category axis module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Axis, AxisItemLocation, AxisDataItem, IAxisProperties, IAxisDataFields, IAxisAdapters, IAxisEvents, IAxisDataItemAdapters } from \"./Axis\";\r\nimport { IPoint, IOrientationPoint } from \"../../core/defs/IPoint\";\r\nimport { AxisFill } from \"./AxisFill\";\r\nimport { AxisRenderer } from \"./AxisRenderer\";\r\nimport { SerialChart } from \"../types/SerialChart\";\r\nimport { AxisTick } from \"./AxisTick\";\r\nimport { Grid } from \"./Grid\";\r\nimport { AxisLabel } from \"./AxisLabel\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport { Dictionary } from \"../../core/utils/Dictionary\";\r\nimport { XYSeries, XYSeriesDataItem } from \"../series/XYSeries\";\r\nimport { CategoryAxisBreak } from \"./CategoryAxisBreak\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\nimport { Adapter } from \"../../core/utils/Adapter\";\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines a [[DataItem]] for [[CategoryAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\r\nexport class CategoryAxisDataItem extends AxisDataItem {\r\n\r\n\t/**\r\n\t * Defines a type of [[Component]] this data item is used for.\r\n\t */\r\n\tpublic _component!: CategoryAxis;\r\n\r\n\t/**\r\n\t * Holds Adapter.\r\n\t */\r\n\tpublic adapter = new Adapter<CategoryAxisDataItem, ICategoryAxisDataItemAdapters>(this);\r\n\r\n\tpublic seriesDataItems: { [index: string]: XYSeriesDataItem[] } = {};\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"CategoryAxisDataItem\";\r\n\t\tthis.text = \"{category}\";\r\n\r\n\t\tthis.locations.category = 0;\r\n\t\tthis.locations.endCategory = 1;\r\n\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Category.\r\n\t *\r\n\t * @param value  Category\r\n\t */\r\n\tpublic set category(value: string) {\r\n\t\tthis.setProperty(\"category\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Category\r\n\t */\r\n\tpublic get category(): string {\r\n\t\tif (this.adapter.isEnabled(\"category\")) {\r\n\t\t\treturn this.adapter.apply(\"category\", this.properties.category);\r\n\t\t}\r\n\t\treturn this.properties.category;\r\n\t}\r\n\r\n\t/**\r\n\t * End category.\r\n\t *\r\n\t * Used for items that span several categories, like [[CategoryAxisBreak]].\r\n\t *\r\n\t * @param value  End category\r\n\t */\r\n\tpublic set endCategory(value: string) {\r\n\t\tthis.setProperty(\"endCategory\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return End category\r\n\t */\r\n\tpublic get endCategory(): string {\r\n\t\treturn this.properties.endCategory;\r\n\t}\r\n}\r\n\r\n/**\r\n * Defines adapters for [[DataItem]]\r\n * Includes both the [[Adapter]] definitions and properties\r\n * @see {@link Adapter}\r\n */\r\nexport interface ICategoryAxisDataItemAdapters extends IAxisDataItemAdapters {\r\n\tcategory: string;\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines data fields for [[CategoryAxis]].\r\n */\r\nexport interface ICategoryAxisDataFields extends IAxisDataFields {\r\n\r\n\t/**\r\n\t * A field that holds category information.\r\n\t */\r\n\tcategory?: string;\r\n\r\n}\r\n\r\n/**\r\n * Defines properties for [[CategoryAxis]].\r\n */\r\nexport interface ICategoryAxisProperties extends IAxisProperties { }\r\n\r\n/**\r\n * Defines events for [[CategoryAxis]].\r\n */\r\nexport interface ICategoryAxisEvents extends IAxisEvents { }\r\n\r\n/**\r\n * Defines adapter for [[CategoryAxis]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface ICategoryAxisAdapters extends IAxisAdapters, ICategoryAxisProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Used to create a category-based axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let xAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * xAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.xAxes.push(new am4charts.CategoryAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Clients\";\r\n * ```\r\n * ```JSON\r\n * \"xAxes\": [{\r\n *   \"type\": \"CategoryAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Clients\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link ICategoryAxisEvents} for a list of available Events\r\n * @see {@link ICategoryAxisAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nexport class CategoryAxis<T extends AxisRenderer = AxisRenderer> extends Axis<T> {\r\n\r\n\t/**\r\n\t * Defines data fields.\r\n\t */\r\n\tpublic _dataFields: ICategoryAxisDataFields;\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: ICategoryAxisProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: ICategoryAxisAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: ICategoryAxisEvents;\r\n\r\n\t/**\r\n\t * Defines the type of the Date Items.\r\n\t */\r\n\tpublic _dataItem: CategoryAxisDataItem;\r\n\r\n\t/**\r\n\t * Defines the type of the axis breaks.\r\n\t */\r\n\tpublic _axisBreak: CategoryAxisBreak;\r\n\r\n\t/**\r\n\t * A reference to chart the axis is for.\r\n\t */\r\n\tpublic chart: SerialChart;\r\n\r\n\t/**\r\n\t * Frequency of the labels on axis.\r\n\t */\r\n\tprotected _frequency: number;\r\n\r\n\t/**\r\n\t * A collection that holds Axis' data items sorted by each category.\r\n\t */\r\n\tpublic dataItemsByCategory: Dictionary<string, this[\"_dataItem\"]> = new Dictionary<string, this[\"_dataItem\"]>();\r\n\r\n\t/**\r\n\t * last data item is used for the closing grid\r\n\t */\r\n\tprotected _lastDataItem: CategoryAxisDataItem;\r\n\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"CategoryAxis\";\r\n\r\n\t\t// Set field name\r\n\t\tthis.axisFieldName = \"category\";\r\n\r\n\t\tthis._lastDataItem = this.createDataItem();\r\n\t\tthis._lastDataItem.component = this;\r\n\t\tthis._disposers.push(this._lastDataItem);\r\n\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n\t *\r\n\t * @see {@link DataItem}\r\n\t * @return Data Item\r\n\t */\r\n\tprotected createDataItem(): this[\"_dataItem\"] {\r\n\t\treturn new CategoryAxisDataItem();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n\t *\r\n\t * @return Axis break\r\n\t */\r\n\tprotected createAxisBreak(): this[\"_axisBreak\"] {\r\n\t\treturn new CategoryAxisBreak();\r\n\t}\r\n\r\n\t/**\r\n\t * Processes a related series' data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param dataItem  Data item\r\n\t */\r\n\tpublic processSeriesDataItem(dataItem: XYSeriesDataItem, axisLetter?: string): void {\r\n\t\tsuper.processSeriesDataItem(dataItem, axisLetter);\r\n\t\tlet category: string = (<any>dataItem)[\"category\" + this.axisLetter];\r\n\r\n\t\tlet categoryAxisDataItem: this[\"_dataItem\"] = this.dataItemsByCategory.getKey(category);\r\n\t\tif (categoryAxisDataItem) {\r\n\t\t\tlet seriesId = dataItem.component.uid;\r\n\t\t\tlet seriesDataItems = categoryAxisDataItem.seriesDataItems[seriesId];\r\n\t\t\tif(!seriesDataItems){\r\n\t\t\t\tseriesDataItems = [];\r\n\t\t\t\tcategoryAxisDataItem.seriesDataItems[seriesId] = seriesDataItems;\r\n\t\t\t}\r\n\t\t\tseriesDataItems.push(dataItem);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Validates the data range.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t */\r\n\tpublic validateDataRange(): void {\r\n\r\n\t\tsuper.validateDataRange();\r\n\r\n\t\t$iter.each(this._series.iterator(), (series) => {\r\n\t\t\tif ((series.xAxis instanceof CategoryAxis) && (series.yAxis instanceof CategoryAxis)) {\r\n\t\t\t\tseries.invalidateDataRange();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tlet startIndex = this.positionToIndex(this.start);\r\n\t\t\t\tlet endIndex = this.positionToIndex(this.end);\r\n\r\n\t\t\t\tlet seriesId = series.uid;\r\n\t\t\t\tlet minIndex:number;\r\n\t\t\t\tlet maxIndex:number;\r\n\r\n\t\t\t\tfor (let i = startIndex; i <= endIndex; i++) {\r\n\t\t\t\t\tlet axisDataItem = this.dataItems.getIndex(i);\r\n\t\t\t\t\tif(axisDataItem){\r\n\t\t\t\t\t\tlet seriesDataItems = axisDataItem.seriesDataItems[seriesId];\r\n\r\n\t\t\t\t\t\tif(seriesDataItems){\r\n\t\t\t\t\t\t\tfor(let i = 0; i < seriesDataItems.length; i++){\r\n\t\t\t\t\t\t\t\tlet seriesDataItem = seriesDataItems[i];\r\n\t\t\t\t\t\t\t\tif(seriesDataItem){\r\n\t\t\t\t\t\t\t\t\tlet index = seriesDataItem.index;\r\n\t\t\t\t\t\t\t\t\tif(!$type.isNumber(minIndex) || index < minIndex){\r\n\t\t\t\t\t\t\t\t\t\tminIndex = index;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\tif(!$type.isNumber(maxIndex) || index > maxIndex){\r\n\t\t\t\t\t\t\t\t\t\tmaxIndex = index;\r\n\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ($type.isNumber(minIndex)) {\r\n\t\t\t\t\tseries.startIndex = minIndex;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tseries.start = this.start;\r\n\t\t\t\t}\r\n\t\t\t\tif ($type.isNumber(maxIndex)) {\r\n\t\t\t\t\tseries.endIndex = maxIndex + 1;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tseries.end = this.end;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// range might not change, but axis breaks might.\r\n\t\t\t\tif (this.axisBreaks.length > 0) {\r\n\t\t\t\t\tseries.invalidateDataRange();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Validates the whole axis. Causes it to redraw.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t */\r\n\tpublic validate(): void {\r\n\r\n\t\tsuper.validate();\r\n\r\n\t\tlet dataCount: number = this.dataItems.length;\r\n\r\n\t\tlet startIndex = $math.fitToRange(Math.floor(this.start * dataCount - 1), 0, dataCount);\r\n\t\tlet endIndex = $math.fitToRange(Math.ceil(this.end * dataCount), 0, dataCount);\r\n\r\n\t\tif (this.renderer.invalid) {\r\n\t\t\tthis.renderer.validate();\r\n\t\t}\r\n\r\n\t\t// find frequency at which we'll show items\r\n\t\tlet maxCount: number = this.renderer.axisLength / this.renderer.minGridDistance;\r\n\t\tlet frequency: number = Math.min(this.dataItems.length, Math.ceil((endIndex - startIndex) / maxCount));\r\n\r\n\t\tthis._startIndex = Math.floor(startIndex / frequency) * frequency;\r\n\t\tthis._endIndex = Math.ceil(this.end * dataCount);\r\n\r\n\t\tthis.fixAxisBreaks();\r\n\r\n\t\tif (this._startIndex == this._endIndex) {\r\n\t\t\tthis._endIndex++;\r\n\t\t}\r\n\r\n\t\tthis._frequency = frequency;\r\n\r\n\t\tif (this.axisLength <= 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.maxZoomFactor = this.dataItems.length;\r\n\t\tif (this.dataItems.length <= 0) {\r\n\t\t\tthis.maxZoomFactor = 1;\r\n\t\t}\r\n\r\n\t\tthis.resetIterators();\r\n\r\n\t\t// it's important to use protected variables here, as getters will return 0 - length\r\n\t\t// TODO use iterator instead\r\n\t\t// @ todo: not solved cat axis item fading\r\n\t\tstartIndex = $math.max(0, this._startIndex - this._frequency);\r\n\t\tendIndex = $math.min(this.dataItems.length, this._endIndex + this._frequency);\r\n\r\n\t\tlet itemIndex = 0;\r\n\r\n\t\tfor (let i = 0; i < startIndex; i++) {\r\n\t\t\tlet dataItem = this.dataItems.getIndex(i);\r\n\t\t\tdataItem.__disabled = true;\r\n\t\t}\r\n\r\n\t\tfor (let i = endIndex, len = this.dataItems.length; i < len; i++) {\r\n\t\t\tlet dataItem = this.dataItems.getIndex(i);\r\n\t\t\tdataItem.__disabled = true;\r\n\t\t}\r\n\r\n\t\tfor (let i = startIndex; i < endIndex; i++) {\r\n\t\t\tif (i < this.dataItems.length) {\r\n\t\t\t\tlet dataItem: this[\"_dataItem\"] = this.dataItems.getIndex(i);\r\n\t\t\t\tif (i / this._frequency == Math.round(i / this._frequency)) {\r\n\t\t\t\t\tlet axisBreak: CategoryAxisBreak = this.isInBreak(i);\r\n\t\t\t\t\tif (!axisBreak) {\r\n\t\t\t\t\t\tthis.appendDataItem(dataItem);\r\n\t\t\t\t\t\tthis.validateDataElement(dataItem, itemIndex);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\titemIndex++;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t//previously we disabled all before, but this is better for cpu\r\n\t\t\t\t\t//this.validateDataElement(dataItem, itemIndex); // helps to solve shrinking // not good - creates all items\r\n\t\t\t\t\tdataItem.__disabled = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.appendDataItem(this._lastDataItem);\r\n\t\tthis.validateDataElement(this._lastDataItem, itemIndex + 1, this.dataItems.length);\r\n\r\n\t\tlet axisBreaks = this.axisBreaks;\r\n\r\n\t\taxisBreaks.each((axisBreak) => {\r\n\t\t\tlet adjustedStartValue: number = axisBreak.adjustedStartValue;\r\n\t\t\tlet adjustedEndValue: number = axisBreak.adjustedEndValue;\r\n\r\n\t\t\tif ($math.intersect({ start: adjustedStartValue, end: adjustedEndValue }, { start: this._startIndex, end: this._endIndex })) {\r\n\r\n\t\t\t\tlet frequency: number = $math.fitToRange(Math.ceil(this._frequency / axisBreak.breakSize), 1, adjustedEndValue - adjustedStartValue);\r\n\t\t\t\tlet itemIndex = 0;\r\n\t\t\t\t// TODO use iterator instead\r\n\t\t\t\tfor (let b = adjustedStartValue; b <= adjustedEndValue; b = b + frequency) {\r\n\t\t\t\t\tlet dataItem: this[\"_dataItem\"] = this.dataItems.getIndex(b);\r\n\t\t\t\t\tthis.appendDataItem(dataItem);\r\n\t\t\t\t\tthis.validateDataElement(dataItem, itemIndex);\r\n\t\t\t\t\titemIndex++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis.validateBreaks();\r\n\t\tthis.validateAxisRanges();\r\n\r\n\t\tthis.ghostLabel.invalidate(); // solves font issue\r\n\t\tthis.renderer.invalidateLayout();\r\n\t}\r\n\r\n\t/**\r\n\t * [validateDataElement description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param dataItem   [description]\r\n\t * @param itemIndex  [description]\r\n\t */\r\n\tpublic validateDataElement(dataItem: this[\"_dataItem\"], itemIndex?: number, index?: number): void {\r\n\t\tsuper.validateDataElement(dataItem);\r\n\r\n\t\t//dataItem.__disabled = false;\r\n\r\n\t\tlet renderer: AxisRenderer = this.renderer;\r\n\t\tif (!$type.isNumber(index)) {\r\n\t\t\tindex = this.categoryToIndex(dataItem.category);\r\n\t\t}\r\n\r\n\t\tlet endIndex = this.categoryToIndex(dataItem.endCategory);\r\n\r\n\t\tif (!$type.isNumber(endIndex)) {\r\n\t\t\tendIndex = index;\r\n\t\t}\r\n\r\n\t\tlet position: number = this.indexToPosition(index, dataItem.locations.category);\r\n\t\tlet endPosition: number = this.indexToPosition(endIndex, dataItem.locations.endCategory);\r\n\r\n\t\tdataItem.position = position;\r\n\r\n\t\tlet fillEndIndex: number;\r\n\t\tlet fillPosition: number;\r\n\t\tlet fillEndPosition: number;\r\n\r\n\t\tif (dataItem.isRange) {\r\n\t\t\tfillEndIndex = endIndex;\r\n\t\t\tfillPosition = this.indexToPosition(index, dataItem.locations.category);\r\n\t\t\tfillEndPosition = this.indexToPosition(fillEndIndex, dataItem.locations.endCategory);\r\n\t\t}\r\n\r\n\t\tdataItem.point = renderer.positionToPoint(position);\r\n\r\n\t\tlet tick: AxisTick = dataItem.tick;\r\n\t\tif (tick && !tick.disabled) {\r\n\t\t\trenderer.updateTickElement(tick, position, endPosition);\r\n\t\t}\r\n\r\n\t\tlet grid: Grid = dataItem.grid;\r\n\t\tif (grid && !grid.disabled) {\r\n\t\t\trenderer.updateGridElement(grid, position, endPosition);\r\n\t\t}\r\n\r\n\r\n\t\tlet label: AxisLabel = dataItem.label;\r\n\t\tif (label && !label.disabled) {\r\n\t\t\t// theorethically this might result problems if category text changes, the range text won't change. But otherwise range.label.text = \"custom text\" wont' work, which is not intuitive.\r\n\t\t\tif (!dataItem.isRange || label.text == undefined) {\r\n\t\t\t\tdataItem.text = dataItem.text;\r\n\t\t\t}\r\n\r\n\t\t\trenderer.updateLabelElement(label, position, endPosition);\r\n\r\n\t\t\tif (dataItem.label.measuredWidth > this.ghostLabel.measuredWidth || dataItem.label.measuredHeight > this.ghostLabel.measuredHeight) {\r\n\t\t\t\tthis.ghostLabel.text = dataItem.label.currentText;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet fill: AxisFill = dataItem.axisFill;\r\n\t\tif (fill && !fill.disabled) {\r\n\r\n\t\t\tif (!dataItem.isRange) {\r\n\t\t\t\tfillEndIndex = index + this._frequency;\r\n\t\t\t\tfillPosition = this.indexToPosition(index, fill.location);\r\n\t\t\t\tfillEndPosition = this.indexToPosition(fillEndIndex, fill.location);\r\n\t\t\t}\r\n\r\n\t\t\trenderer.updateFillElement(fill, fillPosition, fillEndPosition);\r\n\t\t\tif (!dataItem.isRange) {\r\n\t\t\t\tthis.fillRule(dataItem, itemIndex);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\tlet mask: AxisFill = dataItem.mask;\r\n\t\tif (mask) {\r\n\t\t\trenderer.updateFillElement(mask, fillPosition, fillEndPosition);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic disposeData() {\r\n\t\tthis.dataItemsByCategory.clear();\r\n\t\tsuper.disposeData();\r\n\t}\r\n\r\n\t/**\r\n\t * Processes the axis data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param dataItem     Data item\r\n\t * @param dataContext  The raw data that corresponds to this data item\r\n\t */\r\n\tpublic processDataItem(dataItem: this[\"_dataItem\"], dataContext: Object): void {\r\n\t\t// creat a collection for fast access\r\n\t\tsuper.processDataItem(dataItem, dataContext);\r\n\t\t// check if such category already exists\r\n\t\t//let existingDataItem: CategoryAxisDataItem = this.dataItemsByCategory.getKey(dataItem.category);\r\n\t\t//if (existingDataItem && existingDataItem != dataItem) {\r\n\t\t//\tthis.dataItems.remove(existingDataItem);\r\n\t\t//}\r\n\r\n\t\tthis.dataItemsByCategory.setKey(dataItem.category, dataItem);\r\n\t}\r\n\r\n\r\n\tprotected getDataItem(dataContext?: any): this[\"_dataItem\"] {\r\n\t\tlet category: string = <string>(dataContext[this.dataFields.category]);\r\n\t\tlet dataItem: this[\"_dataItem\"] = this.dataItemsByCategory.getKey(category);\r\n\r\n\t\tif (dataItem) {\r\n\t\t\treturn dataItem;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.dataItems.create();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a category index to an actual screen coordinate on the axis.\r\n\t *\r\n\t * `location` identifies relative location within category. 0 - beginning,\r\n\t * 0.5 - middle, 1 - end, and anything inbetween.\r\n\t *\r\n\t * @param index     Index\r\n\t * @param location  Location (0-1)\r\n\t * @return Position (px)\r\n\t */\r\n\tpublic indexToPosition(index: number, location?: AxisItemLocation | number): number {\r\n\t\tif (!$type.isNumber(location)) {\r\n\t\t\tlocation = 0.5;\r\n\t\t}\r\n\r\n\t\tlet startIndex: number = this.startIndex;\r\n\t\tlet endIndex: number = this.endIndex;\r\n\r\n\t\tlet difference: number = this.adjustDifference(startIndex, endIndex);\r\n\r\n\t\tlet startLocation = this.startLocation;\r\n\t\tlet endLocation = this.endLocation;\r\n\r\n\t\tdifference -= startLocation;\r\n\t\tdifference -= (1 - endLocation);\r\n\r\n\t\tlet axisBreaks = this.axisBreaks;\r\n\r\n\t\t$iter.eachContinue(axisBreaks.iterator(), (axisBreak) => {\r\n\t\t\tlet breakStartIndex: number = axisBreak.adjustedStartValue;\r\n\t\t\tlet breakEndIndex: number = axisBreak.adjustedEndValue;\r\n\r\n\t\t\tif (index < startIndex) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tif ($math.intersect({ start: breakStartIndex, end: breakEndIndex }, { start: startIndex, end: endIndex })) {\r\n\t\t\t\tbreakStartIndex = Math.max(startIndex, breakStartIndex);\r\n\t\t\t\tbreakEndIndex = Math.min(endIndex, breakEndIndex);\r\n\r\n\t\t\t\tlet breakSize: number = axisBreak.breakSize;\r\n\r\n\t\t\t\t// value to the right of break end\r\n\t\t\t\tif (index > breakEndIndex) {\r\n\t\t\t\t\tstartIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\r\n\t\t\t\t}\r\n\t\t\t\t// value to the left of break start\r\n\t\t\t\telse if (index < breakStartIndex) {\r\n\r\n\t\t\t\t}\r\n\t\t\t\t// value within break\r\n\t\t\t\telse {\r\n\t\t\t\t\tindex = breakStartIndex + (index - breakStartIndex) * breakSize;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t});\r\n\r\n\t\treturn $math.round((index + location - startLocation - startIndex) / difference, 5);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a string category name to relative position on axis.\r\n\t *\r\n\t * `location` identifies relative location within category. 0 - beginning,\r\n\t * 0.5 - middle, 1 - end, and anything inbetween.\r\n\t *\r\n\t * @param category  Category name\r\n\t * @param location  Location (0-1)\r\n\t * @return Position\r\n\t */\r\n\tpublic categoryToPosition(category: string, location?: AxisItemLocation): number {\r\n\t\tlet index: number = this.categoryToIndex(category);\r\n\t\treturn this.indexToPosition(index, location);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a string category name to a orientation point (x, y, angle) on axis\r\n\t *\r\n\t * `location` identifies relative location within category. 0 - beginning,\r\n\t * 0.5 - middle, 1 - end, and anything inbetween.\r\n\t * @param category  Category name\r\n\t * @param location  Location (0-1)\r\n\t * @return Orientation point\r\n\t */\r\n\tpublic categoryToPoint(category: string, location?: AxisItemLocation): IOrientationPoint {\r\n\t\tlet position = this.categoryToPosition(category, location);\r\n\t\tlet point = this.renderer.positionToPoint(position);\r\n\t\tlet angle = this.renderer.positionToAngle(position);\r\n\t\treturn { x: point.x, y: point.y, angle: angle };\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Converts a string category name to a orientation point (x, y, angle) on axis\r\n\t *\r\n\t * `location` identifies relative location within category. 0 - beginning,\r\n\t * 0.5 - middle, 1 - end, and anything inbetween.\r\n\t * @param category  Category name\r\n\t * @param location  Location (0-1)\r\n\t * @return Orientation point\r\n\t */\r\n\tanyToPoint(category: string, location?: AxisItemLocation): IOrientationPoint {\r\n\t\treturn this.categoryToPoint(category, location);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Converts a string category name to relative position on axis.\r\n\t *\r\n\t * An alias to `categoryToPosition()`.\r\n\t *\r\n\t * @param category  Category name\r\n\t * @param location  Location (0-1)\r\n\t * @return Relative position\r\n\t */\r\n\tpublic anyToPosition(category: string, location?: AxisItemLocation): number {\r\n\t\treturn this.categoryToPosition(category, location);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts named category to an index of data item it corresponds to.\r\n\t *\r\n\t * @param category  Category\r\n\t * @return Data item index\r\n\t */\r\n\tpublic categoryToIndex(category: string): number {\r\n\t\tif ($type.hasValue(category)) {\r\n\t\t\tlet dataItem: this[\"_dataItem\"] = this.dataItemsByCategory.getKey(category);\r\n\t\t\tif (dataItem) {\r\n\t\t\t\treturn dataItem.index;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Zooms the axis to specific named ctaegories.\r\n\t *\r\n\t * @param startCategory  Start category\r\n\t * @param endCategory    End category\r\n\t */\r\n\tpublic zoomToCategories(startCategory: string, endCategory: string): void {\r\n\t\tthis.zoomToIndexes(this.categoryToIndex(startCategory), this.categoryToIndex(endCategory) + 1);\r\n\t}\r\n\r\n\t/**\r\n\t * [getAnyRangePath description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param start         [description]\r\n\t * @param end           [description]\r\n\t * @param startLocation [description]\r\n\t * @param endLocation   [description]\r\n\t * @return [description]\r\n\t */\r\n\tpublic getAnyRangePath(start: string, end: string, startLocation?: AxisItemLocation, endLocation?: AxisItemLocation): string {\r\n\t\tlet startPos: number = this.categoryToPosition(start, startLocation);\r\n\t\tlet endPos: number = this.categoryToPosition(end, endLocation);\r\n\t\treturn this.getPositionRangePath(startPos, endPos); // Base class (Axis) gets range shape from AxisRenderer\r\n\t}\r\n\r\n\t/**\r\n\t * Takes an absolute position (px) within axis and adjust it to a specific\r\n\t * `location` within category it corresponds to.\r\n\t *\r\n\t * @param position  Source position (px)\r\n\t * @param location  Location within category (0-1)\r\n\t * @return Adjusted position (px)\r\n\t */\r\n\tpublic roundPosition(position: number, location?: AxisItemLocation): number {\r\n\t\tlet index: number = this.positionToIndex(position);\r\n\t\treturn this.indexToPosition(index, location);\r\n\t}\r\n\r\n\t/**\r\n\t * Finds and returns first series data item with specific category\r\n\t * @param series    Target series\r\n\t * @param category  Category\r\n\t * @return XYSeriesDataItem data item\r\n\t */\r\n\tpublic getFirstSeriesDataItem(series: XYSeries, category: string): XYSeriesDataItem {\r\n\r\n\t\tfor (let i = 0; i < series.dataItems.length; i++) {\r\n\t\t\tlet dataItem = series.dataItems.getIndex(i);\r\n\t\t\tif (series.xAxis == this) {\r\n\t\t\t\tif (dataItem.categoryX == category) {\r\n\t\t\t\t\treturn dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (series.yAxis == this) {\r\n\t\t\t\tif (dataItem.categoryY == category) {\r\n\t\t\t\t\treturn dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Finds and returns last series data item with specific category.\r\n\t * @param series    Target series\r\n\t * @param category  Category\r\n\t * @return XYSeriesDataItem data item\r\n\t */\r\n\tpublic getLastSeriesDataItem(series: XYSeries, category: string): XYSeriesDataItem {\r\n\r\n\t\tfor (let i = series.dataItems.length - 1; i >= 0; i--) {\r\n\t\t\tlet dataItem = series.dataItems.getIndex(i);\r\n\t\t\tif (series.xAxis == this) {\r\n\t\t\t\tif (dataItem.categoryX == category) {\r\n\t\t\t\t\treturn dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (series.yAxis == this) {\r\n\t\t\t\tif (dataItem.categoryY == category) {\r\n\t\t\t\t\treturn dataItem;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns a data item from Series that corresponds to a specific absolute\r\n\t * position on the Axis.\r\n\t *\r\n\t * @param series    Target series\r\n\t * @param position  Position (px)\r\n\t * @return XYSeriesDataItem data item\r\n\t */\r\n\tpublic getSeriesDataItem(series: XYSeries, position: number, findNearest?: boolean): XYSeriesDataItem {\r\n\r\n\t\tif ($type.isNumber(position)) {\r\n\r\n\t\t\tlet index = this.positionToIndex(position);\r\n\r\n\t\t\tlet dataItem = this.dataItems.getIndex(index);\r\n\r\n\t\t\tif (dataItem) {\r\n\t\t\t\tlet category = dataItem.category;\r\n\t\t\t\tlet sdi: XYSeriesDataItem;\r\n\r\n\t\t\t\tlet seriesDataItem = series.dataItems.getIndex(index);\r\n\t\t\t\tif (seriesDataItem) {\r\n\t\t\t\t\tif (series.xAxis == this) {\r\n\t\t\t\t\t\tif (seriesDataItem.categoryX == category) {\r\n\t\t\t\t\t\t\treturn seriesDataItem;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (series.yAxis == this) {\r\n\t\t\t\t\t\tif (seriesDataItem.categoryY == category) {\r\n\t\t\t\t\t\t\treturn seriesDataItem;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tseries.dataItems.each((dataItem) => {\r\n\t\t\t\t\tif (series.xAxis == this) {\r\n\t\t\t\t\t\tif (dataItem.categoryX == category) {\r\n\t\t\t\t\t\t\tif (!sdi) {\r\n\t\t\t\t\t\t\t\tsdi = dataItem;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (Math.abs(index - sdi.index) > Math.abs(index - dataItem.index)) {\r\n\t\t\t\t\t\t\t\tsdi = dataItem;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (series.yAxis == this) {\r\n\t\t\t\t\t\tif (dataItem.categoryY == category) {\r\n\t\t\t\t\t\t\tif (!sdi) {\r\n\t\t\t\t\t\t\t\tsdi = dataItem;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (Math.abs(index - sdi.index) > Math.abs(index - dataItem.index)) {\r\n\t\t\t\t\t\t\t\tsdi = dataItem;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\r\n\t\t\t\t//@todo\r\n\t\t\t\tif (findNearest) {\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn sdi;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the X coordinate for series' data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param dataItem  Data item\r\n\t * @param key       Category\r\n\t * @param location  Location (0-1)\r\n\t * @return X coordinate (px)\r\n\t */\r\n\tpublic getX(dataItem: XYSeriesDataItem, key?: string, location?: number): number {\r\n\t\tlet position;\r\n\t\tif ($type.hasValue(key)) {\r\n\t\t\tposition = this.categoryToPosition(dataItem.categories[key], location);\r\n\t\t}\r\n\t\tif ($type.isNaN(position)) {\r\n\t\t\treturn this.basePoint.x;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.renderer.positionToPoint(position).x;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the Y coordinate for series' data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param dataItem  Data item\r\n\t * @param key       Category\r\n\t * @param location  Location (0-1)\r\n\t * @return Y coordinate (px)\r\n\t */\r\n\tpublic getY(dataItem: XYSeriesDataItem, key?: string, location?: number): number {\r\n\t\tlet position;\r\n\t\tif ($type.hasValue(key)) {\r\n\t\t\tposition = this.categoryToPosition(dataItem.categories[key], location);\r\n\t\t}\r\n\t\tif ($type.isNaN(position)) {\r\n\t\t\treturn this.basePoint.y;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.renderer.positionToPoint(position).y;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an angle for series data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param dataItem  Data item\r\n\t * @param key       Category\r\n\t * @param location  Location (0-1)\r\n\t * @param stackKey  Stack key (?)\r\n\t * @return Angle\r\n\t */\r\n\tpublic getAngle(dataItem: XYSeriesDataItem, key: string, location?: number, stackKey?: string): number {\r\n\t\treturn this.positionToAngle(this.categoryToPosition(dataItem.categories[key], location));\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an absolute pixel coordinate of the start of the cell (category),\r\n\t * that specific position value falls into.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param position  Position (px)\r\n\t * @return Cell start position (px)\r\n\t */\r\n\tpublic getCellStartPosition(position: number): number {\r\n\t\treturn this.roundPosition(position, 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an absolute pixel coordinate of the end of the cell (category),\r\n\t * that specific position value falls into.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param position  Position (px)\r\n\t * @return Cell end position (px)\r\n\t */\r\n\tpublic getCellEndPosition(position: number): number {\r\n\t\treturn this.roundPosition(position, 1);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns text to show in a category tooltip, based on specific position\r\n\t * within axis.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param position  Position (px)\r\n\t * @return Label (category)\r\n\t */\r\n\tpublic getTooltipText(position: number): string {\r\n\t\tlet dataItem: this[\"_dataItem\"] = this.dataItems.getIndex(this.positionToIndex(position));\r\n\t\tif (dataItem) {\r\n\t\t\treturn this.adapter.apply(\"getTooltipText\", dataItem.category);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an index of the category that corresponds to specific pixel\r\n\t * position within axis.\r\n\t *\r\n\t * @param position  Position (px)\r\n\t * @return Category index\r\n\t */\r\n\tpublic positionToIndex(position: number): number {\r\n\t\tposition = $math.round(position, 10);\r\n\t\tif (position < 0) {\r\n\t\t\tposition = 0;\r\n\t\t}\r\n\r\n\t\tlet startIndex: number = this.startIndex;\r\n\t\tlet endIndex: number = this.endIndex;\r\n\t\tlet difference: number = endIndex - startIndex;\r\n\r\n\t\tlet axisBreaks = this.axisBreaks;\r\n\r\n\t\tlet index: number = null;\r\n\r\n\t\t// in case we have some axis breaks\r\n\t\t$iter.eachContinue(axisBreaks.iterator(), (axisBreak) => {\r\n\t\t\tlet breakStartPosition: number = axisBreak.startPosition;\r\n\t\t\tlet breakEndPosition: number = axisBreak.endPosition;\r\n\r\n\t\t\tlet breakStartIndex: number = axisBreak.adjustedStartValue;\r\n\t\t\tlet breakEndIndex: number = axisBreak.adjustedEndValue;\r\n\r\n\t\t\tbreakStartIndex = $math.max(breakStartIndex, startIndex);\r\n\t\t\tbreakEndIndex = $math.min(breakEndIndex, endIndex);\r\n\r\n\t\t\tlet breakSize: number = axisBreak.breakSize;\r\n\r\n\t\t\tdifference -= (breakEndIndex - breakStartIndex) * (1 - breakSize);\r\n\r\n\t\t\t// position to the right of break end\r\n\t\t\tif (position > breakEndPosition) {\r\n\t\t\t\tstartIndex += (breakEndIndex - breakStartIndex) * (1 - breakSize);\r\n\t\t\t}\r\n\t\t\t// position to the left of break start\r\n\t\t\telse if (position < breakStartPosition) {\r\n\r\n\t\t\t}\r\n\t\t\t// value within break\r\n\t\t\telse {\r\n\t\t\t\tlet breakPosition = (position - breakStartPosition) / (breakEndPosition - breakStartPosition);\r\n\t\t\t\tindex = breakStartIndex + Math.round(breakPosition * (breakEndIndex - breakStartIndex));\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t});\r\n\r\n\t\tif (!$type.isNumber(index)) {\r\n\t\t\tindex = Math.floor(position * difference + startIndex);\r\n\t\t}\r\n\t\tif (index >= endIndex) {\r\n\t\t\tindex--;\r\n\t\t}\r\n\r\n\t\treturn index;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns category based on position.\r\n\t *\r\n\t * Please note that `position` represents position within axis which may be\r\n\t * zoomed and not correspond to Cursor's `position`.\r\n\t *\r\n\t * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n\t *\r\n\t * This is a synonim of `getPositionLabel()` implemented here for consistentcy.\r\n\t *\r\n\t * @since 4.3.8\r\n\t * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n\t * @param position  Relative position on axis (0-1)\r\n\t * @return Position label\r\n\t */\r\n\tpublic positionToCategory(position: number): string {\r\n\t\treturn this.getPositionLabel(position);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns category based on position.\r\n\t *\r\n\t * Please note that `position` represents position within axis which may be\r\n\t * zoomed and not correspond to Cursor's `position`.\r\n\t *\r\n\t * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n\t * @param position  Relative position on axis (0-1)\r\n\t * @return Position label\r\n\t */\r\n\tpublic getPositionLabel(position: number): string {\r\n\t\tlet dataItem: this[\"_dataItem\"] = this.dataItems.getIndex(this.positionToIndex(position));\r\n\t\tif (dataItem) {\r\n\t\t\treturn dataItem.category;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Coordinates of the actual axis start.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Base point\r\n\t */\r\n\tpublic get basePoint(): IPoint {\r\n\t\t// This makes base grid to be drawn at the end of the axis and adds extra\r\n\t\t// grid which we need to nicely close the chart.\r\n\t\treturn this.renderer.positionToPoint(1);\r\n\t}\r\n\r\n\t/**\r\n\t * Initializes Axis' renderer.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic initRenderer(): void {\r\n\t\tsuper.initRenderer();\r\n\r\n\t\tlet renderer = this.renderer;\r\n\t\trenderer.baseGrid.disabled = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Current frequency of labels of the axis.\r\n\t *\r\n\t * Normally it would be 1, but when labels start to be hidden due\r\n\t * to `minGridDistance` this read-only property will increase.\r\n\t *\r\n\t * @readonly\r\n\t * @since 4.2.0\r\n\t * @return Label frequency\r\n\t */\r\n\tpublic get frequency(): number {\r\n\t\treturn this._frequency;\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"CategoryAxis\"] = CategoryAxis;\r\nregistry.registeredClasses[\"CategoryAxisDataItem\"] = CategoryAxisDataItem;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}