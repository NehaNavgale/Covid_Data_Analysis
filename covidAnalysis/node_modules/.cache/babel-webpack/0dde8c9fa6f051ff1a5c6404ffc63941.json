{"ast":null,"code":"/**\n * Module contains functionality related to [[Sprite]] states.\n */\nimport * as tslib_1 from \"tslib\";\n/**\n * ============================================================================\n * IMPORTS\n * ============================================================================\n * @hidden\n */\n\nimport { BaseObject } from \"./Base\";\nimport { registry } from \"./Registry\";\nimport { Adapter } from \"./utils/Adapter\";\nimport { List, ListDisposer } from \"./utils/List\";\nimport { toColor } from \"./utils/Color\";\nimport { percent } from \"./utils/Percent\";\nimport * as $utils from \"./utils/Utils\";\nimport * as $ease from \"./utils/Ease\";\nimport * as $object from \"./utils/Object\";\nimport * as $type from \"./utils/Type\";\n/**\n * Defines a state for [[Sprite]].\n *\n * A \"state\" is a special object that has all the same properties as the\n * [[Sprite]] of the same type, and which can be used to quickly apply a set\n * of property values. (set state)\n *\n * When [[Sprite]] (or any object that extends Sprite) is created it creates a\n * \"default\" state. You can modify the \"default\" state so that when the Sprite\n * returns to default state certain properties are added.\n *\n * Default state can be accessed using Sprite's `defaultState` getter.\n *\n * ```TypeScript\n * sprite.defaultState.properties.fillOpacity = 0.5;\n * ```\n * ```JavaScript\n * sprite.defaultState.properties.fillOpacity = 0.5;\n * ```\n * ```JSON\n * {\n *   // ...\n *   \"defaultState\": {\n *     \"properties\": {\n *       \"fillOpacity\": 0.5\n *     }\n *   }\n * }\n * ```\n *\n * If Sprite is \"hoverable\", it automatically adds a \"hover\" state, which is\n * applied when it has a cursor over it.\n *\n * ```TypeScript\n * let hoverstate = sprite.states.create(\"hover\");\n * hoverstate.properties.fillOpacity = 1;\n * ```\n * ```JavaScript\n * var hoverstate = sprite.states.create(\"hover\");\n * hoverstate.properties.fillOpacity = 1;\n * ```\n * ```JSON\n * {\n *   // ...\n *   \"states\": {\n *     \"hover\": {\n *       \"properties\": {\n *         \"fillOpacity\": 0.5\n *       }\n *     }\n *   }\n * }\n * ```\n *\n * The above will automatically apply \"hover\" state when the Sprite is hovered,\n * thus will set its `fillOpacity` property to 1, and will reset it to 0.5 when\n * it's no longer hovered.\n *\n * Every object that inherits from [[Sprite]] can and will add their own\n * properties to the available list.\n *\n * User can create their own states, and apply them as needed:\n *\n * ```TypeScript\n * let myCustomState = sprite.states.create(\"mystate\");\n * myCustomState.properties.fillOpacity = 0.5;\n * myCustomState.properties.strokeOpacity = 0.8;\n * sprite.setState(\"mystate\");\n * ```\n * ```JavaScript\n * var myCustomState = sprite.states.create(\"mystate\");\n * myCustomState.properties.fillOpacity = 0.5;\n * myCustomState.properties.strokeOpacity = 0.8;\n * sprite.setState(\"mystate\");\n * ```\n *\n * @see {@link https://www.amcharts.com/docs/v4/concepts/states/}\n * @important\n */\n\nvar SpriteState =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(SpriteState, _super);\n  /**\n   * Constructor\n   */\n\n\n  function SpriteState() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\n     * Holds Adapter.\n     */\n\n\n    _this.adapter = new Adapter(_this);\n    /**\n     * Duration of the transition to this state. 0 means instantenous transition.\n     * Any number means the [[Sprite]] will transit smoothly to this state,\n     * animating all animatable properties.\n     *\n     * @default 0\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/animations/} for more info about animations\n     */\n\n    _this.transitionDuration = 0;\n    /**\n     * Easing function to use when transitioning to this state.\n     *\n     * @default cubicOut\n     * @see {@link Ease}\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/animations/} for more info about animations\n     */\n\n    _this.transitionEasing = $ease.cubicOut;\n    /**\n     * Collection of properties and their values that should be applied to [[Sprite]]\n     * when switching to this State.\n     *\n     * The property values set on a [[SpriteState]] will override the ones set\n     * directly on a [[Sprite]].\n     */\n\n    _this.properties = {};\n    /**\n     * A collection of key/value pairs that can be used to bind specific Sprite\n     * properties to [[DataItem]].\n     *\n     * For example: `fill` property can be bound to `myCustomColor` field in\n     * DataItem. The Sprite will automatically get the value for `fill` from its\n     * DataItem.\n     *\n     * SpriteState-specific binding will override binding set directly on\n     * [[Sprite]]. I.e. you can make Sprite use different fill color on hover by\n     * adding a `fill` binding to a different DataItem key for Sprite's \"hover\"\n     * state object.\n     *\n     * @see {@link Sprite}\n     */\n\n    _this.propertyFields = {}; //public propertyFields: Dictionary<keyof this[\"_properties\"], string> = new Dictionary<keyof this[\"_properties\"], string>();;\n\n    /**\n     * A list of [[Filter]] elements to be applied to the relative [[Sprite]]\n     * when switching to this State.\n     *\n     * @param {List}\n     */\n\n    _this.filters = new List();\n    /**\n     * Identifies if this object is a \"template\" and should not be treated as\n     * real object that is drawn or actually used in the chart.\n     */\n\n    _this.isTemplate = false;\n    _this.className = \"SpriteState\"; // Make filter list disposable\n\n    _this._disposers.push(new ListDisposer(_this.filters)); // Decorate adapter with events so that we can apply its settings whenever\n    // it is modified\n\n\n    _this.adapter.events.on(\"inserted\", function (ev) {\n      _this[ev.newValue.key] = _this[ev.newValue.key];\n    }, undefined, false);\n\n    _this.adapter.events.on(\"removed\", function (ev) {\n      _this[ev.newValue.key] = _this[ev.newValue.key];\n    }, undefined, false); // Apply theme\n\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\n   * Returns [[Sprite]] element's property value.\n   *\n   * Will check if there are any bindings with [[DataItem]] and if there are\n   * any method callbacks set up for the specific property.\n   *\n   * @param propertyName  Property name\n   * @return Property value\n   */\n\n\n  SpriteState.prototype.getPropertyValue = function (propertyName) {\n    var propValue = this.properties[propertyName];\n    var sprite = this.sprite;\n\n    if (sprite) {\n      var fieldName = this.propertyFields[propertyName];\n\n      if ($type.hasValue(fieldName)) {\n        if (sprite.dataItem) {\n          propValue = sprite.dataItem.dataContext[fieldName];\n        }\n      } // Apply adapters\n      // If the value itself is undefined, we're going to pass in Sprite's\n      // value to adapters\n      // @todo get rid of <any>\n\n\n      if (!$type.hasValue(propValue)) {\n        var spriteValue = sprite.getPropertyValue(propertyName);\n        propValue = this.adapter.apply(propertyName, sprite.getPropertyValue(propertyName));\n\n        if (propValue == spriteValue) {\n          propValue = undefined;\n        }\n      } else {\n        propValue = this.adapter.apply(propertyName, propValue);\n      }\n      /*let method = this.propertyMethods.getKey(propertyName);\n      if (method) {\n          propValue = method(sprite, propertyName);\n      }*/\n\n    }\n\n    return propValue;\n  };\n  /**\n   * Copies all property and style values from another [[SpriteState]] object.\n   *\n   * @param source  Source [[SpriteState]]\n   */\n\n\n  SpriteState.prototype.copyFrom = function (source) {\n    if (source && source != this) {\n      this.transitionDuration = source.transitionDuration;\n      this.transitionEasing = source.transitionEasing;\n      $utils.copyProperties(source.properties, this.properties);\n      $utils.copyProperties(source.propertyFields, this.propertyFields);\n      this.filters.copyFrom(source.filters);\n      this.adapter.copyFrom(source.adapter);\n    }\n  };\n\n  Object.defineProperty(SpriteState.prototype, \"allValues\", {\n    /**\n     * Returns all values that should be applied by the SpriteState.\n     *\n     * It takes adapters into account.\n     *\n     * @ignore Exclude from docs\n     * @return Properties\n     * @todo Add adapter values\n     * @todo proper type this[\"_properties\"]\n     */\n    get: function get() {\n      var _this = this; // Init return value\n\n\n      var res = {}; // Apply adapters to all values\n\n      $object.each(this.properties, function (prop, value) {\n        res[prop] = _this.getPropertyValue(prop);\n      }); // Cycle through all adapters and add values for missing properties\n\n      var keys = this.adapter.keys();\n      $object.each(keys, function (_x, prop) {\n        var value = _this.getPropertyValue(prop);\n\n        res[prop] = value;\n      }); // Cycle through all property fileds and add values for missing properties\n\n      var propertyFields = this.propertyFields;\n      $object.each(propertyFields, function (prop) {\n        var value = _this.getPropertyValue(prop);\n\n        res[prop] = value;\n      });\n      return res;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Resets the State to initial state - no values or Filters applied.\n   */\n\n  SpriteState.prototype.reset = function () {\n    this.properties = {};\n    this.filters.clear();\n  };\n  /**\n   * Processes JSON-based config before it is applied to the object.\n   *\n   * @ignore Exclude from docs\n   * @param config  Config\n   */\n\n\n  SpriteState.prototype.processConfig = function (config) {\n    if ($type.hasValue(config) && $type.hasValue(config[\"properties\"])) {\n      $object.each(config[\"properties\"], function (key, value) {\n        if ($type.isString(value)) {\n          if (value.match(/^[0-9.\\-]+\\%$/)) {\n            config[\"properties\"][key] = percent($type.toNumber(value));\n          } else if (value.match(/^\\#[0-9abcdef]{3,}$/i)) {\n            config[\"properties\"][key] = toColor(value);\n          }\n        }\n      });\n    }\n\n    _super.prototype.processConfig.call(this, config);\n  };\n\n  return SpriteState;\n}(BaseObject);\n\nexport { SpriteState };\n/**\n * Register class in system, so that it can be instantiated using its name from\n * anywhere.\n *\n * @ignore\n */\n\nregistry.registeredClasses[\"SpriteState\"] = SpriteState;","map":{"version":3,"sources":["../../../../src/.internal/core/SpriteState.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Module contains functionality related to [[Sprite]] states.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { BaseObject } from \"./Base\";\r\nimport { registry } from \"./Registry\";\r\nimport { Adapter } from \"./utils/Adapter\";\r\nimport { List, ListDisposer } from \"./utils/List\";\r\nimport { Filter } from \"./rendering/filters/Filter\";\r\nimport { Sprite } from \"./Sprite\";\r\n\r\nimport { toColor } from \"./utils/Color\";\r\nimport { percent } from \"./utils/Percent\";\r\nimport * as $utils from \"./utils/Utils\";\r\nimport * as $ease from \"./utils/Ease\";\r\nimport * as $object from \"./utils/Object\";\r\nimport * as $type from \"./utils/Type\";\r\n\r\n/**\r\n * Defines a state for [[Sprite]].\r\n *\r\n * A \"state\" is a special object that has all the same properties as the\r\n * [[Sprite]] of the same type, and which can be used to quickly apply a set\r\n * of property values. (set state)\r\n *\r\n * When [[Sprite]] (or any object that extends Sprite) is created it creates a\r\n * \"default\" state. You can modify the \"default\" state so that when the Sprite\r\n * returns to default state certain properties are added.\r\n *\r\n * Default state can be accessed using Sprite's `defaultState` getter.\r\n *\r\n * ```TypeScript\r\n * sprite.defaultState.properties.fillOpacity = 0.5;\r\n * ```\r\n * ```JavaScript\r\n * sprite.defaultState.properties.fillOpacity = 0.5;\r\n * ```\r\n * ```JSON\r\n * {\r\n *   // ...\r\n *   \"defaultState\": {\r\n *     \"properties\": {\r\n *       \"fillOpacity\": 0.5\r\n *     }\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * If Sprite is \"hoverable\", it automatically adds a \"hover\" state, which is\r\n * applied when it has a cursor over it.\r\n *\r\n * ```TypeScript\r\n * let hoverstate = sprite.states.create(\"hover\");\r\n * hoverstate.properties.fillOpacity = 1;\r\n * ```\r\n * ```JavaScript\r\n * var hoverstate = sprite.states.create(\"hover\");\r\n * hoverstate.properties.fillOpacity = 1;\r\n * ```\r\n * ```JSON\r\n * {\r\n *   // ...\r\n *   \"states\": {\r\n *     \"hover\": {\r\n *       \"properties\": {\r\n *         \"fillOpacity\": 0.5\r\n *       }\r\n *     }\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * The above will automatically apply \"hover\" state when the Sprite is hovered,\r\n * thus will set its `fillOpacity` property to 1, and will reset it to 0.5 when\r\n * it's no longer hovered.\r\n *\r\n * Every object that inherits from [[Sprite]] can and will add their own\r\n * properties to the available list.\r\n *\r\n * User can create their own states, and apply them as needed:\r\n *\r\n * ```TypeScript\r\n * let myCustomState = sprite.states.create(\"mystate\");\r\n * myCustomState.properties.fillOpacity = 0.5;\r\n * myCustomState.properties.strokeOpacity = 0.8;\r\n * sprite.setState(\"mystate\");\r\n * ```\r\n * ```JavaScript\r\n * var myCustomState = sprite.states.create(\"mystate\");\r\n * myCustomState.properties.fillOpacity = 0.5;\r\n * myCustomState.properties.strokeOpacity = 0.8;\r\n * sprite.setState(\"mystate\");\r\n * ```\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/states/}\r\n * @important\r\n */\r\nexport class SpriteState<P, A> extends BaseObject {\r\n\r\n\t/**\r\n\t * Defines property types.\r\n\t */\r\n\tpublic _properties!: P;\r\n\r\n\t/**\r\n\t * Defines adapter types.\r\n\t */\r\n\tpublic _adapter!: A;\r\n\r\n\t/**\r\n\t * Title of the state, i.e. \"default\", \"hidden\", etc.\r\n\t */\r\n\tpublic name: string;\r\n\r\n\t/**\r\n\t * Reference to [[Sprite]] element this State is for.\r\n\t */\r\n\tpublic sprite: $type.Optional<Sprite>;\r\n\r\n\t/**\r\n\t * Holds Adapter.\r\n\t */\r\n\tpublic adapter = new Adapter<this, A>(this);\r\n\r\n\t/**\r\n\t * Duration of the transition to this state. 0 means instantenous transition.\r\n\t * Any number means the [[Sprite]] will transit smoothly to this state,\r\n\t * animating all animatable properties.\r\n\t *\r\n\t * @default 0\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/animations/} for more info about animations\r\n\t */\r\n\tpublic transitionDuration: number = 0;\r\n\r\n\t/**\r\n\t * Easing function to use when transitioning to this state.\r\n\t *\r\n\t * @default cubicOut\r\n\t * @see {@link Ease}\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/animations/} for more info about animations\r\n\t */\r\n\tpublic transitionEasing: (value: number) => number = $ease.cubicOut;\r\n\r\n\t/**\r\n\t * Collection of properties and their values that should be applied to [[Sprite]]\r\n\t * when switching to this State.\r\n\t *\r\n\t * The property values set on a [[SpriteState]] will override the ones set\r\n\t * directly on a [[Sprite]].\r\n\t */\r\n\tpublic properties: P = <P>{};\r\n\r\n\t/**\r\n\t * A collection of key/value pairs that can be used to bind specific Sprite\r\n\t * properties to [[DataItem]].\r\n\t *\r\n\t * For example: `fill` property can be bound to `myCustomColor` field in\r\n\t * DataItem. The Sprite will automatically get the value for `fill` from its\r\n\t * DataItem.\r\n\t *\r\n\t * SpriteState-specific binding will override binding set directly on\r\n\t * [[Sprite]]. I.e. you can make Sprite use different fill color on hover by\r\n\t * adding a `fill` binding to a different DataItem key for Sprite's \"hover\"\r\n\t * state object.\r\n\t *\r\n\t * @see {@link Sprite}\r\n\t */\r\n\tpublic propertyFields: { [index in keyof this[\"_properties\"]]?: string } = {};\r\n\t//public propertyFields: Dictionary<keyof this[\"_properties\"], string> = new Dictionary<keyof this[\"_properties\"], string>();;\r\n\r\n\t/**\r\n\t * A list of [[Filter]] elements to be applied to the relative [[Sprite]]\r\n\t * when switching to this State.\r\n\t *\r\n\t * @param {List}\r\n\t */\r\n\tpublic filters = new List<Filter>();\r\n\r\n\t/**\r\n\t * Identifies if this object is a \"template\" and should not be treated as\r\n\t * real object that is drawn or actually used in the chart.\r\n\t */\r\n\tpublic isTemplate: boolean = false;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"SpriteState\";\r\n\r\n\t\t// Make filter list disposable\r\n\t\tthis._disposers.push(new ListDisposer(this.filters));\r\n\r\n\t\t// Decorate adapter with events so that we can apply its settings whenever\r\n\t\t// it is modified\r\n\t\tthis.adapter.events.on(\"inserted\", (ev: any) => {\r\n\t\t\t(<any>this)[ev.newValue.key] = (<any>this)[ev.newValue.key];\r\n\t\t}, undefined, false);\r\n\t\tthis.adapter.events.on(\"removed\", (ev: any) => {\r\n\t\t\t(<any>this)[ev.newValue.key] = (<any>this)[ev.newValue.key];\r\n\t\t}, undefined, false);\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns [[Sprite]] element's property value.\r\n\t *\r\n\t * Will check if there are any bindings with [[DataItem]] and if there are\r\n\t * any method callbacks set up for the specific property.\r\n\t *\r\n\t * @param propertyName  Property name\r\n\t * @return Property value\r\n\t */\r\n\tpublic getPropertyValue<Key extends keyof P>(propertyName: Key): P[Key] {\r\n\t\tlet propValue: any = this.properties[propertyName];\r\n\t\tlet sprite: $type.Optional<Sprite> = this.sprite;\r\n\r\n\t\tif (sprite) {\r\n\t\t\tlet fieldName: string = this.propertyFields[propertyName];\r\n\r\n\t\t\tif ($type.hasValue(fieldName)) {\r\n\t\t\t\tif (sprite.dataItem) {\r\n\t\t\t\t\tpropValue = (<any>sprite.dataItem.dataContext)[fieldName];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Apply adapters\r\n\t\t\t// If the value itself is undefined, we're going to pass in Sprite's\r\n\t\t\t// value to adapters\r\n\t\t\t// @todo get rid of <any>\r\n\t\t\tif (!$type.hasValue(propValue)) {\r\n\t\t\t\tlet spriteValue = sprite.getPropertyValue(<any>propertyName);\r\n\t\t\t\tpropValue = this.adapter.apply(<any>propertyName, sprite.getPropertyValue(<any>propertyName));\r\n\t\t\t\tif (propValue == spriteValue) {\r\n\t\t\t\t\tpropValue = undefined;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tpropValue = this.adapter.apply(<any>propertyName, propValue)\r\n\t\t\t}\r\n\r\n\t\t\t/*let method = this.propertyMethods.getKey(propertyName);\r\n\t\t\tif (method) {\r\n\t\t\t\tpropValue = method(sprite, propertyName);\r\n\t\t\t}*/\r\n\r\n\t\t}\r\n\r\n\t\treturn propValue;\r\n\t}\r\n\r\n\t/**\r\n\t * Copies all property and style values from another [[SpriteState]] object.\r\n\t *\r\n\t * @param source  Source [[SpriteState]]\r\n\t */\r\n\tpublic copyFrom(source: this) {\r\n\t\tif (source && source != this) {\r\n\t\t\tthis.transitionDuration = source.transitionDuration;\r\n\t\t\tthis.transitionEasing = source.transitionEasing;\r\n\r\n\t\t\t$utils.copyProperties(source.properties, this.properties);\r\n\t\t\t$utils.copyProperties(source.propertyFields, this.propertyFields);\r\n\t\t\tthis.filters.copyFrom(source.filters);\r\n\t\t\tthis.adapter.copyFrom(source.adapter);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns all values that should be applied by the SpriteState.\r\n\t *\r\n\t * It takes adapters into account.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Properties\r\n\t * @todo Add adapter values\r\n\t * @todo proper type this[\"_properties\"]\r\n\t */\r\n\tpublic get allValues(): P {\r\n\r\n\t\t// Init return value\r\n\t\tlet res: P = <P>{};\r\n\r\n\t\t// Apply adapters to all values\r\n\t\t$object.each(this.properties, (prop, value) => {\r\n\t\t\tres[prop] = this.getPropertyValue(prop);\r\n\t\t});\r\n\r\n\t\t// Cycle through all adapters and add values for missing properties\r\n\t\tlet keys = this.adapter.keys();\r\n\r\n\t\t$object.each(keys, (_x, prop) => {\r\n\t\t\tlet value = this.getPropertyValue<any>(prop);\r\n\t\t\t(<any>res)[prop] = value;\r\n\t\t});\r\n\r\n\t\t// Cycle through all property fileds and add values for missing properties\r\n\t\tlet propertyFields = this.propertyFields;\r\n\r\n\t\t$object.each(propertyFields, (prop) => {\r\n\t\t\tlet value = this.getPropertyValue<any>(prop);\r\n\t\t\t(<any>res)[prop] = value;\r\n\t\t});\r\n\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Resets the State to initial state - no values or Filters applied.\r\n\t */\r\n\tpublic reset(): void {\r\n\t\tthis.properties = <P>{};\r\n\t\tthis.filters.clear();\r\n\t}\r\n\r\n\t/**\r\n\t * Processes JSON-based config before it is applied to the object.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param config  Config\r\n\t */\r\n\tpublic processConfig(config?: { [index: string]: any }): void {\r\n\r\n\t\tif ($type.hasValue(config) && $type.hasValue(config[\"properties\"])) {\r\n\t\t\t$object.each(config[\"properties\"], (key, value) => {\r\n\t\t\t\tif ($type.isString(value)) {\r\n\t\t\t\t\tif (value.match(/^[0-9.\\-]+\\%$/)) {\r\n\t\t\t\t\t\tconfig[\"properties\"][key] = percent($type.toNumber(value));\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (value.match(/^\\#[0-9abcdef]{3,}$/i)) {\r\n\t\t\t\t\t\tconfig[\"properties\"][key] = toColor(value);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tsuper.processConfig(config);\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"SpriteState\"] = SpriteState;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}