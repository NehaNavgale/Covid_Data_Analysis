{"ast":null,"code":"/**\n * Number formatting-related functionality.\n */\nimport * as tslib_1 from \"tslib\";\nimport { Language } from \"../utils/Language\";\nimport { BaseObject } from \"../Base\";\nimport { getTextFormatter } from \"../formatters/TextFormatter\";\nimport { registry } from \"../Registry\";\nimport * as $strings from \"../utils/Strings\";\nimport * as $object from \"../utils/Object\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $type from \"../utils/Type\";\n/**\n * NumberFormatter class. Formats numbers according to specified formats.\n *\n * @todo Apply translations to suffixes/prefixes\n */\n\nvar NumberFormatter =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(NumberFormatter, _super);\n  /**\n   * Constructor\n   */\n\n\n  function NumberFormatter() {\n    var _this = _super.call(this) || this;\n    /**\n     * A base value for negative numbers. Will treat all numbers below this value\n     * as negative numbers.\n     */\n\n\n    _this._negativeBase = 0;\n    /**\n     * Holds number format.\n     *\n     * @default #,###.#####\n     */\n\n    _this._numberFormat = \"#,###.#####\";\n    /**\n     * Output format to produce. If the format calls for applying color to the\n     * formatted value, this setting will determine what markup to use: SVG or\n     * HTML.\n     *\n     * Available options: svg, html.\n     *\n     * @default \"svg\"\n     */\n\n    _this._outputFormat = \"svg\";\n    _this.className = \"NumberFormatter\";\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  NumberFormatter.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n\n    if (this.language) {\n      this.language.dispose();\n    }\n  };\n\n  Object.defineProperty(NumberFormatter.prototype, \"language\", {\n    /**\n     * @return Language\n     */\n    get: function get() {\n      if (!this._language) {\n        if (this.sprite) {\n          this._language = this.sprite.language;\n        } else {\n          this._language = new Language();\n        }\n      }\n\n      return this._language;\n    },\n\n    /**\n     * A reference to [[Language]] instance.\n     *\n     * Formatter will use language to translate various items, like number\n     * suffixes, etc.\n     *\n     * @param value  Language\n     */\n    set: function set(value) {\n      this._language = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Formats the number according to specific format.\n   *\n   * @param value   Value to format\n   * @param format  Format to apply\n   * @return Formatted number\n   */\n\n  NumberFormatter.prototype.format = function (value, format) {\n    // no format passed in or \"Number\"\n    if (typeof format === \"undefined\" || format.toLowerCase() === \"number\") {\n      format = this._numberFormat;\n    } // Clean format\n\n\n    format = $utils.cleanFormat(format); // Get format info (it will also deal with parser caching)\n\n    var info = this.parseFormat(format, this.language); // cast to number just in case\n    // TODO: maybe use better casting\n\n    var source = Number(value); // format and replace the number\n\n    var details;\n\n    if (source > this._negativeBase) {\n      details = info.positive;\n    } else if (source < this._negativeBase) {\n      details = info.negative;\n    } else {\n      details = info.zero;\n    } // Format\n\n\n    var formatted = details.template.split($strings.PLACEHOLDER).join(this.applyFormat(source, details));\n    return formatted;\n  };\n  /**\n   * Parses supplied format into structured object which can be used to format\n   * the number.\n   *\n   * @param format Format string, i.e. \"#,###.00\"\n   * @param language Language\n   */\n\n\n  NumberFormatter.prototype.parseFormat = function (format, language) {\n    var _this = this; // Check cache\n\n\n    var cached = this.getCache(format);\n\n    if ($type.hasValue(cached)) {\n      return cached;\n    } // init format parse info holder\n\n\n    var info = {\n      \"positive\": {\n        \"thousands\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"interval\": -1,\n          \"separator\": language.translateEmpty(\"_thousandSeparator\")\n        },\n        \"decimals\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"separator\": language.translateEmpty(\"_decimalSeparator\")\n        },\n        \"template\": \"\",\n        \"source\": \"\",\n        \"parsed\": false\n      },\n      \"negative\": {\n        \"thousands\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"interval\": -1,\n          \"separator\": language.translateEmpty(\"_thousandSeparator\")\n        },\n        \"decimals\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"separator\": language.translateEmpty(\"_decimalSeparator\")\n        },\n        \"template\": \"\",\n        \"source\": \"\",\n        \"parsed\": false\n      },\n      \"zero\": {\n        \"thousands\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"interval\": -1,\n          \"separator\": language.translateEmpty(\"_thousandSeparator\")\n        },\n        \"decimals\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"separator\": language.translateEmpty(\"_decimalSeparator\")\n        },\n        \"template\": \"\",\n        \"source\": \"\",\n        \"parsed\": false\n      }\n    }; // Escape double vertical bars (that mean display one vertical bar)\n\n    format = format.replace(\"||\", $strings.PLACEHOLDER2); // Split it up and deal with different formats\n\n    var parts = format.split(\"|\");\n    info.positive.source = parts[0];\n\n    if (typeof parts[2] === \"undefined\") {\n      info.zero = info.positive;\n    } else {\n      info.zero.source = parts[2];\n    }\n\n    if (typeof parts[1] === \"undefined\") {\n      info.negative = info.positive;\n    } else {\n      info.negative.source = parts[1];\n    } // Parse each\n\n\n    $object.each(info, function (part, item) {\n      // Already parsed\n      if (item.parsed) {\n        return;\n      } // Check cached\n\n\n      if (typeof _this.getCache(item.source) !== \"undefined\") {\n        info[part] = _this.getCache(item.source);\n        return;\n      } // Begin parsing\n\n\n      var partFormat = item.source; // Just \"Number\"?\n\n      if (partFormat.toLowerCase() === \"number\") {\n        partFormat = _this._numberFormat;\n      } // Let TextFormatter split into chunks\n\n\n      var chunks = getTextFormatter().chunk(partFormat, true);\n\n      for (var i = 0; i < chunks.length; i++) {\n        var chunk = chunks[i]; // replace back double vertical bar\n\n        chunk.text = chunk.text.replace($strings.PLACEHOLDER2, \"|\");\n\n        if (chunk.type === \"value\") {\n          // Parse format\n          // Look for codes\n          var matches = chunk.text.match(/[#0.,]+[ ]?[abesABES%]?[abesABES‰]?/);\n\n          if (matches) {\n            if (matches === null || matches[0] === \"\") {\n              // no codes here - assume string\n              // nothing to do here\n              item.template += chunk.text;\n            } else {\n              // look for the format modifiers at the end\n              var mods = matches[0].match(/[abesABES%‰]{2}|[abesABES%‰]{1}$/);\n\n              if (mods) {\n                item.mod = mods[0].toLowerCase();\n                item.modSpacing = matches[0].match(/[ ]{1}[abesABES%‰]{1}$/) ? true : false;\n              } // break the format up\n\n\n              var a = matches[0].split(\".\"); // Deal with thousands\n\n              if (a[0] === \"\") {// No directives for thousands\n                // Leave default settings (no formatting)\n              } else {\n                // Counts\n                item.thousands.active = (a[0].match(/0/g) || []).length;\n                item.thousands.passive = (a[0].match(/\\#/g) || []).length + item.thousands.active; // Separator interval\n\n                var b = a[0].split(\",\");\n\n                if (b.length === 1) {// No thousands separators\n                  // Do nothing\n                } else {\n                  // Use length fo the last chunk as thousands length\n                  item.thousands.interval = $type.getValue(b.pop()).length;\n\n                  if (item.thousands.interval === 0) {\n                    item.thousands.interval = -1;\n                  }\n                }\n              } // Deal with decimals\n\n\n              if (typeof a[1] === \"undefined\") {// No directives for decimals\n                // Leave at defaults (no formatting)\n              } else {\n                // Counts\n                item.decimals.active = (a[1].match(/0/g) || []).length;\n                item.decimals.passive = (a[1].match(/\\#/g) || []).length + item.decimals.active;\n              } // Add special code to template\n\n\n              item.template += chunk.text.split(matches[0]).join($strings.PLACEHOLDER);\n            }\n          }\n        } else {\n          // Quoted string - take it as it is\n          item.template += chunk.text;\n        }\n      } // Apply style formatting\n      //item.template = getTextFormatter().format(item.template, this.outputFormat);\n      // Save cache\n\n\n      _this.setCache(item.source, item); // Mark this as parsed\n\n\n      item.parsed = true;\n    }); // Save cache (the whole thing)\n\n    this.setCache(format, info);\n    return info;\n  };\n  /**\n   * Applies parsed format to a numeric value.\n   *\n   * @param value    Value\n   * @param details  Parsed format as returned by {parseFormat}\n   * @return Formatted number\n   */\n\n\n  NumberFormatter.prototype.applyFormat = function (value, details) {\n    // Use absolute values\n    var negative = value < 0;\n    value = Math.abs(value); // Recalculate according to modifier\n\n    var prefix = \"\",\n        suffix = \"\";\n    var mods = details.mod ? details.mod.split(\"\") : [];\n\n    if (mods.indexOf(\"b\") !== -1) {\n      var a_1 = this.applyPrefix(value, this.bytePrefixes);\n      value = a_1[0];\n      prefix = a_1[1];\n      suffix = a_1[2];\n\n      if (details.modSpacing) {\n        suffix = \" \" + suffix;\n      }\n    } else if (mods.indexOf(\"a\") !== -1) {\n      var a_2 = this.applyPrefix(value, value < 1.00 ? this.smallNumberPrefixes : this.bigNumberPrefixes);\n      value = a_2[0];\n      prefix = a_2[1];\n      suffix = a_2[2];\n\n      if (details.modSpacing) {\n        suffix = \" \" + suffix;\n      }\n    } else if (mods.indexOf(\"%\") !== -1) {\n      value *= 100;\n      suffix = \"%\";\n    } else if (mods.indexOf(\"‰\") !== -1) {\n      value *= 1000;\n      suffix = \"‰\";\n    } // Round to passive\n\n\n    if (mods.indexOf(\"e\") !== -1) {\n      // convert the value to exponential\n      var exp = void 0;\n\n      if (details.decimals.passive >= 0) {\n        exp = value.toExponential(details.decimals.passive).split(\"e\");\n      } else {\n        exp = value.toExponential().split(\"e\");\n      }\n\n      value = Number(exp[0]);\n      suffix = \"e\" + exp[1];\n\n      if (details.modSpacing) {\n        suffix = \" \" + suffix;\n      }\n    } else if (details.decimals.passive === 0) {\n      value = Math.round(value);\n    } else if (details.decimals.passive > 0) {\n      var d = Math.pow(10, details.decimals.passive);\n      value = Math.round(value * d) / d;\n    } // Init return value\n\n\n    var res = \"\"; // Calc integer and decimal parts\n\n    var a = $utils.numberToString(value).split(\".\"); // Format integers\n\n    var ints = a[0]; // Pad integers to active length\n\n    if (ints.length < details.thousands.active) {\n      ints = Array(details.thousands.active - ints.length + 1).join(\"0\") + ints;\n    } // Insert thousands separators\n\n\n    if (details.thousands.interval > 0) {\n      var ip = [];\n      var intsr = ints.split(\"\").reverse().join(\"\");\n\n      for (var i = 0, len = ints.length; i <= len; i += details.thousands.interval) {\n        var c = intsr.substr(i, details.thousands.interval).split(\"\").reverse().join(\"\");\n\n        if (c !== \"\") {\n          ip.unshift(c);\n        }\n      }\n\n      ints = ip.join(details.thousands.separator);\n    } // Add integers\n\n\n    res += ints; // Add decimals\n\n    if (a.length === 1) {\n      a.push(\"\");\n    }\n\n    var decs = a[1]; // Fill zeros?\n\n    if (decs.length < details.decimals.active) {\n      decs += Array(details.decimals.active - decs.length + 1).join(\"0\");\n    }\n\n    if (decs !== \"\") {\n      res += details.decimals.separator + decs;\n    } // Can't have empty return value\n\n\n    if (res === \"\") {\n      res = \"0\";\n    } // Add minus sign back\n\n\n    if (value !== 0 && negative && mods.indexOf(\"s\") === -1) {\n      res = \"-\" + res;\n    } // Add suffixes/prefixes\n\n\n    if (prefix) {\n      res = prefix + res;\n    }\n\n    if (suffix) {\n      res += suffix;\n    }\n\n    return res;\n  };\n  /**\n   * Chooses appropriate prefix and suffix based on the passed in rules.\n   *\n   * @param value     Value\n   * @param prefixes  Prefix array\n   * @return Result\n   */\n\n\n  NumberFormatter.prototype.applyPrefix = function (value, prefixes) {\n    var newvalue = value,\n        prefix = \"\",\n        suffix = \"\";\n\n    for (var i = 0, len = prefixes.length; i < len; i++) {\n      if (prefixes[i].number <= value) {\n        if (prefixes[i].number === 0) {\n          newvalue = 0;\n        } else {\n          newvalue = value / prefixes[i].number;\n        }\n\n        prefix = prefixes[i].prefix;\n        suffix = prefixes[i].suffix;\n      }\n    }\n\n    return [newvalue, prefix, suffix];\n  };\n  /**\n   * Invalidates the parent [[Sprite]] object.\n   */\n\n\n  NumberFormatter.prototype.invalidateSprite = function () {\n    if (this.sprite) {\n      this.sprite.invalidate();\n    }\n  };\n\n  Object.defineProperty(NumberFormatter.prototype, \"numberFormat\", {\n    /**\n     * @return A format to use for number formatting\n     */\n    get: function get() {\n      return this._numberFormat;\n    },\n\n    /**\n     * Number format.\n     *\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\n     * @param format  A format to use for number formatting\n     */\n    set: function set(format) {\n      this._numberFormat = format;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"negativeBase\", {\n    /**\n     * @return A format to use for number formatting\n     */\n    get: function get() {\n      return this._negativeBase;\n    },\n\n    /**\n     * Negative base for negative numbers.\n     *\n     * @default 0\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\n     * @param format  A format to use for number formatting\n     */\n    set: function set(value) {\n      this._negativeBase = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"bigNumberPrefixes\", {\n    /**\n     * @return Prefixes for big numbers\n     */\n    get: function get() {\n      if (!$type.hasValue(this._bigNumberPrefixes)) {\n        this._bigNumberPrefixes = [{\n          \"number\": 1e+3,\n          \"suffix\": this.language.translate(\"_big_number_suffix_3\")\n        }, {\n          \"number\": 1e+6,\n          \"suffix\": this.language.translate(\"_big_number_suffix_6\")\n        }, {\n          \"number\": 1e+9,\n          \"suffix\": this.language.translate(\"_big_number_suffix_9\")\n        }, {\n          \"number\": 1e+12,\n          \"suffix\": this.language.translate(\"_big_number_suffix_12\")\n        }, {\n          \"number\": 1e+15,\n          \"suffix\": this.language.translate(\"_big_number_suffix_15\")\n        }, {\n          \"number\": 1e+18,\n          \"suffix\": this.language.translate(\"_big_number_suffix_18\")\n        }, {\n          \"number\": 1e+21,\n          \"suffix\": this.language.translate(\"_big_number_suffix_21\")\n        }, {\n          \"number\": 1e+24,\n          \"suffix\": this.language.translate(\"_big_number_suffix_24\")\n        }];\n      }\n\n      return this._bigNumberPrefixes;\n    },\n\n    /**\n     * Prefixes for big numbers.\n     *\n     * It's an array of objects of number/prefix pairs.\n     *\n     * ```JSON\n     * [\n     *   { \"number\": 1e+3, \"suffix\": \"K\" },\n     *   { \"number\": 1e+6, \"suffix\": \"M\" },\n     *   { \"number\": 1e+9, \"suffix\": \"G\" },\n     *   { \"number\": 1e+12, \"suffix\": \"T\" },\n     *   { \"number\": 1e+15, \"suffix\": \"P\" },\n     *   { \"number\": 1e+18, \"suffix\": \"E\" },\n     *   { \"number\": 1e+21, \"suffix\": \"Z\" },\n     *   { \"number\": 1e+24, \"suffix\": \"Y\" }\n     * ]\n     * ```\n     *\n     * If the number is bigger than the `number` ir will be converted to the\n     * appropriate bigger number with prefix.\n     *\n     * E.g. as per above `1500` will be converted to `1.5K`.\n     *\n     * Please note that for this transformation to be enabled, you need to\n     * enable it specific modifier in your format setting.\n     *\n     * The modifier for big/small number modification is \"a\":\n     *\n     * ```Text\n     * {myfield.formatNumber(\"#,###.00a\")}\n     * ```\n     *\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\n     * @param prefixes  Prefixes for big numbers\n     */\n    set: function set(prefixes) {\n      this._bigNumberPrefixes = prefixes;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"smallNumberPrefixes\", {\n    /**\n     * @return Prefixes for small numbers\n     */\n    get: function get() {\n      if (!$type.hasValue(this._smallNumberPrefixes)) {\n        this._smallNumberPrefixes = [{\n          \"number\": 1e-24,\n          \"suffix\": this.language.translate(\"_small_number_suffix_24\")\n        }, {\n          \"number\": 1e-21,\n          \"suffix\": this.language.translate(\"_small_number_suffix_21\")\n        }, {\n          \"number\": 1e-18,\n          \"suffix\": this.language.translate(\"_small_number_suffix_18\")\n        }, {\n          \"number\": 1e-15,\n          \"suffix\": this.language.translate(\"_small_number_suffix_15\")\n        }, {\n          \"number\": 1e-12,\n          \"suffix\": this.language.translate(\"_small_number_suffix_12\")\n        }, {\n          \"number\": 1e-9,\n          \"suffix\": this.language.translate(\"_small_number_suffix_9\")\n        }, {\n          \"number\": 1e-6,\n          \"suffix\": this.language.translate(\"_small_number_suffix_6\")\n        }, {\n          \"number\": 1e-3,\n          \"suffix\": this.language.translate(\"_small_number_suffix_3\")\n        }];\n      }\n\n      return this._smallNumberPrefixes;\n    },\n\n    /**\n     * Prefixes for big numbers.\n     *\n     * It's an array of objects of number/prefix pairs.\n     *\n     * ```JSON\n     * [\n     *   { \"number\": 1e-24, \"suffix\": \"y\" },\n     *   { \"number\": 1e-21, \"suffix\": \"z\" },\n     *   { \"number\": 1e-18, \"suffix\": \"a\" },\n     *   { \"number\": 1e-15, \"suffix\": \"f\" },\n     *   { \"number\": 1e-12, \"suffix\": \"p\" },\n     *   { \"number\": 1e-9, \"suffix\": \"n\" },\n     *   { \"number\": 1e-6, \"suffix\": \"μ\" },\n     *   { \"number\": 1e-3, \"suffix\": \"m\" }\n     * ]\n     * ```\n     *\n     * If the number is smaller than the `number` ir will be converted to the\n     * appropriate smaller number with prefix.\n     *\n     * E.g. as per above `0.0015` will be converted to `1.5m`.\n     *\n     * Please note that for this transformation to be enabled, you need to\n     * enable it specific modifier in your format setting.\n     *\n     * The modifier for big/small number modification is \"a\":\n     *\n     * ```Text\n     * {myfield.formatNumber(\"#,###.00a\")}\n     * ```\n     *\n     * IMPORTANT: The order of the suffixes is important. The list must start\n     * from the smallest number and work towards bigger ones.\n     *\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\n     * @param prefixes  Prefixes for small numbers\n     */\n    set: function set(prefixes) {\n      this._smallNumberPrefixes = prefixes;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"bytePrefixes\", {\n    /**\n     * @return Prefixes for byte-size formatting\n     */\n    get: function get() {\n      if (!$type.hasValue(this._bytePrefixes)) {\n        this._bytePrefixes = [{\n          \"number\": 0,\n          suffix: this.language.translate(\"_byte_suffix_B\")\n        }, {\n          \"number\": 1024,\n          suffix: this.language.translate(\"_byte_suffix_KB\")\n        }, {\n          \"number\": 1048576,\n          suffix: this.language.translate(\"_byte_suffix_MB\")\n        }, {\n          \"number\": 1073741824,\n          suffix: this.language.translate(\"_byte_suffix_GB\")\n        }, {\n          \"number\": 1099511627776,\n          suffix: this.language.translate(\"_byte_suffix_TB\")\n        }, {\n          \"number\": 1125899906842624,\n          suffix: this.language.translate(\"_byte_suffix_PB\")\n        }];\n      }\n\n      return this._bytePrefixes;\n    },\n\n    /**\n     * Basically the same as `bigNumberPrefixes`, except base for calculation\n     * is not thousand but byte (1024).\n     *\n     * The modifier is \"b\".\n     *\n     *  ```Text\n     * {myfield.formatNumber(\"#,###.00b\")}\n     * ```\n     *\n     * The above `2048` will change to `2K`.\n     *\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\n     * @param prefixes  Prefixes for byte-size formatting\n     */\n    set: function set(prefixes) {\n      this._bytePrefixes = prefixes;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"outputFormat\", {\n    /**\n     * @ignore Exclude from docs\n     * @return Output format\n     */\n    get: function get() {\n      return this._outputFormat;\n    },\n\n    /**\n     * Ooutput format: \"svg\" or \"html\".\n     *\n     * @ignore Exclude from docs\n     * @param value  Output format\n     */\n    set: function set(outputFormat) {\n      this._outputFormat = outputFormat.toLowerCase();\n      this.invalidateSprite();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Replaces brackets with temporary placeholders.\n   *\n   * @ignore Exclude from docs\n   * @param text  Input text\n   * @return Escaped text\n   */\n\n  NumberFormatter.prototype.escape = function (text) {\n    return text.replace(\"||\", $strings.PLACEHOLDER2);\n  };\n  /**\n   * Replaces placeholders back to brackets.\n   *\n   * @ignore Exclude from docs\n   * @param text  Escaped text\n   * @return Unescaped text\n   */\n\n\n  NumberFormatter.prototype.unescape = function (text) {\n    return text.replace($strings.PLACEHOLDER2, \"|\");\n  };\n\n  return NumberFormatter;\n}(BaseObject);\n\nexport { NumberFormatter };\n/**\n * Register class in system, so that it can be instantiated using its name from\n * anywhere.\n *\n * @ignore\n */\n\nregistry.registeredClasses[\"NumberFormatter\"] = NumberFormatter;","map":{"version":3,"sources":["../../../../../src/.internal/core/formatters/NumberFormatter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Number formatting-related functionality.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Sprite } from \"../Sprite\";\r\nimport { Language } from \"../utils/Language\";\r\nimport { BaseObject } from \"../Base\";\r\nimport { ITextChunk, getTextFormatter } from \"../formatters/TextFormatter\";\r\nimport { registry } from \"../Registry\";\r\nimport * as $strings from \"../utils/Strings\";\r\nimport * as $object from \"../utils/Object\";\r\nimport * as $utils from \"../utils/Utils\";\r\nimport * as $type from \"../utils/Type\";\r\n\r\n/**\r\n * @ignore\r\n */\r\nexport interface INumberSuffix {\r\n\tnumber: number;\r\n\tsuffix: string;\r\n}\r\n\r\n/**\r\n * NumberFormatter class. Formats numbers according to specified formats.\r\n *\r\n * @todo Apply translations to suffixes/prefixes\r\n */\r\nexport class NumberFormatter extends BaseObject {\r\n\r\n\t/**\r\n\t * A base value for negative numbers. Will treat all numbers below this value\r\n\t * as negative numbers.\r\n\t */\r\n\tprotected _negativeBase: number = 0;\r\n\r\n\t/**\r\n\t * Holds number format.\r\n\t *\r\n\t * @default #,###.#####\r\n\t */\r\n\tprotected _numberFormat = \"#,###.#####\";\r\n\r\n\t/**\r\n\t * Output format to produce. If the format calls for applying color to the\r\n\t * formatted value, this setting will determine what markup to use: SVG or\r\n\t * HTML.\r\n\t *\r\n\t * Available options: svg, html.\r\n\t *\r\n\t * @default \"svg\"\r\n\t */\r\n\tprotected _outputFormat: string = \"svg\";\r\n\r\n\t/**\r\n\t * Holds big number prefixes to apply to numbers if `a` modifier is used in\r\n\t * format.\r\n\t */\r\n\tprotected _bigNumberPrefixes: INumberSuffix[];\r\n\r\n\t/**\r\n\t * Holds small number prefixes to apply to numbers if `a` modifier is used in\r\n\t * format.\r\n\t */\r\n\tprotected _smallNumberPrefixes: INumberSuffix[];\r\n\r\n\t/**\r\n\t * Holds prefixes to apply to data size numbers if `b` modifier is used in\r\n\t * format.\r\n\t */\r\n\tprotected _bytePrefixes: INumberSuffix[];\r\n\r\n\t/**\r\n\t * Holds reference to parent [[Sprite]] object.\r\n\t */\r\n\tpublic sprite: $type.Optional<Sprite>;\r\n\r\n\t/**\r\n\t * Holds reference to [[Language]] object.\r\n\t */\r\n\tprivate _language: $type.Optional<Language>;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"NumberFormatter\";\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\tpublic dispose(): void {\r\n\t\tsuper.dispose();\r\n\r\n\t\tif (this.language) {\r\n\t\t\tthis.language.dispose();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * A reference to [[Language]] instance.\r\n\t *\r\n\t * Formatter will use language to translate various items, like number\r\n\t * suffixes, etc.\r\n\t *\r\n\t * @param value  Language\r\n\t */\r\n\tpublic set language(value: Language) {\r\n\t\tthis._language = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Language\r\n\t */\r\n\tpublic get language(): Language {\r\n\t\tif (!this._language) {\r\n\t\t\tif (this.sprite) {\r\n\t\t\t\tthis._language = this.sprite.language;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis._language = new Language;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this._language;\r\n\t}\r\n\r\n\t/**\r\n\t * Formats the number according to specific format.\r\n\t *\r\n\t * @param value   Value to format\r\n\t * @param format  Format to apply\r\n\t * @return Formatted number\r\n\t */\r\n\tpublic format(value: number | string, format?: string): string {\r\n\r\n\t\t// no format passed in or \"Number\"\r\n\t\tif (typeof format === \"undefined\" || format.toLowerCase() === \"number\") {\r\n\t\t\tformat = this._numberFormat;\r\n\t\t}\r\n\r\n\t\t// Clean format\r\n\t\tformat = $utils.cleanFormat(format);\r\n\r\n\t\t// Get format info (it will also deal with parser caching)\r\n\t\tlet info = this.parseFormat(format, this.language);\r\n\r\n\t\t// cast to number just in case\r\n\t\t// TODO: maybe use better casting\r\n\t\tlet source: number = Number(value);\r\n\r\n\t\t// format and replace the number\r\n\t\tlet details;\r\n\t\tif (source > this._negativeBase) {\r\n\t\t\tdetails = info.positive;\r\n\t\t}\r\n\t\telse if (source < this._negativeBase) {\r\n\t\t\tdetails = info.negative;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdetails = info.zero;\r\n\t\t}\r\n\r\n\t\t// Format\r\n\t\tlet formatted = details.template.split($strings.PLACEHOLDER).join(this.applyFormat(source, details));\r\n\r\n\t\treturn formatted;\r\n\t}\r\n\r\n\t/**\r\n\t * Parses supplied format into structured object which can be used to format\r\n\t * the number.\r\n\t *\r\n\t * @param format Format string, i.e. \"#,###.00\"\r\n\t * @param language Language\r\n\t */\r\n\tprotected parseFormat(format: string, language: Language): any {\r\n\r\n\t\t// Check cache\r\n\t\tlet cached = this.getCache(format);\r\n\t\tif ($type.hasValue(cached)) {\r\n\t\t\treturn cached;\r\n\t\t}\r\n\r\n\t\t// init format parse info holder\r\n\t\tlet info: any = {\r\n\t\t\t\"positive\": {\r\n\t\t\t\t\"thousands\": {\r\n\t\t\t\t\t\"active\": -1,\r\n\t\t\t\t\t\"passive\": -1,\r\n\t\t\t\t\t\"interval\": -1,\r\n\t\t\t\t\t\"separator\": language.translateEmpty(\"_thousandSeparator\")\r\n\t\t\t\t},\r\n\t\t\t\t\"decimals\": {\r\n\t\t\t\t\t\"active\": -1,\r\n\t\t\t\t\t\"passive\": -1,\r\n\t\t\t\t\t\"separator\": language.translateEmpty(\"_decimalSeparator\")\r\n\t\t\t\t},\r\n\t\t\t\t\"template\": \"\",\r\n\t\t\t\t\"source\": \"\",\r\n\t\t\t\t\"parsed\": false\r\n\t\t\t},\r\n\t\t\t\"negative\": {\r\n\t\t\t\t\"thousands\": {\r\n\t\t\t\t\t\"active\": -1,\r\n\t\t\t\t\t\"passive\": -1,\r\n\t\t\t\t\t\"interval\": -1,\r\n\t\t\t\t\t\"separator\": language.translateEmpty(\"_thousandSeparator\")\r\n\t\t\t\t},\r\n\t\t\t\t\"decimals\": {\r\n\t\t\t\t\t\"active\": -1,\r\n\t\t\t\t\t\"passive\": -1,\r\n\t\t\t\t\t\"separator\": language.translateEmpty(\"_decimalSeparator\")\r\n\t\t\t\t},\r\n\t\t\t\t\"template\": \"\",\r\n\t\t\t\t\"source\": \"\",\r\n\t\t\t\t\"parsed\": false\r\n\t\t\t},\r\n\t\t\t\"zero\": {\r\n\t\t\t\t\"thousands\": {\r\n\t\t\t\t\t\"active\": -1,\r\n\t\t\t\t\t\"passive\": -1,\r\n\t\t\t\t\t\"interval\": -1,\r\n\t\t\t\t\t\"separator\": language.translateEmpty(\"_thousandSeparator\")\r\n\t\t\t\t},\r\n\t\t\t\t\"decimals\": {\r\n\t\t\t\t\t\"active\": -1,\r\n\t\t\t\t\t\"passive\": -1,\r\n\t\t\t\t\t\"separator\": language.translateEmpty(\"_decimalSeparator\")\r\n\t\t\t\t},\r\n\t\t\t\t\"template\": \"\",\r\n\t\t\t\t\"source\": \"\",\r\n\t\t\t\t\"parsed\": false\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// Escape double vertical bars (that mean display one vertical bar)\r\n\t\tformat = format.replace(\"||\", $strings.PLACEHOLDER2);\r\n\r\n\t\t// Split it up and deal with different formats\r\n\t\tlet parts = format.split(\"|\");\r\n\t\tinfo.positive.source = parts[0];\r\n\r\n\t\tif (typeof parts[2] === \"undefined\") {\r\n\t\t\tinfo.zero = info.positive;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tinfo.zero.source = parts[2];\r\n\t\t}\r\n\r\n\t\tif (typeof parts[1] === \"undefined\") {\r\n\t\t\tinfo.negative = info.positive;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tinfo.negative.source = parts[1];\r\n\t\t}\r\n\r\n\t\t// Parse each\r\n\t\t$object.each(info, (part, item) => {\r\n\t\t\t// Already parsed\r\n\t\t\tif (item.parsed) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Check cached\r\n\t\t\tif (typeof this.getCache(item.source) !== \"undefined\") {\r\n\t\t\t\tinfo[part] = this.getCache(item.source);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Begin parsing\r\n\t\t\tlet partFormat: string = item.source;\r\n\r\n\t\t\t// Just \"Number\"?\r\n\t\t\tif (partFormat.toLowerCase() === \"number\") {\r\n\t\t\t\tpartFormat = this._numberFormat;\r\n\t\t\t}\r\n\r\n\t\t\t// Let TextFormatter split into chunks\r\n\t\t\tlet chunks: ITextChunk[] = getTextFormatter().chunk(partFormat, true);\r\n\t\t\tfor (let i: number = 0; i < chunks.length; i++) {\r\n\t\t\t\tlet chunk: ITextChunk = chunks[i];\r\n\r\n\t\t\t\t// replace back double vertical bar\r\n\t\t\t\tchunk.text = chunk.text.replace($strings.PLACEHOLDER2, \"|\");\r\n\r\n\t\t\t\tif (chunk.type === \"value\") {\r\n\t\t\t\t\t// Parse format\r\n\r\n\t\t\t\t\t// Look for codes\r\n\t\t\t\t\tlet matches: string[] | null = chunk.text.match(/[#0.,]+[ ]?[abesABES%]?[abesABES‰]?/);\r\n\r\n\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\tif (matches === null || matches[0] === \"\") {\r\n\t\t\t\t\t\t\t// no codes here - assume string\r\n\t\t\t\t\t\t\t// nothing to do here\r\n\t\t\t\t\t\t\titem.template += chunk.text;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t\t// look for the format modifiers at the end\r\n\t\t\t\t\t\t\tlet mods: string[] | null = matches[0].match(/[abesABES%‰]{2}|[abesABES%‰]{1}$/);\r\n\r\n\t\t\t\t\t\t\tif (mods) {\r\n\t\t\t\t\t\t\t\titem.mod = mods[0].toLowerCase();\r\n\t\t\t\t\t\t\t\titem.modSpacing = matches[0].match(/[ ]{1}[abesABES%‰]{1}$/) ? true : false;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// break the format up\r\n\t\t\t\t\t\t\tlet a = matches[0].split(\".\");\r\n\r\n\t\t\t\t\t\t\t// Deal with thousands\r\n\t\t\t\t\t\t\tif (a[0] === \"\") {\r\n\t\t\t\t\t\t\t\t// No directives for thousands\r\n\t\t\t\t\t\t\t\t// Leave default settings (no formatting)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t// Counts\r\n\t\t\t\t\t\t\t\titem.thousands.active = (a[0].match(/0/g) || []).length;\r\n\t\t\t\t\t\t\t\titem.thousands.passive = (a[0].match(/\\#/g) || []).length + item.thousands.active;\r\n\r\n\t\t\t\t\t\t\t\t// Separator interval\r\n\t\t\t\t\t\t\t\tlet b = a[0].split(\",\");\r\n\t\t\t\t\t\t\t\tif (b.length === 1) {\r\n\t\t\t\t\t\t\t\t\t// No thousands separators\r\n\t\t\t\t\t\t\t\t\t// Do nothing\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t// Use length fo the last chunk as thousands length\r\n\t\t\t\t\t\t\t\t\titem.thousands.interval = $type.getValue(b.pop()).length;\r\n\r\n\t\t\t\t\t\t\t\t\tif (item.thousands.interval === 0) {\r\n\t\t\t\t\t\t\t\t\t\titem.thousands.interval = -1;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Deal with decimals\r\n\t\t\t\t\t\t\tif (typeof (a[1]) === \"undefined\") {\r\n\t\t\t\t\t\t\t\t// No directives for decimals\r\n\t\t\t\t\t\t\t\t// Leave at defaults (no formatting)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t// Counts\r\n\t\t\t\t\t\t\t\titem.decimals.active = (a[1].match(/0/g) || []).length;\r\n\t\t\t\t\t\t\t\titem.decimals.passive = (a[1].match(/\\#/g) || []).length + item.decimals.active;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Add special code to template\r\n\t\t\t\t\t\t\titem.template += chunk.text.split(matches[0]).join($strings.PLACEHOLDER);\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// Quoted string - take it as it is\r\n\t\t\t\t\titem.template += chunk.text;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Apply style formatting\r\n\t\t\t//item.template = getTextFormatter().format(item.template, this.outputFormat);\r\n\r\n\t\t\t// Save cache\r\n\t\t\tthis.setCache(item.source, item);\r\n\r\n\t\t\t// Mark this as parsed\r\n\t\t\titem.parsed = true;\r\n\r\n\t\t});\r\n\r\n\t\t// Save cache (the whole thing)\r\n\t\tthis.setCache(format, info);\r\n\r\n\t\treturn info;\r\n\t}\r\n\r\n\t/**\r\n\t * Applies parsed format to a numeric value.\r\n\t *\r\n\t * @param value    Value\r\n\t * @param details  Parsed format as returned by {parseFormat}\r\n\t * @return Formatted number\r\n\t */\r\n\tprotected applyFormat(value: number, details: any): string {\r\n\r\n\t\t// Use absolute values\r\n\t\tlet negative: boolean = value < 0;\r\n\t\tvalue = Math.abs(value);\r\n\r\n\t\t// Recalculate according to modifier\r\n\t\tlet prefix: string = \"\", suffix: string = \"\";\r\n\t\tlet mods: string[] = details.mod ? details.mod.split(\"\") : [];\r\n\t\tif (mods.indexOf(\"b\") !== -1) {\r\n\t\t\tlet a = this.applyPrefix(value, this.bytePrefixes);\r\n\t\t\tvalue = a[0];\r\n\t\t\tprefix = a[1];\r\n\t\t\tsuffix = a[2];\r\n\t\t\tif (details.modSpacing) {\r\n\t\t\t\tsuffix = \" \" + suffix;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (mods.indexOf(\"a\") !== -1) {\r\n\t\t\tlet a = this.applyPrefix(value, value < 1.00 ? this.smallNumberPrefixes : this.bigNumberPrefixes);\r\n\t\t\tvalue = a[0];\r\n\t\t\tprefix = a[1];\r\n\t\t\tsuffix = a[2];\r\n\t\t\tif (details.modSpacing) {\r\n\t\t\t\tsuffix = \" \" + suffix;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (mods.indexOf(\"%\") !== -1) {\r\n\t\t\tvalue *= 100;\r\n\t\t\tsuffix = \"%\";\r\n\t\t}\r\n\t\telse if (mods.indexOf(\"‰\") !== -1) {\r\n\t\t\tvalue *= 1000;\r\n\t\t\tsuffix = \"‰\";\r\n\t\t}\r\n\r\n\t\t// Round to passive\r\n\t\tif (mods.indexOf(\"e\") !== -1) {\r\n\t\t\t// convert the value to exponential\r\n\t\t\tlet exp: string[];\r\n\t\t\tif (details.decimals.passive >= 0) {\r\n\t\t\t\texp = value.toExponential(details.decimals.passive).split(\"e\");\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\texp = value.toExponential().split(\"e\");\r\n\t\t\t}\r\n\t\t\tvalue = Number(exp[0]);\r\n\t\t\tsuffix = \"e\" + exp[1];\r\n\t\t\tif (details.modSpacing) {\r\n\t\t\t\tsuffix = \" \" + suffix;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (details.decimals.passive === 0) {\r\n\t\t\tvalue = Math.round(value);\r\n\t\t}\r\n\t\telse if (details.decimals.passive > 0) {\r\n\t\t\tlet d: number = Math.pow(10, details.decimals.passive);\r\n\t\t\tvalue = Math.round(value * d) / d;\r\n\t\t}\r\n\r\n\t\t// Init return value\r\n\t\tlet res: string = \"\";\r\n\r\n\t\t// Calc integer and decimal parts\r\n\t\tlet a = $utils.numberToString(value).split(\".\");\r\n\r\n\t\t// Format integers\r\n\t\tlet ints = a[0];\r\n\r\n\t\t// Pad integers to active length\r\n\t\tif (ints.length < details.thousands.active) {\r\n\t\t\tints = Array(details.thousands.active - ints.length + 1).join(\"0\") + ints;\r\n\t\t}\r\n\r\n\t\t// Insert thousands separators\r\n\t\tif (details.thousands.interval > 0) {\r\n\t\t\tlet ip: string[] = [];\r\n\t\t\tlet intsr: string = ints.split(\"\").reverse().join(\"\");\r\n\t\t\tfor (let i = 0, len = ints.length; i <= len; i += details.thousands.interval) {\r\n\t\t\t\tlet c: string = intsr.substr(i, details.thousands.interval).split(\"\").reverse().join(\"\");\r\n\t\t\t\tif (c !== \"\") {\r\n\t\t\t\t\tip.unshift(c);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tints = ip.join(details.thousands.separator);\r\n\t\t}\r\n\r\n\t\t// Add integers\r\n\t\tres += ints;\r\n\r\n\t\t// Add decimals\r\n\t\tif (a.length === 1) {\r\n\t\t\ta.push(\"\");\r\n\t\t}\r\n\t\tlet decs: string = a[1];\r\n\r\n\t\t// Fill zeros?\r\n\t\tif (decs.length < details.decimals.active) {\r\n\t\t\tdecs += Array(details.decimals.active - decs.length + 1).join(\"0\");\r\n\t\t}\r\n\r\n\t\tif (decs !== \"\") {\r\n\t\t\tres += details.decimals.separator + decs;\r\n\t\t}\r\n\r\n\t\t// Can't have empty return value\r\n\t\tif (res === \"\") {\r\n\t\t\tres = \"0\";\r\n\t\t}\r\n\r\n\t\t// Add minus sign back\r\n\t\tif (value !== 0 && negative && (mods.indexOf(\"s\") === -1)) {\r\n\t\t\tres = \"-\" + res;\r\n\t\t}\r\n\r\n\t\t// Add suffixes/prefixes\r\n\t\tif (prefix) {\r\n\t\t\tres = prefix + res;\r\n\t\t}\r\n\t\tif (suffix) {\r\n\t\t\tres += suffix;\r\n\t\t}\r\n\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Chooses appropriate prefix and suffix based on the passed in rules.\r\n\t *\r\n\t * @param value     Value\r\n\t * @param prefixes  Prefix array\r\n\t * @return Result\r\n\t */\r\n\tprotected applyPrefix(value: number, prefixes: any[]): any[] {\r\n\t\tlet newvalue: number = value,\r\n\t\t\tprefix: string = \"\",\r\n\t\t\tsuffix: string = \"\";\r\n\r\n\t\tfor (let i = 0, len = prefixes.length; i < len; i++) {\r\n\t\t\tif (prefixes[i].number <= value) {\r\n\t\t\t\tif (prefixes[i].number === 0) {\r\n\t\t\t\t\tnewvalue = 0;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tnewvalue = value / prefixes[i].number;\r\n\t\t\t\t}\r\n\t\t\t\tprefix = prefixes[i].prefix;\r\n\t\t\t\tsuffix = prefixes[i].suffix;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn [newvalue, prefix, suffix];\r\n\t}\r\n\r\n\t/**\r\n\t * Invalidates the parent [[Sprite]] object.\r\n\t */\r\n\tprotected invalidateSprite(): void {\r\n\t\tif (this.sprite) {\r\n\t\t\tthis.sprite.invalidate();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Number format.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n\t * @param format  A format to use for number formatting\r\n\t */\r\n\tpublic set numberFormat(format: string) {\r\n\t\tthis._numberFormat = format;\r\n\t}\r\n\r\n\t/**\r\n\t * @return A format to use for number formatting\r\n\t */\r\n\tpublic get numberFormat(): string {\r\n\t\treturn this._numberFormat;\r\n\t}\r\n\r\n\t/**\r\n\t * Negative base for negative numbers.\r\n\t *\r\n\t * @default 0\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n\t * @param format  A format to use for number formatting\r\n\t */\r\n\tpublic set negativeBase(value: number) {\r\n\t\tthis._negativeBase = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @return A format to use for number formatting\r\n\t */\r\n\tpublic get negativeBase(): number {\r\n\t\treturn this._negativeBase;\r\n\t}\r\n\r\n\t/**\r\n\t * Prefixes for big numbers.\r\n\t *\r\n\t * It's an array of objects of number/prefix pairs.\r\n\t *\r\n\t * ```JSON\r\n\t * [\r\n\t *   { \"number\": 1e+3, \"suffix\": \"K\" },\r\n\t *   { \"number\": 1e+6, \"suffix\": \"M\" },\r\n\t *   { \"number\": 1e+9, \"suffix\": \"G\" },\r\n\t *   { \"number\": 1e+12, \"suffix\": \"T\" },\r\n\t *   { \"number\": 1e+15, \"suffix\": \"P\" },\r\n\t *   { \"number\": 1e+18, \"suffix\": \"E\" },\r\n\t *   { \"number\": 1e+21, \"suffix\": \"Z\" },\r\n\t *   { \"number\": 1e+24, \"suffix\": \"Y\" }\r\n\t * ]\r\n\t * ```\r\n\t *\r\n\t * If the number is bigger than the `number` ir will be converted to the\r\n\t * appropriate bigger number with prefix.\r\n\t *\r\n\t * E.g. as per above `1500` will be converted to `1.5K`.\r\n\t *\r\n\t * Please note that for this transformation to be enabled, you need to\r\n\t * enable it specific modifier in your format setting.\r\n\t *\r\n\t * The modifier for big/small number modification is \"a\":\r\n\t *\r\n\t * ```Text\r\n\t * {myfield.formatNumber(\"#,###.00a\")}\r\n\t * ```\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n\t * @param prefixes  Prefixes for big numbers\r\n\t */\r\n\tpublic set bigNumberPrefixes(prefixes: INumberSuffix[]) {\r\n\t\tthis._bigNumberPrefixes = prefixes;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Prefixes for big numbers\r\n\t */\r\n\tpublic get bigNumberPrefixes(): INumberSuffix[] {\r\n\t\tif (!$type.hasValue(this._bigNumberPrefixes)) {\r\n\t\t\tthis._bigNumberPrefixes = [\r\n\t\t\t\t{ \"number\": 1e+3, \"suffix\": this.language.translate(\"_big_number_suffix_3\") },\r\n\t\t\t\t{ \"number\": 1e+6, \"suffix\": this.language.translate(\"_big_number_suffix_6\") },\r\n\t\t\t\t{ \"number\": 1e+9, \"suffix\": this.language.translate(\"_big_number_suffix_9\") },\r\n\t\t\t\t{ \"number\": 1e+12, \"suffix\": this.language.translate(\"_big_number_suffix_12\") },\r\n\t\t\t\t{ \"number\": 1e+15, \"suffix\": this.language.translate(\"_big_number_suffix_15\") },\r\n\t\t\t\t{ \"number\": 1e+18, \"suffix\": this.language.translate(\"_big_number_suffix_18\") },\r\n\t\t\t\t{ \"number\": 1e+21, \"suffix\": this.language.translate(\"_big_number_suffix_21\") },\r\n\t\t\t\t{ \"number\": 1e+24, \"suffix\": this.language.translate(\"_big_number_suffix_24\") }\r\n\t\t\t]\r\n\t\t}\r\n\t\treturn this._bigNumberPrefixes;\r\n\t}\r\n\r\n\t/**\r\n\t * Prefixes for big numbers.\r\n\t *\r\n\t * It's an array of objects of number/prefix pairs.\r\n\t *\r\n\t * ```JSON\r\n\t * [\r\n\t *   { \"number\": 1e-24, \"suffix\": \"y\" },\r\n\t *   { \"number\": 1e-21, \"suffix\": \"z\" },\r\n\t *   { \"number\": 1e-18, \"suffix\": \"a\" },\r\n\t *   { \"number\": 1e-15, \"suffix\": \"f\" },\r\n\t *   { \"number\": 1e-12, \"suffix\": \"p\" },\r\n\t *   { \"number\": 1e-9, \"suffix\": \"n\" },\r\n\t *   { \"number\": 1e-6, \"suffix\": \"μ\" },\r\n\t *   { \"number\": 1e-3, \"suffix\": \"m\" }\r\n\t * ]\r\n\t * ```\r\n\t *\r\n\t * If the number is smaller than the `number` ir will be converted to the\r\n\t * appropriate smaller number with prefix.\r\n\t *\r\n\t * E.g. as per above `0.0015` will be converted to `1.5m`.\r\n\t *\r\n\t * Please note that for this transformation to be enabled, you need to\r\n\t * enable it specific modifier in your format setting.\r\n\t *\r\n\t * The modifier for big/small number modification is \"a\":\r\n\t *\r\n\t * ```Text\r\n\t * {myfield.formatNumber(\"#,###.00a\")}\r\n\t * ```\r\n\t *\r\n\t * IMPORTANT: The order of the suffixes is important. The list must start\r\n\t * from the smallest number and work towards bigger ones.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n\t * @param prefixes  Prefixes for small numbers\r\n\t */\r\n\tpublic set smallNumberPrefixes(prefixes: INumberSuffix[]) {\r\n\t\tthis._smallNumberPrefixes = prefixes;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Prefixes for small numbers\r\n\t */\r\n\tpublic get smallNumberPrefixes(): INumberSuffix[] {\r\n\t\tif (!$type.hasValue(this._smallNumberPrefixes)) {\r\n\t\t\tthis._smallNumberPrefixes = [\r\n\t\t\t\t{ \"number\": 1e-24, \"suffix\": this.language.translate(\"_small_number_suffix_24\") },\r\n\t\t\t\t{ \"number\": 1e-21, \"suffix\": this.language.translate(\"_small_number_suffix_21\") },\r\n\t\t\t\t{ \"number\": 1e-18, \"suffix\": this.language.translate(\"_small_number_suffix_18\") },\r\n\t\t\t\t{ \"number\": 1e-15, \"suffix\": this.language.translate(\"_small_number_suffix_15\") },\r\n\t\t\t\t{ \"number\": 1e-12, \"suffix\": this.language.translate(\"_small_number_suffix_12\") },\r\n\t\t\t\t{ \"number\": 1e-9, \"suffix\": this.language.translate(\"_small_number_suffix_9\") },\r\n\t\t\t\t{ \"number\": 1e-6, \"suffix\": this.language.translate(\"_small_number_suffix_6\") },\r\n\t\t\t\t{ \"number\": 1e-3, \"suffix\": this.language.translate(\"_small_number_suffix_3\") }\r\n\t\t\t]\r\n\t\t}\r\n\t\treturn this._smallNumberPrefixes;\r\n\t}\r\n\r\n\t/**\r\n\t * Basically the same as `bigNumberPrefixes`, except base for calculation\r\n\t * is not thousand but byte (1024).\r\n\t *\r\n\t * The modifier is \"b\".\r\n\t *\r\n\t *  ```Text\r\n\t * {myfield.formatNumber(\"#,###.00b\")}\r\n\t * ```\r\n\t *\r\n\t * The above `2048` will change to `2K`.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n\t * @param prefixes  Prefixes for byte-size formatting\r\n\t */\r\n\tpublic set bytePrefixes(prefixes: INumberSuffix[]) {\r\n\t\tthis._bytePrefixes = prefixes;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Prefixes for byte-size formatting\r\n\t */\r\n\tpublic get bytePrefixes(): INumberSuffix[] {\r\n\t\tif (!$type.hasValue(this._bytePrefixes)) {\r\n\t\t\tthis._bytePrefixes = [\r\n\t\t\t\t{ \"number\": 0, suffix: this.language.translate(\"_byte_suffix_B\") },\r\n\t\t\t\t{ \"number\": 1024, suffix: this.language.translate(\"_byte_suffix_KB\") },\r\n\t\t\t\t{ \"number\": 1048576, suffix: this.language.translate(\"_byte_suffix_MB\") },\r\n\t\t\t\t{ \"number\": 1073741824, suffix: this.language.translate(\"_byte_suffix_GB\") },\r\n\t\t\t\t{ \"number\": 1099511627776, suffix: this.language.translate(\"_byte_suffix_TB\") },\r\n\t\t\t\t{ \"number\": 1125899906842624, suffix: this.language.translate(\"_byte_suffix_PB\") }\r\n\t\t\t]\r\n\t\t}\r\n\t\treturn this._bytePrefixes;\r\n\t}\r\n\r\n\t/**\r\n\t * Ooutput format: \"svg\" or \"html\".\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param value  Output format\r\n\t */\r\n\tpublic set outputFormat(outputFormat: string) {\r\n\t\tthis._outputFormat = outputFormat.toLowerCase();\r\n\t\tthis.invalidateSprite();\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore Exclude from docs\r\n\t * @return Output format\r\n\t */\r\n\tpublic get outputFormat(): string {\r\n\t\treturn this._outputFormat;\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces brackets with temporary placeholders.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text  Input text\r\n\t * @return Escaped text\r\n\t */\r\n\tpublic escape(text: string): string {\r\n\t\treturn text.replace(\"||\", $strings.PLACEHOLDER2);\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces placeholders back to brackets.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text  Escaped text\r\n\t * @return Unescaped text\r\n\t */\r\n\tpublic unescape(text: string): string {\r\n\t\treturn text.replace($strings.PLACEHOLDER2, \"|\");\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"NumberFormatter\"] = NumberFormatter;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}