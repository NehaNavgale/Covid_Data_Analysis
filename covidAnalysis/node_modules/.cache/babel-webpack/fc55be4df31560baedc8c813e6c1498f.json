{"ast":null,"code":"/**\n * Polyspline (smoothed line) module.\n */\nimport * as tslib_1 from \"tslib\";\n/**\n * ============================================================================\n * IMPORTS\n * ============================================================================\n * @hidden\n */\n\nimport { Polyline } from \"./Polyline\";\nimport { registry } from \"../Registry\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $path from \"../../core/rendering/Path\";\n/**\n * ============================================================================\n * MAIN CLASS\n * ============================================================================\n * @hidden\n */\n\n/**\n * Draws a polysline. (smoothed multi-sigment line)\n *\n * @see {@link IPolysplineEvents} for a list of available events\n * @see {@link IPolysplineAdapters} for a list of available Adapters\n */\n\nvar Polyspline =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Polyspline, _super);\n  /**\n   * Constructor\n   */\n\n\n  function Polyspline() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"Polyspline\";\n    _this.tensionX = 0.5;\n    _this.tensionY = 0.5;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\n   * Creats and adds an SVG path for the arc.\n   *\n   * @ignore Exclude from docs\n   */\n\n\n  Polyspline.prototype.makePath = function () {\n    this._distance = 0;\n    var segments = this.segments;\n    var tensionX = this.tensionX;\n    var tensionY = this.tensionY;\n\n    if (segments && segments.length > 0) {\n      var path = \"\";\n      this._realSegments = [];\n\n      for (var i = 0, len = segments.length; i < len; i++) {\n        var points = segments[i];\n        var realPoints = [];\n\n        this._realSegments.push(realPoints);\n\n        if (points.length > 0) {\n          path += $path.moveTo(points[0]);\n\n          for (var p = 0; p < points.length - 1; p++) {\n            var p0 = points[p - 1];\n            var p1 = points[p];\n            var p2 = points[p + 1];\n            var p3 = points[p + 2];\n\n            if (p === 0) {\n              p0 = points[p];\n            } else if (p == points.length - 2) {\n              p3 = points[p + 1];\n            }\n\n            if (!p3) {\n              p3 = p2;\n            }\n\n            var controlPointA = $math.getCubicControlPointA(p0, p1, p2, p3, tensionX, tensionY);\n            var controlPointB = $math.getCubicControlPointB(p0, p1, p2, p3, tensionX, tensionY);\n            path += $path.cubicCurveTo(p2, controlPointA, controlPointB); // now split to small segments so that we could have positionToPoint later\n\n            var stepCount = Math.ceil($math.getDistance(p1, p2)) / 2;\n            var prevPoint = p1;\n\n            if (stepCount > 0) {\n              for (var s = 0; s <= stepCount; s++) {\n                var point = $math.getPointOnCubicCurve(p1, p2, controlPointA, controlPointB, s / stepCount);\n                realPoints.push(point);\n                this._distance += $math.getDistance(prevPoint, point); //path += $path.lineTo(point);\n\n                prevPoint = point;\n              }\n            } else {\n              realPoints.push(p0);\n            }\n          }\n        }\n      }\n\n      this.path = path;\n    }\n  };\n\n  Object.defineProperty(Polyspline.prototype, \"tensionX\", {\n    /**\n     * @return Tension\n     */\n    get: function get() {\n      return this.getPropertyValue(\"tensionX\");\n    },\n\n    /**\n     * Horizontal tension for the spline.\n     *\n     * Used by the line smoothing algorithm.\n     *\n     * @default 0.5\n     * @param value  Tension\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"tensionX\", value);\n      this.makePath();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Polyspline.prototype, \"tensionY\", {\n    /**\n     * @return Tension\n     */\n    get: function get() {\n      return this.getPropertyValue(\"tensionY\");\n    },\n\n    /**\n     * Vertical tension for the spline.\n     *\n     * Used by the line smoothing algorithm.\n     *\n     * @default 0.5\n     * @param value  Tensions\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"tensionY\", value, true);\n      this.makePath();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Polyspline;\n}(Polyline);\n\nexport { Polyspline };\n/**\n * Register class in system, so that it can be instantiated using its name from\n * anywhere.\n *\n * @ignore\n */\n\nregistry.registeredClasses[\"Polyspline\"] = Polyspline;","map":{"version":3,"sources":["../../../../../src/.internal/core/elements/Polyspline.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Polyspline (smoothed line) module.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Polyline, IPolylineProperties, IPolylineAdapters, IPolylineEvents } from \"./Polyline\";\r\nimport { IPoint } from \"../../core/defs/IPoint\";\r\nimport { registry } from \"../Registry\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $path from \"../../core/rendering/Path\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[Polyspline]].\r\n */\r\nexport interface IPolysplineProperties extends IPolylineProperties {\r\n\r\n\t/**\r\n\t * Horizontal tension for the spline.\r\n\t *\r\n\t * Used by the line smoothing algorithm.\r\n\t *\r\n\t * @default 0.5\r\n\t */\r\n\ttensionX: number;\r\n\r\n\t/**\r\n\t * Vertical tension for the spline.\r\n\t *\r\n\t * Used by the line smoothing algorithm.\r\n\t *\r\n\t * @default 0.5\r\n\t */\r\n\ttensionY: number;\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[Polyspline]].\r\n */\r\nexport interface IPolysplineEvents extends IPolylineEvents { }\r\n\r\n/**\r\n * Defines adapters\r\n * Includes both the [[Adapter]] definitions and properties\r\n * @see {@link Adapter}\r\n */\r\nexport interface IPolysplineAdapters extends IPolylineAdapters, IPolysplineProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Draws a polysline. (smoothed multi-sigment line)\r\n *\r\n * @see {@link IPolysplineEvents} for a list of available events\r\n * @see {@link IPolysplineAdapters} for a list of available Adapters\r\n */\r\nexport class Polyspline extends Polyline {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tpublic _properties!: IPolysplineProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tpublic _adapter!: IPolysplineAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IPolysplineEvents;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"Polyspline\";\r\n\r\n\t\tthis.tensionX = 0.5;\r\n\t\tthis.tensionY = 0.5;\r\n\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Creats and adds an SVG path for the arc.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic makePath(): void {\r\n\t\tthis._distance = 0;\r\n\t\tlet segments = this.segments;\r\n\r\n\t\tlet tensionX: number = this.tensionX;\r\n\t\tlet tensionY: number = this.tensionY;\r\n\r\n\t\tif (segments && segments.length > 0) {\r\n\t\t\tlet path: string = \"\";\r\n\t\t\tthis._realSegments = [];\r\n\r\n\t\t\tfor (let i = 0, len = segments.length; i < len; i++) {\r\n\t\t\t\tlet points: IPoint[] = segments[i];\r\n\t\t\t\tlet realPoints: IPoint[] = [];\r\n\t\t\t\tthis._realSegments.push(realPoints);\r\n\r\n\t\t\t\tif (points.length > 0) {\r\n\r\n\t\t\t\t\tpath += $path.moveTo(points[0]);\r\n\r\n\t\t\t\t\tfor (let p = 0; p < points.length - 1; p++) {\r\n\r\n\t\t\t\t\t\tlet p0: IPoint = points[p - 1];\r\n\r\n\t\t\t\t\t\tlet p1: IPoint = points[p];\r\n\r\n\t\t\t\t\t\tlet p2: IPoint = points[p + 1];\r\n\r\n\t\t\t\t\t\tlet p3: IPoint = points[p + 2];\r\n\r\n\t\t\t\t\t\tif (p === 0) {\r\n\t\t\t\t\t\t\tp0 = points[p];\r\n\t\t\t\t\t\t} else if (p == points.length - 2) {\r\n\t\t\t\t\t\t\tp3 = points[p + 1];\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (!p3) {\r\n\t\t\t\t\t\t\tp3 = p2;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tlet controlPointA: IPoint = $math.getCubicControlPointA(p0, p1, p2, p3, tensionX, tensionY);\r\n\t\t\t\t\t\tlet controlPointB: IPoint = $math.getCubicControlPointB(p0, p1, p2, p3, tensionX, tensionY);\r\n\r\n\t\t\t\t\t\tpath += $path.cubicCurveTo(p2, controlPointA, controlPointB);\r\n\r\n\t\t\t\t\t\t// now split to small segments so that we could have positionToPoint later\r\n\t\t\t\t\t\tlet stepCount: number = Math.ceil($math.getDistance(p1, p2)) / 2;\r\n\t\t\t\t\t\tlet prevPoint: IPoint = p1;\r\n\t\t\t\t\t\tif (stepCount > 0) {\r\n\t\t\t\t\t\t\tfor (let s = 0; s <= stepCount; s++) {\r\n\t\t\t\t\t\t\t\tlet point = $math.getPointOnCubicCurve(p1, p2, controlPointA, controlPointB, s / stepCount);\r\n\t\t\t\t\t\t\t\trealPoints.push(point);\r\n\t\t\t\t\t\t\t\tthis._distance += $math.getDistance(prevPoint, point);\r\n\t\t\t\t\t\t\t\t//path += $path.lineTo(point);\r\n\t\t\t\t\t\t\t\tprevPoint = point;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\trealPoints.push(p0);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.path = path;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Horizontal tension for the spline.\r\n\t *\r\n\t * Used by the line smoothing algorithm.\r\n\t *\r\n\t * @default 0.5\r\n\t * @param value  Tension\r\n\t */\r\n\tpublic set tensionX(value: number) {\r\n\t\tthis.setPropertyValue(\"tensionX\", value);\r\n\t\tthis.makePath();\r\n\t}\r\n\r\n\t/**\r\n\t * @return Tension\r\n\t */\r\n\tpublic get tensionX(): number {\r\n\t\treturn this.getPropertyValue(\"tensionX\");\r\n\t}\r\n\r\n\t/**\r\n\t * Vertical tension for the spline.\r\n\t *\r\n\t * Used by the line smoothing algorithm.\r\n\t *\r\n\t * @default 0.5\r\n\t * @param value  Tensions\r\n\t */\r\n\tpublic set tensionY(value: number) {\r\n\t\tthis.setPropertyValue(\"tensionY\", value, true);\r\n\t\tthis.makePath();\r\n\t}\r\n\r\n\t/**\r\n\t * @return Tension\r\n\t */\r\n\tpublic get tensionY(): number {\r\n\t\treturn this.getPropertyValue(\"tensionY\");\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"Polyspline\"] = Polyspline;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}