{"ast":null,"code":"/**\n * DateAxis module\n */\nimport * as tslib_1 from \"tslib\";\n/**\n * ============================================================================\n * IMPORTS\n * ============================================================================\n * @hidden\n */\n\nimport { ValueAxis, ValueAxisDataItem } from \"./ValueAxis\";\nimport { List } from \"../../core/utils/List\";\nimport { Dictionary } from \"../../core/utils/Dictionary\";\nimport { DateAxisBreak } from \"./DateAxisBreak\";\nimport { registry } from \"../../core/Registry\";\nimport * as $time from \"../../core/utils/Time\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $object from \"../../core/utils/Object\";\n/**\n * ============================================================================\n * DATA ITEM\n * ============================================================================\n * @hidden\n */\n\n/**\n * Defines data item for [[DateAxis]].\n *\n * @see {@link DataItem}\n */\n\nvar DateAxisDataItem =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(DateAxisDataItem, _super);\n  /**\n   * Constructor\n   */\n\n\n  function DateAxisDataItem() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"DateAxisDataItem\";\n\n    _this.applyTheme();\n\n    _this.values.date = {};\n    _this.values.endDate = {};\n    return _this;\n  }\n\n  Object.defineProperty(DateAxisDataItem.prototype, \"date\", {\n    /**\n     * @return Date\n     */\n    get: function get() {\n      return this.dates[\"date\"];\n    },\n\n    /**\n     * Date position of the data item.\n     *\n     * @param date  Date\n     */\n    set: function set(date) {\n      this.setDate(\"date\", date);\n      this.value = date.getTime();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxisDataItem.prototype, \"endDate\", {\n    /**\n     * @return End date\n     */\n    get: function get() {\n      return this.dates[\"endDate\"];\n    },\n\n    /**\n     * End date for data item.\n     *\n     * @param date End date\n     */\n    set: function set(date) {\n      this.setDate(\"endDate\", date);\n      this.endValue = date.getTime();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DateAxisDataItem;\n}(ValueAxisDataItem);\n\nexport { DateAxisDataItem };\n/**\n * ============================================================================\n * MAIN CLASS\n * ============================================================================\n * @hidden\n */\n\n/**\n * Used to create a date/time-based axis for the chart.\n *\n * ```TypeScript\n * // Create the axis\n * let xAxis = chart.xAxes.push(new am4charts.DateAxis());\n *\n * // Set settings\n * xAxis.title.text = \"Time\";\n * ```\n * ```JavaScript\n * // Create the axis\n * var valueAxis = chart.xAxes.push(new am4charts.DateAxis());\n *\n * // Set settings\n * valueAxis.title.text = \"Time\";\n * ```\n * ```JSON\n * \"xAxes\": [{\n *   \"type\": \"DateAxis\",\n *   \"title\": {\n *     \"text\": \"Time\"\n *   }\n * }]\n * ```\n *\n * @see {@link IDateAxisEvents} for a list of available Events\n * @see {@link IDateAxisAdapters} for a list of available Adapters\n * @important\n */\n\nvar DateAxis =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(DateAxis, _super);\n  /**\n   * Constructor\n   */\n\n\n  function DateAxis() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\n     * A list of date/time intervals for Date axis.\n     *\n     * This define various granularities available for the axis. For example\n     * if you have an axis spanning an hour, and space for 6 grid lines / labels\n     * the axis will choose the granularity of 10 minutes, displaying a label\n     * every 10 minutes.\n     *\n     * Default intervals:\n     *\n     * ```JSON\n     * [\n     *  { timeUnit: \"millisecond\", count: 1 },\n     *  { timeUnit: \"millisecond\", count: 5 },\n     *  { timeUnit: \"millisecond\", count: 10 },\n     *  { timeUnit: \"millisecond\", count: 50 },\n     *  { timeUnit: \"millisecond\", count: 100 },\n     *  { timeUnit: \"millisecond\", count: 500 },\n     *  { timeUnit: \"second\", count: 1 },\n     *  { timeUnit: \"second\", count: 5 },\n     *  { timeUnit: \"second\", count: 10 },\n     *  { timeUnit: \"second\", count: 30 },\n     *  { timeUnit: \"minute\", count: 1 },\n     *  { timeUnit: \"minute\", count: 5 },\n     *  { timeUnit: \"minute\", count: 10 },\n     *  { timeUnit: \"minute\", count: 30 },\n     *  { timeUnit: \"hour\", count: 1 },\n     *  { timeUnit: \"hour\", count: 3 },\n     *  { timeUnit: \"hour\", count: 6 },\n     *  { timeUnit: \"hour\", count: 12 },\n     *  { timeUnit: \"day\", count: 1 },\n     *  { timeUnit: \"day\", count: 2 },\n     *  { timeUnit: \"day\", count: 3 },\n     *  { timeUnit: \"day\", count: 4 },\n     *  { timeUnit: \"day\", count: 5 },\n     *  { timeUnit: \"week\", count: 1 },\n     *  { timeUnit: \"month\", count: 1 },\n     *  { timeUnit: \"month\", count: 2 },\n     *  { timeUnit: \"month\", count: 3 },\n     *  { timeUnit: \"month\", count: 6 },\n     *  { timeUnit: \"year\", count: 1 },\n     *  { timeUnit: \"year\", count: 2 },\n     *  { timeUnit: \"year\", count: 5 },\n     *  { timeUnit: \"year\", count: 10 },\n     *  { timeUnit: \"year\", count: 50 },\n     *  { timeUnit: \"year\", count: 100 }\n     * ]\n     * ```\n     */\n\n\n    _this.gridIntervals = new List();\n    /**\n     * A collection of date formats to use when formatting different time units\n     * on Date/time axis.\n     *\n     * Actual defaults will depend on the language locale set for the chart.\n     *\n     * To override format for a specific time unit, say days, you need to set\n     * the appropriate key to a format string. E.g.:\n     *\n     * ```TypeScript\n     * axis.dateFormats.setKey(\"day\", \"MMMM d, yyyy\");\n     * ```\n     * ```JavaScript\n     * axis.dateFormats.setKey(\"day\", \"MMMM d, yyyy\");\n     * ```\n     * ```JSON\n     * \"xAxes\": [{\n     *   \"type\": \"DateAxis\",\n     *   \"dateFormats\": {\n     *     \"day\": \"MMMM d, yyyy\"\n     *   }\n     * }]\n     * ```\n     *\n     * @see {@link DateFormatter}\n     */\n\n    _this.dateFormats = new Dictionary();\n    /**\n     * These formats are applied to labels that are first in a larger unit.\n     *\n     * For example, if we have a DateAxis with days on it, the first day of month\n     * indicates a break in month - a start of the bigger period.\n     *\n     * For those labels, `periodChangeDateFormats` are applied instead of\n     * `dateFormats`.\n     *\n     * This allows us implement convenient structures, like instead of:\n     *\n     * `Jan 1 - Jan 2 - Jan 3 - ...`\n     *\n     * We can have:\n     *\n     * `Jan - 1 - 2 - 3 - ...`\n     *\n     * This can be disabled by setting `markUnitChange = false`.\n     */\n\n    _this.periodChangeDateFormats = new Dictionary();\n    /**\n     * Actual interval (granularity) derived from the actual data.\n     */\n\n    _this._baseIntervalReal = {\n      timeUnit: \"day\",\n      count: 1\n    };\n    /**\n     * [_minDifference description]\n     *\n     * @todo Description\n     */\n\n    _this._minDifference = {};\n    _this.className = \"DateAxis\";\n\n    _this.setPropertyValue(\"markUnitChange\", true);\n\n    _this.snapTooltip = true; // Translatable defaults are applied in `applyInternalDefaults()`\n    // ...\n    // Define default intervals\n\n    _this.gridIntervals.pushAll([{\n      timeUnit: \"millisecond\",\n      count: 1\n    }, {\n      timeUnit: \"millisecond\",\n      count: 5\n    }, {\n      timeUnit: \"millisecond\",\n      count: 10\n    }, {\n      timeUnit: \"millisecond\",\n      count: 50\n    }, {\n      timeUnit: \"millisecond\",\n      count: 100\n    }, {\n      timeUnit: \"millisecond\",\n      count: 500\n    }, {\n      timeUnit: \"second\",\n      count: 1\n    }, {\n      timeUnit: \"second\",\n      count: 5\n    }, {\n      timeUnit: \"second\",\n      count: 10\n    }, {\n      timeUnit: \"second\",\n      count: 30\n    }, {\n      timeUnit: \"minute\",\n      count: 1\n    }, {\n      timeUnit: \"minute\",\n      count: 5\n    }, {\n      timeUnit: \"minute\",\n      count: 10\n    }, {\n      timeUnit: \"minute\",\n      count: 15\n    }, {\n      timeUnit: \"minute\",\n      count: 30\n    }, {\n      timeUnit: \"hour\",\n      count: 1\n    }, {\n      timeUnit: \"hour\",\n      count: 3\n    }, {\n      timeUnit: \"hour\",\n      count: 6\n    }, {\n      timeUnit: \"hour\",\n      count: 12\n    }, {\n      timeUnit: \"day\",\n      count: 1\n    }, {\n      timeUnit: \"day\",\n      count: 2\n    }, {\n      timeUnit: \"day\",\n      count: 3\n    }, {\n      timeUnit: \"day\",\n      count: 4\n    }, {\n      timeUnit: \"day\",\n      count: 5\n    }, {\n      timeUnit: \"week\",\n      count: 1\n    }, {\n      timeUnit: \"month\",\n      count: 1\n    }, {\n      timeUnit: \"month\",\n      count: 2\n    }, {\n      timeUnit: \"month\",\n      count: 3\n    }, {\n      timeUnit: \"month\",\n      count: 6\n    }, {\n      timeUnit: \"year\",\n      count: 1\n    }, {\n      timeUnit: \"year\",\n      count: 2\n    }, {\n      timeUnit: \"year\",\n      count: 5\n    }, {\n      timeUnit: \"year\",\n      count: 10\n    }, {\n      timeUnit: \"year\",\n      count: 50\n    }, {\n      timeUnit: \"year\",\n      count: 100\n    }, {\n      timeUnit: \"year\",\n      count: 200\n    }, {\n      timeUnit: \"year\",\n      count: 500\n    }, {\n      timeUnit: \"year\",\n      count: 1000\n    }, {\n      timeUnit: \"year\",\n      count: 2000\n    }, {\n      timeUnit: \"year\",\n      count: 5000\n    }, {\n      timeUnit: \"year\",\n      count: 10000\n    }, {\n      timeUnit: \"year\",\n      count: 100000\n    }]); // Set field name\n\n\n    _this.axisFieldName = \"date\"; // Apply theme\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\n   * A function which applies fills to axis cells.\n   *\n   * Default function fills every second fill. You can set this to a function\n   * that follows some other logic.\n   *\n   * Function should accept a [[DateAxisDataItem]] and modify its `axisFill`\n   * property accordingly.\n   */\n\n\n  DateAxis.prototype.fillRule = function (dataItem) {\n    var value = dataItem.value;\n    var axis = dataItem.component;\n    var gridInterval = axis._gridInterval;\n    var gridDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\n\n    if (Math.round((value - axis.min) / gridDuration) / 2 == Math.round(Math.round((value - axis.min) / gridDuration) / 2)) {\n      dataItem.axisFill.__disabled = true;\n    } else {\n      dataItem.axisFill.__disabled = false;\n    }\n  };\n  /**\n   * Sets defaults that instantiate some objects that rely on parent, so they\n   * cannot be set in constructor.\n   */\n\n\n  DateAxis.prototype.applyInternalDefaults = function () {\n    _super.prototype.applyInternalDefaults.call(this); // Set default date formats\n\n\n    if (!this.dateFormats.hasKey(\"millisecond\")) {\n      this.dateFormats.setKey(\"millisecond\", this.language.translate(\"_date_millisecond\"));\n    }\n\n    if (!this.dateFormats.hasKey(\"second\")) {\n      this.dateFormats.setKey(\"second\", this.language.translate(\"_date_second\"));\n    }\n\n    if (!this.dateFormats.hasKey(\"minute\")) {\n      this.dateFormats.setKey(\"minute\", this.language.translate(\"_date_minute\"));\n    }\n\n    if (!this.dateFormats.hasKey(\"hour\")) {\n      this.dateFormats.setKey(\"hour\", this.language.translate(\"_date_hour\"));\n    }\n\n    if (!this.dateFormats.hasKey(\"day\")) {\n      this.dateFormats.setKey(\"day\", this.language.translate(\"_date_day\"));\n    }\n\n    if (!this.dateFormats.hasKey(\"week\")) {\n      this.dateFormats.setKey(\"week\", this.language.translate(\"_date_day\")); // not a mistake\n    }\n\n    if (!this.dateFormats.hasKey(\"month\")) {\n      this.dateFormats.setKey(\"month\", this.language.translate(\"_date_month\"));\n    }\n\n    if (!this.dateFormats.hasKey(\"year\")) {\n      this.dateFormats.setKey(\"year\", this.language.translate(\"_date_year\"));\n    }\n\n    if (!this.periodChangeDateFormats.hasKey(\"millisecond\")) {\n      this.periodChangeDateFormats.setKey(\"millisecond\", this.language.translate(\"_date_millisecond\"));\n    }\n\n    if (!this.periodChangeDateFormats.hasKey(\"second\")) {\n      this.periodChangeDateFormats.setKey(\"second\", this.language.translate(\"_date_second\"));\n    }\n\n    if (!this.periodChangeDateFormats.hasKey(\"minute\")) {\n      this.periodChangeDateFormats.setKey(\"minute\", this.language.translate(\"_date_minute\"));\n    }\n\n    if (!this.periodChangeDateFormats.hasKey(\"hour\")) {\n      this.periodChangeDateFormats.setKey(\"hour\", this.language.translate(\"_date_hour\"));\n    }\n\n    if (!this.periodChangeDateFormats.hasKey(\"day\")) {\n      this.periodChangeDateFormats.setKey(\"day\", this.language.translate(\"_date_day\"));\n    }\n\n    if (!this.periodChangeDateFormats.hasKey(\"week\")) {\n      this.periodChangeDateFormats.setKey(\"week\", this.language.translate(\"_date_day\"));\n    }\n\n    if (!this.periodChangeDateFormats.hasKey(\"month\")) {\n      this.periodChangeDateFormats.setKey(\"month\", this.language.translate(\"_date_month\") + \" \" + this.language.translate(\"_date_year\"));\n    }\n  };\n  /**\n   * Returns a new/empty [[DataItem]] of the type appropriate for this object.\n   *\n   * @see {@link DataItem}\n   * @return Data Item\n   */\n\n\n  DateAxis.prototype.createDataItem = function () {\n    return new DateAxisDataItem();\n  };\n  /**\n   * Returns a new/empty [[AxisBreak]] of the appropriate type.\n   *\n   * @return Axis break\n   */\n\n\n  DateAxis.prototype.createAxisBreak = function () {\n    return new DateAxisBreak();\n  };\n  /**\n   * Validates Axis' data items.\n   *\n   * @ignore Exclude from docs\n   */\n\n\n  DateAxis.prototype.validateDataItems = function () {\n    // allows to keep selection of the same size\n    var start = this.start;\n    var end = this.end;\n    var periodCount = (this.max - this.min) / this.baseDuration;\n\n    _super.prototype.validateDataItems.call(this);\n\n    this.maxZoomFactor = (this.max - this.min) / this.baseDuration;\n    this._deltaMinMax = this.baseDuration / 2; // allows to keep selection of the same size\n\n    var newPeriodCount = (this.max - this.min) / this.baseDuration;\n    start = start + (end - start) * (1 - periodCount / newPeriodCount);\n    this.zoom({\n      start: start,\n      end: end\n    }, false, true); // added instantlyto solve zoomout problem when we have axes gaps. @todo: check how this affects maxZoomFactor\n  };\n  /**\n   * Handles process after zoom.\n   *\n   * @ignore Exclude from docs\n   * @todo Does nothing?\n   */\n\n\n  DateAxis.prototype.handleSelectionExtremesChange = function () {};\n  /**\n   * Calculates all positions, related to axis as per current zoom.\n   *\n   * @ignore Exclude from docs\n   */\n\n\n  DateAxis.prototype.calculateZoom = function () {\n    var _this = this;\n\n    _super.prototype.calculateZoom.call(this);\n\n    var gridInterval = this.chooseInterval(0, this.adjustDifference(this._minZoomed, this._maxZoomed), this._gridCount);\n\n    if ($time.getDuration(gridInterval.timeUnit, gridInterval.count) < this.baseDuration) {\n      gridInterval = tslib_1.__assign({}, this.baseInterval);\n    }\n\n    this._gridInterval = gridInterval;\n    this._gridDate = $time.round(new Date(this.min), gridInterval.timeUnit, gridInterval.count, this.getFirstWeekDay(), this.dateFormatter.utc);\n    this._nextGridUnit = $time.getNextUnit(gridInterval.timeUnit); // the following is needed to avoid grid flickering while scrolling\n\n    this._intervalDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\n    var count = Math.ceil(this._difference / this._intervalDuration);\n    count = Math.max(-5, Math.floor(this.start * count) - 3); // some extra is needed\n\n    $time.add(this._gridDate, gridInterval.timeUnit, count * gridInterval.count, this.dateFormatter.utc); // tell series start/end\n\n    $iter.each(this.series.iterator(), function (series) {\n      if (series.baseAxis == _this) {\n        var field_1 = series.getAxisField(_this);\n        var minZoomed = $time.round(new Date(_this._minZoomed), _this.baseInterval.timeUnit, _this.baseInterval.count).getTime();\n        var minZoomedStr = minZoomed.toString();\n        var startDataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(minZoomedStr);\n        var startIndex = 0;\n\n        if (_this.start != 0) {\n          if (startDataItem) {\n            startDataItem = _this.findFirst(startDataItem, minZoomed, field_1);\n            startIndex = startDataItem.index;\n          } else {\n            startIndex = series.dataItems.findClosestIndex(_this._minZoomed, function (x) {\n              return x[field_1];\n            }, \"left\");\n          }\n        } // 1 millisecond is removed so that if only first item is selected, it would not count in the second.\n\n\n        var baseInterval = _this.baseInterval;\n        var maxZoomed = $time.add($time.round(new Date(_this._maxZoomed), baseInterval.timeUnit, baseInterval.count, _this.getFirstWeekDay(), _this.dateFormatter.utc), baseInterval.timeUnit, baseInterval.count, _this.dateFormatter.utc).getTime();\n        var maxZoomedStr = maxZoomed.toString();\n        var endDataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(maxZoomedStr);\n        var endIndex = series.dataItems.length;\n\n        if (_this.end != 1) {\n          if (endDataItem) {\n            endIndex = endDataItem.index;\n          } else {\n            maxZoomed -= 1;\n            endIndex = series.dataItems.findClosestIndex(maxZoomed, function (x) {\n              return x[field_1];\n            }, \"right\") + 1;\n          }\n        }\n\n        series.startIndex = startIndex;\n        series.endIndex = endIndex;\n      }\n    });\n  };\n\n  DateAxis.prototype.findFirst = function (dataItem, time, key) {\n    var index = dataItem.index;\n\n    if (index > 0) {\n      var series = dataItem.component;\n      var previousDataItem = series.dataItems.getIndex(index - 1);\n      var previousDate = previousDataItem[key];\n\n      if (!previousDate || previousDate.getTime() < time) {\n        return dataItem;\n      } else {\n        return this.findFirst(previousDataItem, time, key);\n      }\n    } else {\n      return dataItem;\n    }\n  };\n  /**\n   * (Re)validates data.\n   *\n   * @ignore Exclude from docs\n   */\n\n\n  DateAxis.prototype.validateData = function () {\n    _super.prototype.validateData.call(this);\n\n    if (!$type.isNumber(this.baseInterval.count)) {\n      this.baseInterval.count = 1;\n    }\n  };\n\n  Object.defineProperty(DateAxis.prototype, \"minDifference\", {\n    /**\n     * @ignore\n     */\n    get: function get() {\n      var _this = this;\n\n      var minDifference = Number.MAX_VALUE;\n      this.series.each(function (series) {\n        if (minDifference > _this._minDifference[series.uid]) {\n          minDifference = _this._minDifference[series.uid];\n        }\n      });\n\n      if (minDifference == Number.MAX_VALUE || minDifference == 0) {\n        minDifference = $time.getDuration(\"day\");\n      }\n\n      return minDifference;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * [dataChangeUpdate description]\n   *\n   *\n   * @ignore Exclude from docs\n   * @todo Description\n   */\n\n  DateAxis.prototype.seriesDataChangeUpdate = function (series) {\n    this._minDifference[series.uid] = Number.MAX_VALUE;\n  };\n  /**\n   * [postProcessSeriesDataItems description]\n   *\n   * @ignore Exclude from docs\n   * @todo Description\n   */\n\n\n  DateAxis.prototype.postProcessSeriesDataItems = function () {\n    var _this = this;\n\n    this.series.each(function (series) {\n      if (JSON.stringify(series._baseInterval[_this.uid]) != JSON.stringify(_this.baseInterval)) {\n        series.dataItems.each(function (dataItem) {\n          _this.postProcessSeriesDataItem(dataItem);\n        });\n        series._baseInterval[_this.uid] = _this.baseInterval;\n      }\n    });\n    this.addEmptyUnitsBreaks();\n  };\n  /**\n   * [postProcessSeriesDataItem description]\n   *\n   * @ignore Exclude from docs\n   * @todo Description\n   * @param dataItem Data item\n   */\n\n\n  DateAxis.prototype.postProcessSeriesDataItem = function (dataItem) {\n    var _this = this; // we need to do this for all series data items not only added recently, as baseInterval might change\n\n\n    var baseInterval = this.baseInterval;\n    var series = dataItem.component;\n    var dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);\n    $object.each(dataItem.dates, function (key) {\n      var date = dataItem.getDate(key);\n      var time = date.getTime();\n      var startDate = $time.round(new Date(time), baseInterval.timeUnit, baseInterval.count, _this.getFirstWeekDay(), _this.dateFormatter.utc);\n      var startTime = startDate.getTime();\n      var endDate = $time.add(new Date(startTime), baseInterval.timeUnit, baseInterval.count, _this.dateFormatter.utc);\n      dataItem.setCalculatedValue(key, startTime, \"open\");\n      dataItem.setCalculatedValue(key, endDate.getTime(), \"close\");\n      dataItemsByAxis.setKey(startTime.toString(), dataItem);\n    });\n  };\n  /**\n   * Collapses empty stretches of date/time scale by creating [[AxisBreak]]\n   * elements for them.\n   *\n   * Can be used to automatically remove strethes without data, like weekends.\n   *\n   * No, need to call this manually. It will automatically be done if\n   * `skipEmptyPeriods = true`.\n   *\n   * @ignore Exclude from docs\n   */\n\n\n  DateAxis.prototype.addEmptyUnitsBreaks = function () {\n    var _this = this;\n\n    if (this.skipEmptyPeriods && $type.isNumber(this.min) && $type.isNumber(this.max)) {\n      var timeUnit = this.baseInterval.timeUnit;\n      var count = this.baseInterval.count;\n      this.axisBreaks.clear(); // TODO: what about breaks added by user?\n\n      var date = $time.round(new Date(this.min), timeUnit, count, this.getFirstWeekDay(), this.dateFormatter.utc);\n      var axisBreak = void 0;\n\n      var _loop_1 = function _loop_1() {\n        $time.add(date, timeUnit, count, this_1.dateFormatter.utc);\n        var startTime = date.getTime();\n        var startTimeStr = startTime.toString();\n        var hasData = $iter.contains(this_1.series.iterator(), function (series) {\n          return !!series.dataItemsByAxis.getKey(_this.uid).getKey(startTimeStr);\n        }); // open break if not yet opened\n\n        if (!hasData) {\n          if (!axisBreak) {\n            axisBreak = this_1.axisBreaks.create();\n            axisBreak.startDate = new Date(startTime);\n          }\n        } else {\n          // close if already opened\n          if (axisBreak) {\n            // close at end time minus one millisecond\n            axisBreak.endDate = new Date(startTime - 1);\n            axisBreak = undefined;\n          }\n        }\n      };\n\n      var this_1 = this;\n\n      while (date.getTime() < this.max - this.baseDuration) {\n        _loop_1();\n      }\n    }\n  };\n  /**\n   * Updates positioning of Axis breaks after something changes.\n   *\n   * @ignore Exclude from docs\n   */\n\n\n  DateAxis.prototype.fixAxisBreaks = function () {\n    var _this = this;\n\n    _super.prototype.fixAxisBreaks.call(this);\n\n    var axisBreaks = this.axisBreaks;\n\n    if (axisBreaks.length > 0) {\n      // process breaks\n      axisBreaks.each(function (axisBreak) {\n        var breakGridCount = Math.ceil(_this._gridCount * (Math.min(_this.end, axisBreak.endPosition) - Math.max(_this.start, axisBreak.startPosition)) / (_this.end - _this.start));\n        axisBreak.gridInterval = _this.chooseInterval(0, axisBreak.adjustedEndValue - axisBreak.adjustedStartValue, breakGridCount);\n        var gridDate = $time.round(new Date(axisBreak.adjustedStartValue), axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, _this.getFirstWeekDay(), _this.dateFormatter.utc);\n\n        if (gridDate.getTime() > axisBreak.startDate.getTime()) {\n          $time.add(gridDate, axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, _this.dateFormatter.utc);\n        }\n\n        axisBreak.gridDate = gridDate;\n      });\n    }\n  };\n  /**\n   * @ignore\n   */\n\n\n  DateAxis.prototype.getFirstWeekDay = function () {\n    if (this.dateFormatter) {\n      return this.dateFormatter.firstDayOfWeek;\n    }\n\n    return 1;\n  };\n  /**\n   * [getGridDate description]\n   *\n   * @ignore Exclude from docs\n   * @todo Description\n   * @param date           [description]\n   * @param intervalCount  [description]\n   * @return [description]\n   */\n\n\n  DateAxis.prototype.getGridDate = function (date, intervalCount) {\n    var timeUnit = this._gridInterval.timeUnit;\n    var realIntervalCount = this._gridInterval.count; // round date\n\n    $time.round(date, timeUnit, 1, this.getFirstWeekDay(), this.dateFormatter.utc);\n    var prevTimestamp = date.getTime();\n    var newDate = $time.copy(date); // modify date by adding intervalcount\n\n    var timestamp = $time.add(newDate, timeUnit, intervalCount, this.dateFormatter.utc).getTime(); // if it's axis break, get first rounded date which is not in a break\n\n    var axisBreak = this.isInBreak(timestamp);\n\n    if (axisBreak) {\n      newDate = new Date(axisBreak.endDate.getTime());\n      $time.round(newDate, timeUnit, realIntervalCount, this.getFirstWeekDay(), this.dateFormatter.utc);\n\n      if (newDate.getTime() < axisBreak.endDate.getTime()) {\n        $time.add(newDate, timeUnit, realIntervalCount, this.dateFormatter.utc);\n      }\n\n      timestamp = newDate.getTime();\n    } // get duration between grid lines with break duration removed\n\n\n    var durationBreaksRemoved = this.adjustDifference(prevTimestamp, timestamp); // calculate how many time units fit to this duration\n\n    var countBreaksRemoved = Math.round(durationBreaksRemoved / $time.getDuration(timeUnit)); // if less units fit, add one and repeat\n\n    if (countBreaksRemoved < realIntervalCount) {\n      return this.getGridDate(date, intervalCount + realIntervalCount);\n    }\n\n    return newDate;\n  };\n  /**\n   * [getBreaklessDate description]\n   *\n   * @ignore Exclude from docs\n   * @todo Description\n   * @param axisBreak  [description]\n   * @param timeUnit   [description]\n   * @param count      [description]\n   * @return [description]\n   */\n\n\n  DateAxis.prototype.getBreaklessDate = function (axisBreak, timeUnit, count) {\n    var date = new Date(axisBreak.endValue);\n    $time.round(date, timeUnit, count, this.getFirstWeekDay(), this.dateFormatter.utc);\n    $time.add(date, timeUnit, count, this.dateFormatter.utc);\n    var timestamp = date.getTime();\n    axisBreak = this.isInBreak(timestamp);\n\n    if (axisBreak) {\n      return this.getBreaklessDate(axisBreak, timeUnit, count);\n    }\n\n    return date;\n  };\n  /**\n   * (Re)validates all Axis elements.\n   *\n   * @ignore Exclude from docs\n   * @todo Description (review)\n   */\n\n\n  DateAxis.prototype.validateAxisElements = function () {\n    var _this = this;\n\n    if ($type.isNumber(this.max) && $type.isNumber(this.min)) {\n      this.calculateZoom(); // first regular items\n\n      var timestamp = this._gridDate.getTime();\n\n      var timeUnit = this._gridInterval.timeUnit;\n      var intervalCount = this._gridInterval.count;\n      var prevGridDate = $time.copy(this._gridDate);\n      var dataItemsIterator_1 = this._dataItemsIterator;\n      this.resetIterators();\n\n      var _loop_2 = function _loop_2() {\n        var date = this_2.getGridDate($time.copy(prevGridDate), intervalCount);\n        timestamp = date.getTime();\n        var endDate = $time.copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length\n\n        endDate = $time.add(endDate, timeUnit, intervalCount, this_2.dateFormatter.utc);\n        var format = this_2.dateFormats.getKey(timeUnit);\n\n        if (this_2.markUnitChange && prevGridDate) {\n          if ($time.checkChange(date, prevGridDate, this_2._nextGridUnit, this_2.dateFormatter.utc)) {\n            if (timeUnit !== \"year\") {\n              format = this_2.periodChangeDateFormats.getKey(timeUnit);\n            }\n          }\n        }\n\n        var text = this_2.dateFormatter.format(date, format);\n        var dataItem = dataItemsIterator_1.find(function (x) {\n          return x.text === text;\n        });\n\n        if (dataItem.__disabled) {\n          dataItem.__disabled = false;\n        }\n\n        this_2.appendDataItem(dataItem);\n        dataItem.axisBreak = undefined;\n        dataItem.date = date;\n        dataItem.endDate = endDate;\n        dataItem.text = text;\n        prevGridDate = date;\n        this_2.validateDataElement(dataItem);\n      };\n\n      var this_2 = this;\n\n      while (timestamp <= this._maxZoomed) {\n        _loop_2();\n      } // breaks later\n\n\n      var renderer_1 = this.renderer;\n      $iter.each(this.axisBreaks.iterator(), function (axisBreak) {\n        if (axisBreak.breakSize > 0) {\n          var timeUnit_1 = axisBreak.gridInterval.timeUnit;\n          var intervalCount_1 = axisBreak.gridInterval.count; // only add grid if gap is bigger then minGridDistance\n\n          if ($math.getDistance(axisBreak.startPoint, axisBreak.endPoint) > renderer_1.minGridDistance * 4) {\n            var timestamp_1 = axisBreak.gridDate.getTime();\n            var prevGridDate_1;\n            var count = 0;\n\n            var _loop_3 = function _loop_3() {\n              var date = $time.copy(axisBreak.gridDate);\n              timestamp_1 = $time.add(date, timeUnit_1, intervalCount_1 * count, _this.dateFormatter.utc).getTime();\n              count++;\n\n              if (timestamp_1 > axisBreak.adjustedStartValue && timestamp_1 < axisBreak.adjustedEndValue) {\n                var endDate = $time.copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length\n\n                endDate = $time.add(endDate, timeUnit_1, intervalCount_1, _this.dateFormatter.utc);\n\n                var format = _this.dateFormats.getKey(timeUnit_1);\n\n                if (_this.markUnitChange && prevGridDate_1) {\n                  if ($time.checkChange(date, prevGridDate_1, _this._nextGridUnit, _this.dateFormatter.utc)) {\n                    if (timeUnit_1 !== \"year\") {\n                      format = _this.periodChangeDateFormats.getKey(timeUnit_1);\n                    }\n                  }\n                }\n\n                var text_1 = _this.dateFormatter.format(date, format);\n\n                var dataItem = dataItemsIterator_1.find(function (x) {\n                  return x.text === text_1;\n                });\n\n                if (dataItem.__disabled) {\n                  dataItem.__disabled = false;\n                } //this.processDataItem(dataItem);\n\n\n                _this.appendDataItem(dataItem);\n\n                dataItem.axisBreak = axisBreak;\n                axisBreak.dataItems.moveValue(dataItem);\n                dataItem.date = date;\n                dataItem.endDate = endDate;\n                dataItem.text = text_1;\n                prevGridDate_1 = date;\n\n                _this.validateDataElement(dataItem);\n              }\n            };\n\n            while (timestamp_1 <= axisBreak.adjustedMax) {\n              _loop_3();\n            }\n          }\n        }\n      });\n    }\n  };\n  /**\n   * Validates Axis data item.\n   *\n   * @ignore Exclude from docs\n   * @param dataItem Data item\n   */\n\n\n  DateAxis.prototype.validateDataElement = function (dataItem) {\n    //super.validateDataElement(dataItem);\n    if ($type.isNumber(this.max) && $type.isNumber(this.min)) {\n      var renderer = this.renderer;\n      var timestamp = dataItem.value;\n      var endTimestamp = dataItem.endValue;\n\n      if (!$type.isNumber(endTimestamp)) {\n        endTimestamp = timestamp;\n      }\n\n      var position = this.valueToPosition(timestamp);\n      var endPosition = this.valueToPosition(endTimestamp);\n      var fillEndPosition = endPosition;\n\n      if (!dataItem.isRange && this._gridInterval.count > this.baseInterval.count) {\n        endPosition = position + (endPosition - position) / (this._gridInterval.count / this.baseInterval.count);\n      }\n\n      dataItem.position = position;\n      var tick = dataItem.tick;\n\n      if (tick && !tick.disabled) {\n        renderer.updateTickElement(tick, position, endPosition);\n      }\n\n      var grid = dataItem.grid;\n\n      if (grid && !grid.disabled) {\n        renderer.updateGridElement(grid, position, endPosition);\n      }\n\n      var fill = dataItem.axisFill;\n\n      if (fill && !fill.disabled) {\n        renderer.updateFillElement(fill, position, fillEndPosition);\n\n        if (!dataItem.isRange) {\n          this.fillRule(dataItem);\n        }\n      }\n\n      var mask = dataItem.mask;\n\n      if (mask) {\n        renderer.updateFillElement(mask, position, endPosition);\n      }\n\n      var label = dataItem.label;\n\n      if (label && !label.disabled) {\n        var location_1 = label.location;\n\n        if (location_1 == 0) {\n          if (this._gridInterval.count == 1 && this._gridInterval.timeUnit != \"week\" && !dataItem.isRange) {\n            location_1 = 0.5;\n          } else {\n            location_1 = 0;\n          }\n        }\n\n        renderer.updateLabelElement(label, position, endPosition, location_1);\n      }\n    }\n  };\n\n  Object.defineProperty(DateAxis.prototype, \"baseDuration\", {\n    /**\n     * A duration in milliseconds of the `baseInterval`.\n     *\n     * @return Duration (ms)\n     */\n    get: function get() {\n      return $time.getDuration(this.baseInterval.timeUnit, this.baseInterval.count);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Adjusts min/max values.\n   *\n   * @ignore Exclude from docs.\n   * @todo Description (review)\n   * @param min  Min timestamp\n   * @param max  Max timestamp\n   * @return Adjusted min/max step\n   */\n\n  DateAxis.prototype.adjustMinMax = function (min, max) {\n    return {\n      min: min,\n      max: max,\n      step: this.baseDuration\n    };\n  };\n  /**\n   * Adjusts the minimum timestamp as per cell start location.\n   *\n   * @param value  Value\n   * @return Adjusted value\n   */\n\n\n  DateAxis.prototype.fixMin = function (value) {\n    // like this because months are not equal\n    var startTime = $time.round(new Date(value), this.baseInterval.timeUnit, this.baseInterval.count, this.getFirstWeekDay(), this.dateFormatter.utc).getTime();\n    var endTime = $time.add(new Date(startTime), this.baseInterval.timeUnit, this.baseInterval.count, this.dateFormatter.utc).getTime();\n    return startTime + (endTime - startTime) * this.startLocation;\n  };\n  /**\n   * Adjusts the maximum timestamp as per cell start location.\n   *\n   * @param value  Value\n   * @return Adjusted value\n   */\n\n\n  DateAxis.prototype.fixMax = function (value) {\n    // like this because months are not equal\n    var startTime = $time.round(new Date(value), this.baseInterval.timeUnit, this.baseInterval.count, this.getFirstWeekDay(), this.dateFormatter.utc).getTime();\n    var endTime = $time.add(new Date(startTime), this.baseInterval.timeUnit, this.baseInterval.count, this.dateFormatter.utc).getTime();\n    return startTime + (endTime - startTime) * this.endLocation;\n  };\n  /**\n   * [chooseInterval description]\n   *\n   * @ignore Exclude from docs.\n   * @todo Description\n   * @param index      [description]\n   * @param duration   [description]\n   * @param gridCount  [description]\n   * @return [description]\n   */\n\n\n  DateAxis.prototype.chooseInterval = function (index, duration, gridCount) {\n    var gridIntervals = this.gridIntervals;\n    var gridInterval = gridIntervals.getIndex(index);\n    var intervalDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\n    var lastIndex = gridIntervals.length - 1;\n\n    if (index >= lastIndex) {\n      return tslib_1.__assign({}, gridIntervals.getIndex(lastIndex));\n    }\n\n    var count = Math.ceil(duration / intervalDuration);\n\n    if (duration < intervalDuration && index > 0) {\n      return tslib_1.__assign({}, gridIntervals.getIndex(index - 1));\n    }\n\n    if (count <= gridCount) {\n      return tslib_1.__assign({}, gridIntervals.getIndex(index));\n    } else {\n      if (index + 1 < gridIntervals.length) {\n        return this.chooseInterval(index + 1, duration, gridCount);\n      } else {\n        return tslib_1.__assign({}, gridIntervals.getIndex(index));\n      }\n    }\n  };\n  /**\n   * Formats the value according to axis' own [[DateFormatter]].\n   *\n   * @param value  Source value\n   * @return Formatted value\n   */\n\n\n  DateAxis.prototype.formatLabel = function (value) {\n    return this.dateFormatter.format(value);\n  };\n  /**\n   * Converts a Date to an asbolute pixel position within Axis.\n   *\n   * @param date  Date\n   * @return Position (px)\n   */\n\n\n  DateAxis.prototype.dateToPosition = function (date) {\n    return this.valueToPosition(date.getTime());\n  };\n  /**\n   * Converts a numeric timestamp or a `Date` to a relative position on axis.\n   *\n   * @param date  Date or a timestamp\n   * @return Relative position\n   */\n\n\n  DateAxis.prototype.anyToPosition = function (date) {\n    if (date instanceof Date) {\n      return this.dateToPosition(date);\n    } else {\n      return this.valueToPosition(date);\n    }\n  };\n  /**\n   * Converts date to orientation point (x, y, angle) on axis\n   *\n   * @param date Date\n   * @return IOrientationPoint\n   */\n\n\n  DateAxis.prototype.dateToPoint = function (date) {\n    var position = this.dateToPosition(date);\n    var point = this.renderer.positionToPoint(position);\n    var angle = this.renderer.positionToAngle(position);\n    return {\n      x: point.x,\n      y: point.y,\n      angle: angle\n    };\n  };\n  /**\n   * Converts a numeric value to orientation (x, y, angle) point on axis\n   *\n   * @param value  Value\n   * @return Orientation point\n   */\n\n\n  DateAxis.prototype.anyToPoint = function (date) {\n    if (date instanceof Date) {\n      return this.dateToPoint(date);\n    } else {\n      return this.valueToPoint(date);\n    }\n  };\n  /**\n   * Converts pixel position within Axis to a corresponding Date.\n   *\n   * @param position  Position (px)\n   * @return Date\n   */\n\n\n  DateAxis.prototype.positionToDate = function (position) {\n    return new Date(this.positionToValue(position));\n  };\n  /**\n   * Returns the X coordinate for series' data item's value.\n   *\n   * @ignore Exclude from docs\n   * @todo Description (review)\n   * @param dataItem  Data item\n   * @param key       Data field to get value from\n   * @param location  Location (0-1)\n   * @return X coordinate (px)\n   */\n\n\n  DateAxis.prototype.getX = function (dataItem, key, location) {\n    var value = this.getTimeByLocation(dataItem, key, location); //let stack: number = dataItem.getValue(\"valueX\", \"stack\");\n\n    if (!$type.isNumber(value)) {\n      value = this.baseValue;\n    }\n\n    return this.renderer.positionToPoint(this.valueToPosition(value)).x;\n  };\n  /**\n   * Returns the Y coordinate for series' data item's value.\n   *\n   * @ignore Exclude from docs\n   * @todo Description (review)\n   * @param dataItem  Data item\n   * @param key       Data field to get value from\n   * @param location  Location (0-1)\n   * @return Y coordinate (px)\n   */\n\n\n  DateAxis.prototype.getY = function (dataItem, key, location) {\n    var value = this.getTimeByLocation(dataItem, key, location);\n    var stack = dataItem.getValue(\"valueX\", \"stack\");\n\n    if (!$type.isNumber(value)) {\n      value = this.baseValue;\n    }\n\n    return this.renderer.positionToPoint(this.valueToPosition(value + stack)).y;\n  };\n  /**\n   * Returns an angle for series data item.\n   *\n   * @ignore Exclude from docs\n   * @todo Description (review)\n   * @param dataItem  Data item\n   * @param key       Data field to get value from\n   * @param location  Location (0-1)\n   * @param stackKey  Stack ID\n   * @return Angle\n   */\n\n\n  DateAxis.prototype.getAngle = function (dataItem, key, location, stackKey) {\n    var value = this.getTimeByLocation(dataItem, key, location);\n    var stack = dataItem.getValue(stackKey, \"stack\");\n\n    if (!$type.isNumber(value)) {\n      value = this.baseValue;\n    }\n\n    return this.positionToAngle(this.valueToPosition(value + stack));\n  };\n  /**\n   * [getTimeByLocation description]\n   *\n   * @ignore Exclude from docs\n   * @todo Description\n   * @param dataItem  [description]\n   * @param key       [description]\n   * @param location  [description]\n   * @return [description]\n   */\n\n\n  DateAxis.prototype.getTimeByLocation = function (dataItem, key, location) {\n    if (!$type.hasValue(key)) {\n      return;\n    }\n\n    if (!$type.isNumber(location)) {\n      location = dataItem.workingLocations[key];\n\n      if (!$type.isNumber(location)) {\n        location = 0;\n      }\n    }\n\n    var startTime = dataItem.values[key][\"open\"];\n    var endTime = dataItem.values[key][\"close\"];\n\n    if ($type.isNumber(startTime) && $type.isNumber(endTime)) {\n      return startTime + (endTime - startTime) * location;\n    }\n  };\n  /**\n   * Processes a related series' data item.\n   *\n   * @ignore Exclude from docs\n   * @todo Description\n   * @param dataItem  Data item\n   */\n\n\n  DateAxis.prototype.processSeriesDataItem = function (dataItem, axisLetter) {\n    var series = dataItem.component;\n    var time;\n    var date = dataItem[\"date\" + axisLetter];\n\n    if (date) {\n      time = date.getTime();\n    } else {\n      return;\n    }\n\n    var openDate = dataItem[\"openDate\" + axisLetter];\n    var prevSeriesTime = this._prevSeriesTime;\n    var openTime;\n\n    if (openDate) {\n      openTime = openDate.getTime();\n    }\n\n    if ($type.isNumber(openTime)) {\n      var difference = Math.abs(time - openTime);\n\n      if (this._minDifference[series.uid] > difference) {\n        this._minDifference[series.uid] = difference;\n      }\n    }\n\n    var differece = time - prevSeriesTime;\n\n    if (differece > 0) {\n      if (this._minDifference[series.uid] > differece) {\n        this._minDifference[series.uid] = differece;\n      }\n    }\n\n    this._prevSeriesTime = time;\n\n    if (series._baseInterval[this.uid]) {\n      this.postProcessSeriesDataItem(dataItem);\n    } else {\n      if (this._baseInterval) {\n        series._baseInterval[this.uid] = this._baseInterval;\n        this.postProcessSeriesDataItem(dataItem);\n      }\n    }\n  };\n  /**\n   * [updateAxisBySeries description]\n   *\n   * @ignore Exclude from docs\n   * @todo Description\n   */\n\n\n  DateAxis.prototype.updateAxisBySeries = function () {\n    _super.prototype.updateAxisBySeries.call(this);\n\n    var baseInterval = this.chooseInterval(0, this.minDifference, 1); // handle short months\n\n    if (this.minDifference >= $time.getDuration(\"day\", 27) && baseInterval.timeUnit == \"week\") {\n      baseInterval.timeUnit = \"month\";\n      baseInterval.count = 1;\n    } // handle daylight saving\n\n\n    if (this.minDifference >= $time.getDuration(\"hour\", 23) && baseInterval.timeUnit == \"hour\") {\n      baseInterval.timeUnit = \"day\";\n      baseInterval.count = 1;\n    }\n\n    if (this.minDifference >= $time.getDuration(\"week\", 1) - $time.getDuration(\"hour\", 1) && baseInterval.timeUnit == \"day\") {\n      baseInterval.timeUnit = \"week\";\n      baseInterval.count = 1;\n    }\n\n    if (this.minDifference >= $time.getDuration(\"year\", 1) - $time.getDuration(\"day\", 1.01) && baseInterval.timeUnit == \"month\") {\n      baseInterval.timeUnit = \"year\";\n      baseInterval.count = 1;\n    }\n\n    this._baseIntervalReal = baseInterval; // no need to invalidate\n  };\n\n  Object.defineProperty(DateAxis.prototype, \"baseInterval\", {\n    /**\n     * @return Base interval\n     */\n    get: function get() {\n      if (this._baseInterval) {\n        return this._baseInterval;\n      } else {\n        return this._baseIntervalReal;\n      }\n    },\n\n    /**\n     * A base interval (granularity) of data.\n     *\n     * Used to indicate what are the base units of your data.\n     *\n     * For example, if you have a data set that has a data point every 5 minutes,\n     * you may want to set this to `{ timeUnit: \"minute\", count: 5 }`.\n     *\n     * If not set, the Axis will try to determine the setting by its own, looking\n     * at actual data.\n     *\n     * @param timeInterval base interval\n     */\n    set: function set(timeInterval) {\n      if (JSON.stringify(this._baseInterval) != JSON.stringify(timeInterval)) {\n        this._baseInterval = timeInterval;\n        this.invalidate();\n        this.postProcessSeriesDataItems();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"skipEmptyPeriods\", {\n    /**\n     * @return Remove empty stretches of time?\n     */\n    get: function get() {\n      return this.getPropertyValue(\"skipEmptyPeriods\");\n    },\n\n    /**\n     * If enabled, axis will automatically collapse empty (without data points)\n     * periods of time, i.e. weekends.\n     *\n     * An \"empty\" period is considered a stretch of time in the length of current\n     * `baseInterval` without a single data point in it.\n     *\n     * For each such empty period, axis will automatically create an\n     * [[AxisBreak]]. By default they will be invisible. You can still configure\n     * them by accessing `axis.breaks.template`.\n     *\n     * [More info about breaks](https://www.amcharts.com/docs/v4/concepts/axes/#Breaks).\n     *\n     * Important notes:\n     * * If you set this property to `true`, you can not add your custom axis breaks to this axis anymore.\n     * * Using this feature affects performance. Use only if you need it.\n     * * Setting this to `true` will reset appearance of breaks. If you want to modify appearance, do it *after* you set `skipEmptyPeriods`.\n     *\n     * @default false\n     * @param value  Remove empty stretches of time?\n     */\n    set: function set(value) {\n      if (this.setPropertyValue(\"skipEmptyPeriods\", value)) {\n        this.invalidateData();\n      }\n\n      if (value) {\n        var breakTemplate = this.axisBreaks.template;\n        breakTemplate.startLine.disabled = true;\n        breakTemplate.endLine.disabled = true;\n        breakTemplate.fillShape.disabled = true;\n        breakTemplate.breakSize = 0;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"tooltipDateFormat\", {\n    /**\n     * @return Date format\n     */\n    get: function get() {\n      return this.getPropertyValue(\"tooltipDateFormat\");\n    },\n\n    /**\n     * A special date format to apply axis tooltips.\n     *\n     * Will use same format as for labels, if not set.\n     *\n     * @param value  Date format\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"tooltipDateFormat\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"markUnitChange\", {\n    /**\n     * @return Use different format for period beginning?\n     */\n    get: function get() {\n      return this.getPropertyValue(\"markUnitChange\");\n    },\n\n    /**\n     * Use `periodChangeDateFormats` to apply different formats to the first\n     * label in bigger time unit.\n     *\n     * @default true\n     * @param value  Use different format for period beginning?\n     */\n    set: function set(value) {\n      if (this.setPropertyValue(\"markUnitChange\", value)) {\n        this.invalidateData();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Returns text to show in a tooltip, based on specific relative position\n   * within axis.\n   *\n   * The label will be formatted as per [[DateFormatter]] set for the whole\n   * chart, or explicitly for this Axis.\n   *\n   * @ignore Exclude from docs\n   * @param position  Position\n   * @return Label (formatted date)\n   */\n\n  DateAxis.prototype.getTooltipText = function (position) {\n    var text;\n    var date = this.positionToDate(position);\n    date = $time.round(date, this.baseInterval.timeUnit, this.baseInterval.count, this.getFirstWeekDay(), this.dateFormatter.utc);\n\n    if ($type.hasValue(this.tooltipDateFormat)) {\n      text = this.dateFormatter.format(date, this.tooltipDateFormat);\n    } else {\n      var dateFormat = this.dateFormats.getKey(this.baseInterval.timeUnit);\n\n      if (dateFormat) {\n        text = this.dateFormatter.format(date, dateFormat);\n      } else {\n        text = this.getPositionLabel(position);\n      }\n    }\n\n    return this.adapter.apply(\"getTooltipText\", text);\n  };\n  /**\n   * Takes an absolute position within axis and adjust it to a specific position within base interval. (cell)\n   *\n   * @ignore Exclude from docs\n   * @param position Source position\n   * @param location  Location in the cell\n   * @return Adjusted position\n   */\n\n\n  DateAxis.prototype.roundPosition = function (position, location) {\n    var baseInterval = this.baseInterval;\n    var timeUnit = baseInterval.timeUnit;\n    var count = baseInterval.count;\n    var date = this.positionToDate(position);\n    $time.round(date, timeUnit, count, this.getFirstWeekDay(), this.dateFormatter.utc);\n\n    if (location > 0) {\n      $time.add(date, timeUnit, location * count, this.dateFormatter.utc);\n    }\n\n    if (this.isInBreak(date.getTime())) {\n      while (date.getTime() < this.max) {\n        $time.add(date, timeUnit, count, this.dateFormatter.utc);\n\n        if (!this.isInBreak(date.getTime())) {\n          break;\n        }\n      }\n    }\n\n    return this.dateToPosition(date);\n  };\n  /**\n   * Returns an relative position of the start of the cell (period), that specific position value falls into.\n   *\n   * @ignore Exclude from docs\n   * @todo Description (review)\n   * @param position  Relative position\n   * @return Cell start relative position\n   */\n\n\n  DateAxis.prototype.getCellStartPosition = function (position) {\n    return this.roundPosition(position, 0);\n  };\n  /**\n   * Returns an relative position of the end of the cell (period), that specific position value falls into.\n   *\n   * @ignore Exclude from docs\n   * @todo Description (review)\n   * @param position  Relative position\n   * @return Cell end relative position\n   */\n\n\n  DateAxis.prototype.getCellEndPosition = function (position) {\n    return this.roundPosition(position, 1); //return this.dateToPosition($time.add(this.positionToDate(this.roundPosition(position, 1)), this.baseInterval.timeUnit, this.baseInterval.count));\n  };\n  /**\n   * Returns a Series data item that corresponds to the specific pixel position\n   * of the Axis.\n   *\n   * If `findNearest` (third parameter) is set to `true`, the method will try\n   * to locate nearest available data item if none is found directly under\n   * `position`.\n   *\n   * @param series       Series\n   * @param position     Position (px)\n   * @param findNearest  Should axis try to find nearest tooltip if there is no data item at exact position\n   * @return Data item\n   */\n\n\n  DateAxis.prototype.getSeriesDataItem = function (series, position, findNearest) {\n    var value = this.positionToValue(position);\n    var date = $time.round(new Date(value), this.baseInterval.timeUnit, this.baseInterval.count, this.getFirstWeekDay(), this.dateFormatter.utc);\n    var dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);\n    var dataItem = dataItemsByAxis.getKey(date.getTime().toString()); // todo:  alternatively we can find closiest here\n\n    if (!dataItem && findNearest) {\n      var key_1;\n\n      if (this.axisLetter == \"Y\") {\n        key_1 = \"dateY\";\n      } else {\n        key_1 = \"dateX\";\n      }\n\n      dataItem = series.dataItems.getIndex(series.dataItems.findClosestIndex(date.getTime(), function (x) {\n        if (x[key_1]) {\n          return x[key_1].getTime();\n        } else {\n          return -Infinity;\n        }\n      }, \"any\"));\n    }\n\n    return dataItem;\n  };\n  /**\n   * Returns a formatted date based on position in axis scale.\n   *\n   * Please note that `position` represents position within axis which may be\n   * zoomed and not correspond to Cursor's `position`.\n   *\n   * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\n   *\n   * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\n   * @param position  Relative position on axis (0-1)\n   * @return Position label\n   */\n\n\n  DateAxis.prototype.getPositionLabel = function (position) {\n    // @todo Better format recognition\n    var date = this.positionToDate(position);\n    return this.dateFormatter.format(date, this.getCurrentLabelFormat());\n  };\n  /**\n   * Returns label date format based on currently used time units\n   *\n   * @return Format\n   */\n\n\n  DateAxis.prototype.getCurrentLabelFormat = function () {\n    return this.dateFormats.getKey(this._gridInterval ? this._gridInterval.timeUnit : \"day\");\n  };\n  /**\n   * Initializes an Axis renderer.\n   *\n   * @ignore Exclude from docs\n   */\n\n\n  DateAxis.prototype.initRenderer = function () {\n    _super.prototype.initRenderer.call(this);\n\n    var renderer = this.renderer;\n\n    if (renderer) {\n      // Set defaults\n      renderer.ticks.template.location = 0;\n      renderer.grid.template.location = 0;\n      renderer.labels.template.location = 0;\n      renderer.baseGrid.disabled = true;\n    }\n  };\n\n  Object.defineProperty(DateAxis.prototype, \"basePoint\", {\n    /**\n     * Coordinates of the actual axis start.\n     *\n     * @ignore Exclude from docs\n     * @return Base point\n     */\n    get: function get() {\n      return {\n        x: 0,\n        y: 0\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Zooms axis to specific Dates.\n   *\n   * @param startDate       Start date\n   * @param endValue        End date\n   * @param skipRangeEvent  Do not invoke events\n   * @param instantly       Do not play zoom animations\n   */\n\n  DateAxis.prototype.zoomToDates = function (startDate, endDate, skipRangeEvent, instantly) {\n    startDate = this.dateFormatter.parse(startDate);\n    endDate = this.dateFormatter.parse(endDate);\n    this.zoomToValues(startDate.getTime(), endDate.getTime(), skipRangeEvent, instantly);\n  };\n  /**\n   * Adds `baseInterval` to \"as is\" fields.\n   *\n   * @param field  Field name\n   * @return Assign as is?\n   */\n\n\n  DateAxis.prototype.asIs = function (field) {\n    return field == \"baseInterval\" || _super.prototype.asIs.call(this, field);\n  };\n  /**\n   * Copies all properties and related data from a different instance of Axis.\n   *\n   * @param source Source Axis\n   */\n\n\n  DateAxis.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n\n    this.dateFormats = source.dateFormats;\n    this.periodChangeDateFormats = source.periodChangeDateFormats;\n\n    if (source[\"_baseInterval\"]) {\n      this.baseInterval = source.baseInterval;\n    }\n  };\n  /**\n   * Shows Axis tooltip at specific relative position within Axis. (0-1)\n   *\n   * @param position Position (0-1)\n   * @param local or global position\n   */\n\n\n  DateAxis.prototype.showTooltipAtPosition = function (position, local) {\n    var _this = this;\n\n    if (!local) {\n      position = this.toAxisPosition(position);\n    }\n\n    if (this.snapTooltip) {\n      var actualDate = $time.round(this.positionToDate(position), this.baseInterval.timeUnit, 1, this.getFirstWeekDay(), this.dateFormatter.utc);\n      var actualTime_1 = actualDate.getTime();\n      var closestDate_1;\n      this.series.each(function (series) {\n        if (series.baseAxis == _this) {\n          var dataItem = _this.getSeriesDataItem(series, position, true);\n\n          if (dataItem) {\n            var date = void 0;\n\n            if (series.xAxis == _this) {\n              date = dataItem.dateX;\n            }\n\n            if (series.yAxis == _this) {\n              date = dataItem.dateY;\n            }\n\n            if (!closestDate_1) {\n              closestDate_1 = date;\n            } else {\n              if (Math.abs(closestDate_1.getTime() - actualTime_1) > Math.abs(date.getTime() - actualTime_1)) {\n                closestDate_1 = date;\n              }\n            }\n          }\n        }\n      });\n\n      if (closestDate_1) {\n        var closestTime_1 = closestDate_1.getTime();\n        closestDate_1 = $time.round(new Date(closestTime_1), this.baseInterval.timeUnit, this.baseInterval.count, this.getFirstWeekDay(), this.dateFormatter.utc);\n        closestTime_1 = closestDate_1.getTime();\n        closestDate_1 = new Date(closestDate_1.getTime() + this.baseDuration * this.renderer.tooltipLocation);\n        position = this.dateToPosition(closestDate_1);\n        this.series.each(function (series) {\n          var dataItem = series.dataItemsByAxis.getKey(_this.uid).getKey(closestTime_1.toString());\n          var point = series.showTooltipAtDataItem(dataItem);\n\n          if (point) {\n            _this.chart._seriesPoints.push({\n              series: series,\n              point: point\n            });\n          } else {\n            // check, otherwise column tooltip will be hidden\n            if (series.tooltipText || series.tooltipHTML) {\n              series.hideTooltip();\n            }\n          }\n        }); //this.chart.sortSeriesTooltips(seriesPoints);\n      }\n    }\n\n    _super.prototype.showTooltipAtPosition.call(this, position, true);\n  };\n\n  Object.defineProperty(DateAxis.prototype, \"snapTooltip\", {\n    /**\n     * @return Should snap?\n     */\n    get: function get() {\n      return this.getPropertyValue(\"snapTooltip\");\n    },\n\n    /**\n     * Should the nearest tooltip be shown if no data item is found on the\n     * current cursor position.\n     *\n     * @default true\n     * @param value  Should snap?\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"snapTooltip\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DateAxis.prototype, \"gridInterval\", {\n    /**\n     * Current grid interval.\n     *\n     * @return Grid interval\n     */\n    get: function get() {\n      return this._gridInterval;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * @ignore\n   */\n\n  DateAxis.prototype.makeGap = function (dataItem, previous) {\n    var series = dataItem.component;\n\n    if (dataItem && previous) {\n      if (!series.connect && $type.isNumber(series.autoGapCount)) {\n        if (series.baseAxis == this) {\n          var time = dataItem.dates[\"date\" + this.axisLetter].getTime();\n          var prevTime = previous.dates[\"date\" + this.axisLetter].getTime();\n\n          if (time - prevTime > series.autoGapCount * this.baseDuration) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n\n  return DateAxis;\n}(ValueAxis);\n\nexport { DateAxis };\n/**\n * Register class in system, so that it can be instantiated using its name from\n * anywhere.\n *\n * @ignore\n */\n\nregistry.registeredClasses[\"DateAxis\"] = DateAxis;\nregistry.registeredClasses[\"DateAxisDataItem\"] = DateAxisDataItem;","map":{"version":3,"sources":["../../../../../src/.internal/charts/axes/DateAxis.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * DateAxis module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { ValueAxis, ValueAxisDataItem, IValueAxisProperties, IValueAxisDataFields, IValueAxisAdapters, IValueAxisEvents } from \"./ValueAxis\";\r\nimport { AxisItemLocation } from \"./Axis\";\r\nimport { AxisRenderer } from \"./AxisRenderer\";\r\nimport { AxisTick } from \"./AxisTick\";\r\nimport { AxisLabel } from \"./AxisLabel\";\r\nimport { AxisFill } from \"./AxisFill\";\r\nimport { List } from \"../../core/utils/List\";\r\nimport { Dictionary } from \"../../core/utils/Dictionary\";\r\nimport { IPoint, IOrientationPoint } from \"../../core/defs/IPoint\";\r\nimport { Grid } from \"./Grid\";\r\nimport { XYSeries, XYSeriesDataItem } from \"../series/XYSeries\";\r\nimport { LineSeriesDataItem } from \"../series/LineSeries\";\r\nimport { TimeUnit } from \"../../core/defs/TimeUnit\";\r\nimport { ITimeInterval } from \"../../core/defs/ITimeInterval\";\r\nimport { IMinMaxStep } from \"./ValueAxis\";\r\nimport { DateAxisBreak } from \"./DateAxisBreak\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport * as $time from \"../../core/utils/Time\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $object from \"../../core/utils/Object\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines data item for [[DateAxis]].\r\n *\r\n * @see {@link DataItem}\r\n */\r\nexport class DateAxisDataItem extends ValueAxisDataItem {\r\n\r\n\t/**\r\n\t * Defines a type of [[Component]] this data item is used for.\r\n\t */\r\n\tpublic _component!: DateAxis;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"DateAxisDataItem\";\r\n\t\tthis.applyTheme();\r\n\r\n\t\tthis.values.date = {};\r\n\t\tthis.values.endDate = {};\r\n\t}\r\n\r\n\t/**\r\n\t * Date position of the data item.\r\n\t *\r\n\t * @param date  Date\r\n\t */\r\n\tpublic set date(date: Date) {\r\n\t\tthis.setDate(\"date\", date);\r\n\t\tthis.value = date.getTime();\r\n\t}\r\n\r\n\t/**\r\n\t * @return Date\r\n\t */\r\n\tpublic get date(): Date {\r\n\t\treturn this.dates[\"date\"];\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * End date for data item.\r\n\t *\r\n\t * @param date End date\r\n\t */\r\n\tpublic set endDate(date: Date) {\r\n\t\tthis.setDate(\"endDate\", date);\r\n\t\tthis.endValue = date.getTime();\r\n\t}\r\n\r\n\t/**\r\n\t * @return End date\r\n\t */\r\n\tpublic get endDate(): Date {\r\n\t\treturn this.dates[\"endDate\"];\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines data fields for [[DateAxis]].\r\n */\r\nexport interface IDateAxisDataFields extends IValueAxisDataFields {\r\n\r\n\t/**\r\n\t * Date.\r\n\t */\r\n\tdate?: string;\r\n\r\n}\r\n\r\n/**\r\n * Defines properties for [[DateAxis]].\r\n */\r\nexport interface IDateAxisProperties extends IValueAxisProperties {\r\n\r\n\t/**\r\n\t * If enabled, axis will automatically collapse empty (without data points)\r\n\t * periods of time, i.e. weekends.\r\n\t *\r\n\t * @default false\r\n\t */\r\n\tskipEmptyPeriods?: boolean;\r\n\r\n\t/**\r\n\t * Use `periodChangeDateFormats` to apply different formats to the first\r\n\t * label in bigger time unit.\r\n\t *\r\n\t * @default true\r\n\t * @param value  Use different format for period beginning?\r\n\t */\r\n\tmarkUnitChange?: boolean;\r\n\r\n\t/**\r\n\t * Should the nearest tooltip be shown if no data item is found on the\r\n\t * current cursor position.\r\n\t *\r\n\t * @default true\r\n\t */\r\n\tsnapTooltip?: boolean;\r\n\r\n\t/**\r\n\t * A special date format to apply axis tooltips.\r\n\t *\r\n\t * Will use same format as for labels, if not set.\r\n\t */\r\n\ttooltipDateFormat?: string;\r\n}\r\n\r\n/**\r\n * Defines events for [[DateAxis]].\r\n */\r\nexport interface IDateAxisEvents extends IValueAxisEvents { }\r\n\r\n/**\r\n * Defines adapters for [[DateAxis]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IDateAxisAdapters extends IValueAxisAdapters, IDateAxisProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Used to create a date/time-based axis for the chart.\r\n *\r\n * ```TypeScript\r\n * // Create the axis\r\n * let xAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n *\r\n * // Set settings\r\n * xAxis.title.text = \"Time\";\r\n * ```\r\n * ```JavaScript\r\n * // Create the axis\r\n * var valueAxis = chart.xAxes.push(new am4charts.DateAxis());\r\n *\r\n * // Set settings\r\n * valueAxis.title.text = \"Time\";\r\n * ```\r\n * ```JSON\r\n * \"xAxes\": [{\r\n *   \"type\": \"DateAxis\",\r\n *   \"title\": {\r\n *     \"text\": \"Time\"\r\n *   }\r\n * }]\r\n * ```\r\n *\r\n * @see {@link IDateAxisEvents} for a list of available Events\r\n * @see {@link IDateAxisAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nexport class DateAxis<T extends AxisRenderer = AxisRenderer> extends ValueAxis<T> {\r\n\r\n\t/**\r\n\t * Defines data fields.\r\n\t */\r\n\tpublic _dataFields: IDateAxisDataFields;\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IDateAxisProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IDateAxisAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IDateAxisEvents;\r\n\r\n\t/**\r\n\t * Defines the type of the Date Items.\r\n\t */\r\n\tpublic _dataItem: DateAxisDataItem;\r\n\r\n\t/**\r\n\t * Defines the type of the axis breaks.\r\n\t */\r\n\tpublic _axisBreak: DateAxisBreak;\r\n\r\n\t/**\r\n\t * A list of date/time intervals for Date axis.\r\n\t *\r\n\t * This define various granularities available for the axis. For example\r\n\t * if you have an axis spanning an hour, and space for 6 grid lines / labels\r\n\t * the axis will choose the granularity of 10 minutes, displaying a label\r\n\t * every 10 minutes.\r\n\t *\r\n\t * Default intervals:\r\n\t *\r\n\t * ```JSON\r\n\t * [\r\n\t *  { timeUnit: \"millisecond\", count: 1 },\r\n\t *  { timeUnit: \"millisecond\", count: 5 },\r\n\t *  { timeUnit: \"millisecond\", count: 10 },\r\n\t *  { timeUnit: \"millisecond\", count: 50 },\r\n\t *  { timeUnit: \"millisecond\", count: 100 },\r\n\t *  { timeUnit: \"millisecond\", count: 500 },\r\n\t *  { timeUnit: \"second\", count: 1 },\r\n\t *  { timeUnit: \"second\", count: 5 },\r\n\t *  { timeUnit: \"second\", count: 10 },\r\n\t *  { timeUnit: \"second\", count: 30 },\r\n\t *  { timeUnit: \"minute\", count: 1 },\r\n\t *  { timeUnit: \"minute\", count: 5 },\r\n\t *  { timeUnit: \"minute\", count: 10 },\r\n\t *  { timeUnit: \"minute\", count: 30 },\r\n\t *  { timeUnit: \"hour\", count: 1 },\r\n\t *  { timeUnit: \"hour\", count: 3 },\r\n\t *  { timeUnit: \"hour\", count: 6 },\r\n\t *  { timeUnit: \"hour\", count: 12 },\r\n\t *  { timeUnit: \"day\", count: 1 },\r\n\t *  { timeUnit: \"day\", count: 2 },\r\n\t *  { timeUnit: \"day\", count: 3 },\r\n\t *  { timeUnit: \"day\", count: 4 },\r\n\t *  { timeUnit: \"day\", count: 5 },\r\n\t *  { timeUnit: \"week\", count: 1 },\r\n\t *  { timeUnit: \"month\", count: 1 },\r\n\t *  { timeUnit: \"month\", count: 2 },\r\n\t *  { timeUnit: \"month\", count: 3 },\r\n\t *  { timeUnit: \"month\", count: 6 },\r\n\t *  { timeUnit: \"year\", count: 1 },\r\n\t *  { timeUnit: \"year\", count: 2 },\r\n\t *  { timeUnit: \"year\", count: 5 },\r\n\t *  { timeUnit: \"year\", count: 10 },\r\n\t *  { timeUnit: \"year\", count: 50 },\r\n\t *  { timeUnit: \"year\", count: 100 }\r\n\t * ]\r\n\t * ```\r\n\t */\r\n\tpublic gridIntervals: List<ITimeInterval> = new List<ITimeInterval>();\r\n\r\n\t/**\r\n\t * A collection of date formats to use when formatting different time units\r\n\t * on Date/time axis.\r\n\t *\r\n\t * Actual defaults will depend on the language locale set for the chart.\r\n\t *\r\n\t * To override format for a specific time unit, say days, you need to set\r\n\t * the appropriate key to a format string. E.g.:\r\n\t *\r\n\t * ```TypeScript\r\n\t * axis.dateFormats.setKey(\"day\", \"MMMM d, yyyy\");\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * axis.dateFormats.setKey(\"day\", \"MMMM d, yyyy\");\r\n\t * ```\r\n\t * ```JSON\r\n\t * \"xAxes\": [{\r\n\t *   \"type\": \"DateAxis\",\r\n\t *   \"dateFormats\": {\r\n\t *     \"day\": \"MMMM d, yyyy\"\r\n\t *   }\r\n\t * }]\r\n\t * ```\r\n\t *\r\n\t * @see {@link DateFormatter}\r\n\t */\r\n\tpublic dateFormats: Dictionary<TimeUnit, string> = new Dictionary<TimeUnit, string>();\r\n\r\n\t/**\r\n\t * These formats are applied to labels that are first in a larger unit.\r\n\t *\r\n\t * For example, if we have a DateAxis with days on it, the first day of month\r\n\t * indicates a break in month - a start of the bigger period.\r\n\t *\r\n\t * For those labels, `periodChangeDateFormats` are applied instead of\r\n\t * `dateFormats`.\r\n\t *\r\n\t * This allows us implement convenient structures, like instead of:\r\n\t *\r\n\t * `Jan 1 - Jan 2 - Jan 3 - ...`\r\n\t *\r\n\t * We can have:\r\n\t *\r\n\t * `Jan - 1 - 2 - 3 - ...`\r\n\t *\r\n\t * This can be disabled by setting `markUnitChange = false`.\r\n\t */\r\n\tpublic periodChangeDateFormats: Dictionary<TimeUnit, string> = new Dictionary<TimeUnit, string>();\r\n\r\n\t/**\r\n\t * At which intervals grid elements are displayed.\r\n\t */\r\n\tprotected _gridInterval: ITimeInterval;\r\n\r\n\t/**\r\n\t * [_intervalDuration description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _intervalDuration: number;\r\n\r\n\t/**\r\n\t * [_gridDate description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _gridDate: Date;\r\n\r\n\t/**\r\n\t * [_nextGridUnit description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _nextGridUnit: TimeUnit;\r\n\r\n\t/**\r\n\t * User-defined granularity of data.\r\n\t */\r\n\tprotected _baseInterval: ITimeInterval;\r\n\r\n\t/**\r\n\t * Actual interval (granularity) derived from the actual data.\r\n\t */\r\n\tprotected _baseIntervalReal: ITimeInterval = { timeUnit: \"day\", count: 1 };\r\n\r\n\t/**\r\n\t */\r\n\tprotected _prevSeriesTime: number;\r\n\r\n\t/**\r\n\t * [_minDifference description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _minDifference: { [index: string]: number } = {};\r\n\r\n\t/**\r\n\t * A function which applies fills to axis cells.\r\n\t *\r\n\t * Default function fills every second fill. You can set this to a function\r\n\t * that follows some other logic.\r\n\t *\r\n\t * Function should accept a [[DateAxisDataItem]] and modify its `axisFill`\r\n\t * property accordingly.\r\n\t */\r\n\tpublic fillRule(dataItem: this[\"_dataItem\"]): void {\r\n\t\tlet value = dataItem.value;\r\n\t\tlet axis = dataItem.component;\r\n\t\tlet gridInterval = axis._gridInterval;\r\n\t\tlet gridDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\r\n\r\n\t\tif (Math.round((value - axis.min) / gridDuration) / 2 == Math.round(Math.round((value - axis.min) / gridDuration) / 2)) {\r\n\t\t\tdataItem.axisFill.__disabled = true;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdataItem.axisFill.__disabled = false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"DateAxis\";\r\n\r\n\t\tthis.setPropertyValue(\"markUnitChange\", true);\r\n\t\tthis.snapTooltip = true;\r\n\r\n\t\t// Translatable defaults are applied in `applyInternalDefaults()`\r\n\t\t// ...\r\n\r\n\t\t// Define default intervals\r\n\t\tthis.gridIntervals.pushAll([\r\n\t\t\t{ timeUnit: \"millisecond\", count: 1 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 5 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 10 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 50 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 100 },\r\n\t\t\t{ timeUnit: \"millisecond\", count: 500 },\r\n\t\t\t{ timeUnit: \"second\", count: 1 },\r\n\t\t\t{ timeUnit: \"second\", count: 5 },\r\n\t\t\t{ timeUnit: \"second\", count: 10 },\r\n\t\t\t{ timeUnit: \"second\", count: 30 },\r\n\t\t\t{ timeUnit: \"minute\", count: 1 },\r\n\t\t\t{ timeUnit: \"minute\", count: 5 },\r\n\t\t\t{ timeUnit: \"minute\", count: 10 },\r\n\t\t\t{ timeUnit: \"minute\", count: 15 },\r\n\t\t\t{ timeUnit: \"minute\", count: 30 },\r\n\t\t\t{ timeUnit: \"hour\", count: 1 },\r\n\t\t\t{ timeUnit: \"hour\", count: 3 },\r\n\t\t\t{ timeUnit: \"hour\", count: 6 },\r\n\t\t\t{ timeUnit: \"hour\", count: 12 },\r\n\t\t\t{ timeUnit: \"day\", count: 1 },\r\n\t\t\t{ timeUnit: \"day\", count: 2 },\r\n\t\t\t{ timeUnit: \"day\", count: 3 },\r\n\t\t\t{ timeUnit: \"day\", count: 4 },\r\n\t\t\t{ timeUnit: \"day\", count: 5 },\r\n\t\t\t{ timeUnit: \"week\", count: 1 },\r\n\t\t\t{ timeUnit: \"month\", count: 1 },\r\n\t\t\t{ timeUnit: \"month\", count: 2 },\r\n\t\t\t{ timeUnit: \"month\", count: 3 },\r\n\t\t\t{ timeUnit: \"month\", count: 6 },\r\n\t\t\t{ timeUnit: \"year\", count: 1 },\r\n\t\t\t{ timeUnit: \"year\", count: 2 },\r\n\t\t\t{ timeUnit: \"year\", count: 5 },\r\n\t\t\t{ timeUnit: \"year\", count: 10 },\r\n\t\t\t{ timeUnit: \"year\", count: 50 },\r\n\t\t\t{ timeUnit: \"year\", count: 100 },\r\n\t\t\t{ timeUnit: \"year\", count: 200 },\r\n\t\t\t{ timeUnit: \"year\", count: 500 },\r\n\t\t\t{ timeUnit: \"year\", count: 1000 },\r\n\t\t\t{ timeUnit: \"year\", count: 2000 },\r\n\t\t\t{ timeUnit: \"year\", count: 5000 },\r\n\t\t\t{ timeUnit: \"year\", count: 10000 },\r\n\t\t\t{ timeUnit: \"year\", count: 100000 }\r\n\t\t]);\r\n\r\n\t\t// Set field name\r\n\t\tthis.axisFieldName = \"date\";\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets defaults that instantiate some objects that rely on parent, so they\r\n\t * cannot be set in constructor.\r\n\t */\r\n\tprotected applyInternalDefaults(): void {\r\n\t\tsuper.applyInternalDefaults();\r\n\r\n\t\t// Set default date formats\r\n\t\tif (!this.dateFormats.hasKey(\"millisecond\")) {\r\n\t\t\tthis.dateFormats.setKey(\"millisecond\", this.language.translate(\"_date_millisecond\"));\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"second\")) {\r\n\t\t\tthis.dateFormats.setKey(\"second\", this.language.translate(\"_date_second\"));\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"minute\")) {\r\n\t\t\tthis.dateFormats.setKey(\"minute\", this.language.translate(\"_date_minute\"));\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"hour\")) {\r\n\t\t\tthis.dateFormats.setKey(\"hour\", this.language.translate(\"_date_hour\"));\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"day\")) {\r\n\t\t\tthis.dateFormats.setKey(\"day\", this.language.translate(\"_date_day\"));\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"week\")) {\r\n\t\t\tthis.dateFormats.setKey(\"week\", this.language.translate(\"_date_day\"));\t // not a mistake\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"month\")) {\r\n\t\t\tthis.dateFormats.setKey(\"month\", this.language.translate(\"_date_month\"));\r\n\t\t}\r\n\t\tif (!this.dateFormats.hasKey(\"year\")) {\r\n\t\t\tthis.dateFormats.setKey(\"year\", this.language.translate(\"_date_year\"));\r\n\t\t}\r\n\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"millisecond\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"millisecond\", this.language.translate(\"_date_millisecond\"));\r\n\t\t}\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"second\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"second\", this.language.translate(\"_date_second\"));\r\n\t\t}\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"minute\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"minute\", this.language.translate(\"_date_minute\"));\r\n\t\t}\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"hour\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"hour\", this.language.translate(\"_date_hour\"));\r\n\t\t}\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"day\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"day\", this.language.translate(\"_date_day\"));\r\n\t\t}\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"week\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"week\", this.language.translate(\"_date_day\"));\r\n\t\t}\r\n\t\tif (!this.periodChangeDateFormats.hasKey(\"month\")) {\r\n\t\t\tthis.periodChangeDateFormats.setKey(\"month\", this.language.translate(\"_date_month\") + \" \" + this.language.translate(\"_date_year\"));\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty [[DataItem]] of the type appropriate for this object.\r\n\t *\r\n\t * @see {@link DataItem}\r\n\t * @return Data Item\r\n\t */\r\n\tprotected createDataItem(): this[\"_dataItem\"] {\r\n\t\treturn new DateAxisDataItem();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty [[AxisBreak]] of the appropriate type.\r\n\t *\r\n\t * @return Axis break\r\n\t */\r\n\tprotected createAxisBreak(): this[\"_axisBreak\"] {\r\n\t\treturn new DateAxisBreak();\r\n\t}\r\n\r\n\t/**\r\n\t * Validates Axis' data items.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validateDataItems(): void {\r\n\t\t// allows to keep selection of the same size\r\n\t\tlet start: number = this.start;\r\n\t\tlet end: number = this.end;\r\n\t\tlet periodCount: number = (this.max - this.min) / this.baseDuration;\r\n\r\n\t\tsuper.validateDataItems();\r\n\r\n\t\tthis.maxZoomFactor = (this.max - this.min) / this.baseDuration;\r\n\r\n\t\tthis._deltaMinMax = this.baseDuration / 2;\r\n\r\n\t\t// allows to keep selection of the same size\r\n\t\tlet newPeriodCount: number = (this.max - this.min) / this.baseDuration;\r\n\t\tstart = start + (end - start) * (1 - periodCount / newPeriodCount);\r\n\t\tthis.zoom({ start: start, end: end }, false, true); // added instantlyto solve zoomout problem when we have axes gaps. @todo: check how this affects maxZoomFactor\r\n\t}\r\n\r\n\t/**\r\n\t * Handles process after zoom.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Does nothing?\r\n\t */\r\n\tpublic handleSelectionExtremesChange(): void {\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Calculates all positions, related to axis as per current zoom.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic calculateZoom(): void {\r\n\t\tsuper.calculateZoom();\r\n\r\n\t\tlet gridInterval: ITimeInterval = this.chooseInterval(0, this.adjustDifference(this._minZoomed, this._maxZoomed), this._gridCount);\r\n\r\n\t\tif ($time.getDuration(gridInterval.timeUnit, gridInterval.count) < this.baseDuration) {\r\n\t\t\tgridInterval = { ...this.baseInterval };\r\n\t\t}\r\n\r\n\t\tthis._gridInterval = gridInterval;\r\n\r\n\t\tthis._gridDate = $time.round(new Date(this.min), gridInterval.timeUnit, gridInterval.count, this.getFirstWeekDay(), this.dateFormatter.utc);\r\n\t\tthis._nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\r\n\r\n\t\t// the following is needed to avoid grid flickering while scrolling\r\n\t\tthis._intervalDuration = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\r\n\t\tlet count: number = Math.ceil(this._difference / this._intervalDuration);\r\n\t\tcount = Math.max(-5, Math.floor(this.start * count) - 3); // some extra is needed\r\n\r\n\t\t$time.add(this._gridDate, gridInterval.timeUnit, count * gridInterval.count, this.dateFormatter.utc);\r\n\r\n\t\t// tell series start/end\r\n\t\t$iter.each(this.series.iterator(), (series) => {\r\n\t\t\tif (series.baseAxis == this) {\r\n\t\t\t\tlet field = <keyof XYSeriesDataItem>series.getAxisField(this);\r\n\r\n\t\t\t\tlet minZoomed = $time.round(new Date(this._minZoomed), this.baseInterval.timeUnit, this.baseInterval.count).getTime();\r\n\t\t\t\tlet minZoomedStr = minZoomed.toString();\r\n\t\t\t\tlet startDataItem = series.dataItemsByAxis.getKey(this.uid).getKey(minZoomedStr);\r\n\t\t\t\tlet startIndex: number = 0;\r\n\t\t\t\tif (this.start != 0) {\r\n\t\t\t\t\tif (startDataItem) {\r\n\t\t\t\t\t\tstartDataItem = this.findFirst(startDataItem, minZoomed, field);\r\n\t\t\t\t\t\tstartIndex = startDataItem.index;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tstartIndex = series.dataItems.findClosestIndex(this._minZoomed, (x) => <number>x[field], \"left\");\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// 1 millisecond is removed so that if only first item is selected, it would not count in the second.\r\n\t\t\t\tlet baseInterval = this.baseInterval;\r\n\t\t\t\tlet maxZoomed = $time.add($time.round(new Date(this._maxZoomed), baseInterval.timeUnit, baseInterval.count, this.getFirstWeekDay(), this.dateFormatter.utc), baseInterval.timeUnit, baseInterval.count, this.dateFormatter.utc).getTime();\r\n\r\n\t\t\t\tlet maxZoomedStr = maxZoomed.toString();\r\n\t\t\t\tlet endDataItem = series.dataItemsByAxis.getKey(this.uid).getKey(maxZoomedStr);\r\n\t\t\t\tlet endIndex: number = series.dataItems.length;\r\n\t\t\t\tif (this.end != 1) {\r\n\t\t\t\t\tif (endDataItem) {\r\n\t\t\t\t\t\tendIndex = endDataItem.index;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tmaxZoomed -= 1;\r\n\t\t\t\t\t\tendIndex = series.dataItems.findClosestIndex(maxZoomed, (x) => <number>x[field], \"right\") + 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tseries.startIndex = startIndex;\r\n\t\t\t\tseries.endIndex = endIndex;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tprotected findFirst(dataItem: XYSeriesDataItem, time: number, key: string): XYSeriesDataItem {\r\n\t\tlet index = dataItem.index;\r\n\t\tif (index > 0) {\r\n\t\t\tlet series = dataItem.component;\r\n\t\t\tlet previousDataItem = series.dataItems.getIndex(index - 1);\r\n\t\t\tlet previousDate = (<any>previousDataItem)[key];\r\n\t\t\tif (!previousDate || previousDate.getTime() < time) {\r\n\t\t\t\treturn dataItem;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn this.findFirst(previousDataItem, time, key);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn dataItem;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * (Re)validates data.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validateData(): void {\r\n\t\tsuper.validateData();\r\n\t\tif (!$type.isNumber(this.baseInterval.count)) {\r\n\t\t\tthis.baseInterval.count = 1;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic get minDifference(): number {\r\n\t\tlet minDifference = Number.MAX_VALUE;\r\n\r\n\t\tthis.series.each((series) => {\r\n\t\t\tif (minDifference > this._minDifference[series.uid]) {\r\n\t\t\t\tminDifference = this._minDifference[series.uid];\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\tif (minDifference == Number.MAX_VALUE || minDifference == 0) {\r\n\t\t\tminDifference = $time.getDuration(\"day\");\r\n\t\t}\r\n\r\n\t\treturn minDifference;\r\n\t}\r\n\r\n\t/**\r\n\t * [dataChangeUpdate description]\r\n\t *\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t */\r\n\tpublic seriesDataChangeUpdate(series: XYSeries): void {\r\n\t\tthis._minDifference[series.uid] = Number.MAX_VALUE;\r\n\t}\r\n\r\n\t/**\r\n\t * [postProcessSeriesDataItems description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t */\r\n\tpublic postProcessSeriesDataItems(): void {\r\n\t\tthis.series.each((series) => {\r\n\t\t\tif (JSON.stringify(series._baseInterval[this.uid]) != JSON.stringify(this.baseInterval)) {\r\n\t\t\t\tseries.dataItems.each((dataItem) => {\r\n\t\t\t\t\tthis.postProcessSeriesDataItem(dataItem);\r\n\t\t\t\t});\r\n\t\t\t\tseries._baseInterval[this.uid] = this.baseInterval;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis.addEmptyUnitsBreaks();\r\n\t}\r\n\r\n\t/**\r\n\t * [postProcessSeriesDataItem description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param dataItem Data item\r\n\t */\r\n\tpublic postProcessSeriesDataItem(dataItem: XYSeriesDataItem): void {\r\n\t\t// we need to do this for all series data items not only added recently, as baseInterval might change\r\n\t\tlet baseInterval: ITimeInterval = this.baseInterval;\r\n\r\n\t\tlet series: XYSeries = dataItem.component;\r\n\t\tlet dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);\r\n\r\n\t\t$object.each(dataItem.dates, (key) => {\r\n\t\t\tlet date: Date = dataItem.getDate(key);\r\n\t\t\tlet time = date.getTime();\r\n\r\n\t\t\tlet startDate: Date = $time.round(new Date(time), baseInterval.timeUnit, baseInterval.count, this.getFirstWeekDay(), this.dateFormatter.utc);\r\n\t\t\tlet startTime = startDate.getTime();\r\n\t\t\tlet endDate: Date = $time.add(new Date(startTime), baseInterval.timeUnit, baseInterval.count, this.dateFormatter.utc);\r\n\r\n\t\t\tdataItem.setCalculatedValue(key, startTime, \"open\");\r\n\t\t\tdataItem.setCalculatedValue(key, endDate.getTime(), \"close\");\r\n\r\n\t\t\tdataItemsByAxis.setKey(startTime.toString(), dataItem);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Collapses empty stretches of date/time scale by creating [[AxisBreak]]\r\n\t * elements for them.\r\n\t *\r\n\t * Can be used to automatically remove strethes without data, like weekends.\r\n\t *\r\n\t * No, need to call this manually. It will automatically be done if\r\n\t * `skipEmptyPeriods = true`.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected addEmptyUnitsBreaks(): void {\r\n\r\n\t\tif (this.skipEmptyPeriods && $type.isNumber(this.min) && $type.isNumber(this.max)) {\r\n\t\t\tlet timeUnit: TimeUnit = this.baseInterval.timeUnit;\r\n\t\t\tlet count: number = this.baseInterval.count;\r\n\r\n\t\t\tthis.axisBreaks.clear(); // TODO: what about breaks added by user?\r\n\r\n\t\t\tlet date: Date = $time.round(new Date(this.min), timeUnit, count, this.getFirstWeekDay(), this.dateFormatter.utc);\r\n\t\t\tlet axisBreak: DateAxisBreak;\r\n\r\n\t\t\twhile (date.getTime() < this.max - this.baseDuration) {\r\n\t\t\t\t$time.add(date, timeUnit, count, this.dateFormatter.utc);\r\n\r\n\t\t\t\tlet startTime: number = date.getTime();\r\n\t\t\t\tlet startTimeStr: string = startTime.toString();\r\n\r\n\t\t\t\tlet hasData = $iter.contains(this.series.iterator(), (series) => {\r\n\t\t\t\t\treturn !!series.dataItemsByAxis.getKey(this.uid).getKey(startTimeStr);\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// open break if not yet opened\r\n\t\t\t\tif (!hasData) {\r\n\t\t\t\t\tif (!axisBreak) {\r\n\t\t\t\t\t\taxisBreak = <DateAxisBreak>this.axisBreaks.create();\r\n\t\t\t\t\t\taxisBreak.startDate = new Date(startTime);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// close if already opened\r\n\t\t\t\t\tif (axisBreak) {\r\n\t\t\t\t\t\t// close at end time minus one millisecond\r\n\t\t\t\t\t\taxisBreak.endDate = new Date(startTime - 1);\r\n\t\t\t\t\t\taxisBreak = undefined;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Updates positioning of Axis breaks after something changes.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic fixAxisBreaks(): void {\r\n\t\tsuper.fixAxisBreaks();\r\n\r\n\t\tlet axisBreaks = this.axisBreaks;\r\n\t\tif (axisBreaks.length > 0) {\r\n\t\t\t// process breaks\r\n\t\t\taxisBreaks.each((axisBreak) => {\r\n\t\t\t\tlet breakGridCount: number = Math.ceil(this._gridCount * (Math.min(this.end, axisBreak.endPosition) - Math.max(this.start, axisBreak.startPosition)) / (this.end - this.start));\r\n\t\t\t\taxisBreak.gridInterval = this.chooseInterval(0, axisBreak.adjustedEndValue - axisBreak.adjustedStartValue, breakGridCount);\r\n\t\t\t\tlet gridDate = $time.round(new Date(axisBreak.adjustedStartValue), axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, this.getFirstWeekDay(), this.dateFormatter.utc);\r\n\t\t\t\tif (gridDate.getTime() > axisBreak.startDate.getTime()) {\r\n\t\t\t\t\t$time.add(gridDate, axisBreak.gridInterval.timeUnit, axisBreak.gridInterval.count, this.dateFormatter.utc);\r\n\t\t\t\t}\r\n\r\n\t\t\t\taxisBreak.gridDate = gridDate;\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected getFirstWeekDay(): number {\r\n\t\tif (this.dateFormatter) {\r\n\t\t\treturn this.dateFormatter.firstDayOfWeek;\r\n\t\t}\r\n\r\n\t\treturn 1;\r\n\t}\r\n\r\n\t/**\r\n\t * [getGridDate description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param date           [description]\r\n\t * @param intervalCount  [description]\r\n\t * @return [description]\r\n\t */\r\n\tpublic getGridDate(date: Date, intervalCount: number): Date {\r\n\t\tlet timeUnit: TimeUnit = this._gridInterval.timeUnit;\r\n\t\tlet realIntervalCount: number = this._gridInterval.count;\r\n\t\t// round date\r\n\t\t$time.round(date, timeUnit, 1, this.getFirstWeekDay(), this.dateFormatter.utc);\r\n\r\n\t\tlet prevTimestamp: number = date.getTime();\r\n\r\n\t\tlet newDate: Date = $time.copy(date);\r\n\t\t// modify date by adding intervalcount\r\n\t\tlet timestamp: number = $time.add(newDate, timeUnit, intervalCount, this.dateFormatter.utc).getTime();\r\n\r\n\t\t// if it's axis break, get first rounded date which is not in a break\r\n\t\tlet axisBreak: DateAxisBreak = <DateAxisBreak>this.isInBreak(timestamp);\r\n\t\tif (axisBreak) {\r\n\t\t\tnewDate = new Date(axisBreak.endDate.getTime());\r\n\t\t\t$time.round(newDate, timeUnit, realIntervalCount, this.getFirstWeekDay(), this.dateFormatter.utc);\r\n\t\t\tif (newDate.getTime() < axisBreak.endDate.getTime()) {\r\n\t\t\t\t$time.add(newDate, timeUnit, realIntervalCount, this.dateFormatter.utc);\r\n\t\t\t}\r\n\t\t\ttimestamp = newDate.getTime();\r\n\t\t}\r\n\r\n\t\t// get duration between grid lines with break duration removed\r\n\t\tlet durationBreaksRemoved: number = this.adjustDifference(prevTimestamp, timestamp);\r\n\t\t// calculate how many time units fit to this duration\r\n\t\tlet countBreaksRemoved: number = Math.round(durationBreaksRemoved / $time.getDuration(timeUnit));\r\n\r\n\t\t// if less units fit, add one and repeat\r\n\t\tif (countBreaksRemoved < realIntervalCount) {\r\n\t\t\treturn this.getGridDate(date, intervalCount + realIntervalCount);\r\n\t\t}\r\n\r\n\t\treturn newDate;\r\n\t}\r\n\r\n\t/**\r\n\t * [getBreaklessDate description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param axisBreak  [description]\r\n\t * @param timeUnit   [description]\r\n\t * @param count      [description]\r\n\t * @return [description]\r\n\t */\r\n\tpublic getBreaklessDate(axisBreak: DateAxisBreak, timeUnit: TimeUnit, count: number): Date {\r\n\t\tlet date = new Date(axisBreak.endValue);\r\n\t\t$time.round(date, timeUnit, count, this.getFirstWeekDay(), this.dateFormatter.utc);\r\n\t\t$time.add(date, timeUnit, count, this.dateFormatter.utc);\r\n\r\n\t\tlet timestamp = date.getTime();\r\n\r\n\t\taxisBreak = <DateAxisBreak>this.isInBreak(timestamp);\r\n\t\tif (axisBreak) {\r\n\t\t\treturn this.getBreaklessDate(axisBreak, timeUnit, count);\r\n\t\t}\r\n\t\treturn date;\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)validates all Axis elements.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t */\r\n\tpublic validateAxisElements(): void {\r\n\t\tif ($type.isNumber(this.max) && $type.isNumber(this.min)) {\r\n\r\n\t\t\tthis.calculateZoom();\r\n\r\n\t\t\t// first regular items\r\n\t\t\tlet timestamp = this._gridDate.getTime();\r\n\t\t\tlet timeUnit = this._gridInterval.timeUnit;\r\n\t\t\tlet intervalCount = this._gridInterval.count;\r\n\t\t\tlet prevGridDate = $time.copy(this._gridDate);\r\n\r\n\t\t\tlet dataItemsIterator = this._dataItemsIterator;\r\n\t\t\tthis.resetIterators();\r\n\r\n\t\t\twhile (timestamp <= this._maxZoomed) {\r\n\t\t\t\tlet date = this.getGridDate($time.copy(prevGridDate), intervalCount);\r\n\r\n\t\t\t\ttimestamp = date.getTime();\r\n\r\n\t\t\t\tlet endDate = $time.copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length\r\n\t\t\t\tendDate = $time.add(endDate, timeUnit, intervalCount, this.dateFormatter.utc);\r\n\r\n\t\t\t\tlet format = this.dateFormats.getKey(timeUnit);\r\n\r\n\t\t\t\tif (this.markUnitChange && prevGridDate) {\r\n\t\t\t\t\tif ($time.checkChange(date, prevGridDate, this._nextGridUnit, this.dateFormatter.utc)) {\r\n\t\t\t\t\t\tif (timeUnit !== \"year\") {\r\n\t\t\t\t\t\t\tformat = this.periodChangeDateFormats.getKey(timeUnit);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet text = this.dateFormatter.format(date, format);\r\n\r\n\t\t\t\tlet dataItem = dataItemsIterator.find((x) => x.text === text);\r\n\t\t\t\tif (dataItem.__disabled) {\r\n\t\t\t\t\tdataItem.__disabled = false;\r\n\t\t\t\t}\r\n\t\t\t\tthis.appendDataItem(dataItem);\r\n\r\n\t\t\t\tdataItem.axisBreak = undefined;\r\n\t\t\t\tdataItem.date = date;\r\n\t\t\t\tdataItem.endDate = endDate;\r\n\r\n\t\t\t\tdataItem.text = text;\r\n\r\n\t\t\t\tprevGridDate = date;\r\n\r\n\t\t\t\tthis.validateDataElement(dataItem);\r\n\t\t\t}\r\n\r\n\t\t\t// breaks later\r\n\t\t\tlet renderer: AxisRenderer = this.renderer;\r\n\r\n\t\t\t$iter.each(this.axisBreaks.iterator(), (axisBreak) => {\r\n\t\t\t\tif (axisBreak.breakSize > 0) {\r\n\t\t\t\t\tlet timeUnit: TimeUnit = axisBreak.gridInterval.timeUnit;\r\n\t\t\t\t\tlet intervalCount: number = axisBreak.gridInterval.count;\r\n\r\n\t\t\t\t\t// only add grid if gap is bigger then minGridDistance\r\n\t\t\t\t\tif ($math.getDistance(axisBreak.startPoint, axisBreak.endPoint) > renderer.minGridDistance * 4) {\r\n\t\t\t\t\t\tlet timestamp: number = axisBreak.gridDate.getTime();\r\n\r\n\t\t\t\t\t\tlet prevGridDate;\r\n\t\t\t\t\t\tlet count: number = 0;\r\n\t\t\t\t\t\twhile (timestamp <= axisBreak.adjustedMax) {\r\n\t\t\t\t\t\t\tlet date: Date = $time.copy(axisBreak.gridDate);\r\n\t\t\t\t\t\t\ttimestamp = $time.add(date, timeUnit, intervalCount * count, this.dateFormatter.utc).getTime();\r\n\t\t\t\t\t\t\tcount++;\r\n\t\t\t\t\t\t\tif (timestamp > axisBreak.adjustedStartValue && timestamp < axisBreak.adjustedEndValue) {\r\n\t\t\t\t\t\t\t\tlet endDate = $time.copy(date); // you might think it's easier to add intervalduration to timestamp, however it won't work for months or years which are not of the same length\r\n\t\t\t\t\t\t\t\tendDate = $time.add(endDate, timeUnit, intervalCount, this.dateFormatter.utc);\r\n\r\n\t\t\t\t\t\t\t\tlet format: string = this.dateFormats.getKey(timeUnit);\r\n\r\n\t\t\t\t\t\t\t\tif (this.markUnitChange && prevGridDate) {\r\n\t\t\t\t\t\t\t\t\tif ($time.checkChange(date, prevGridDate, this._nextGridUnit, this.dateFormatter.utc)) {\r\n\t\t\t\t\t\t\t\t\t\tif (timeUnit !== \"year\") {\r\n\t\t\t\t\t\t\t\t\t\t\tformat = this.periodChangeDateFormats.getKey(timeUnit);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tlet text: string = this.dateFormatter.format(date, format);\r\n\r\n\t\t\t\t\t\t\t\tlet dataItem: this[\"_dataItem\"] = dataItemsIterator.find((x) => x.text === text);\r\n\t\t\t\t\t\t\t\tif (dataItem.__disabled) {\r\n\t\t\t\t\t\t\t\t\tdataItem.__disabled = false;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t//this.processDataItem(dataItem);\r\n\t\t\t\t\t\t\t\tthis.appendDataItem(dataItem);\r\n\t\t\t\t\t\t\t\tdataItem.axisBreak = axisBreak;\r\n\t\t\t\t\t\t\t\taxisBreak.dataItems.moveValue(dataItem);\r\n\r\n\t\t\t\t\t\t\t\tdataItem.date = date;\r\n\t\t\t\t\t\t\t\tdataItem.endDate = endDate;\r\n\t\t\t\t\t\t\t\tdataItem.text = text;\r\n\t\t\t\t\t\t\t\tprevGridDate = date;\r\n\t\t\t\t\t\t\t\tthis.validateDataElement(dataItem);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Validates Axis data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param dataItem Data item\r\n\t */\r\n\tpublic validateDataElement(dataItem: this[\"_dataItem\"]): void {\r\n\t\t//super.validateDataElement(dataItem);\r\n\t\tif ($type.isNumber(this.max) && $type.isNumber(this.min)) {\r\n\t\t\tlet renderer: AxisRenderer = this.renderer;\r\n\r\n\t\t\tlet timestamp = dataItem.value;\r\n\t\t\tlet endTimestamp = dataItem.endValue;\r\n\r\n\t\t\tif (!$type.isNumber(endTimestamp)) {\r\n\t\t\t\tendTimestamp = timestamp;\r\n\t\t\t}\r\n\r\n\t\t\tlet position: number = this.valueToPosition(timestamp);\r\n\t\t\tlet endPosition: number = this.valueToPosition(endTimestamp);\r\n\t\t\tlet fillEndPosition = endPosition;\r\n\r\n\t\t\tif (!dataItem.isRange && this._gridInterval.count > this.baseInterval.count) {\r\n\t\t\t\tendPosition = position + (endPosition - position) / (this._gridInterval.count / this.baseInterval.count);\r\n\t\t\t}\r\n\r\n\t\t\tdataItem.position = position;\r\n\r\n\t\t\tlet tick: AxisTick = dataItem.tick;\r\n\t\t\tif (tick && !tick.disabled) {\r\n\t\t\t\trenderer.updateTickElement(tick, position, endPosition);\r\n\t\t\t}\r\n\r\n\t\t\tlet grid: Grid = dataItem.grid;\r\n\t\t\tif (grid && !grid.disabled) {\r\n\t\t\t\trenderer.updateGridElement(grid, position, endPosition);\r\n\t\t\t}\r\n\r\n\t\t\tlet fill: AxisFill = dataItem.axisFill;\r\n\t\t\tif (fill && !fill.disabled) {\r\n\t\t\t\trenderer.updateFillElement(fill, position, fillEndPosition);\r\n\t\t\t\tif (!dataItem.isRange) {\r\n\t\t\t\t\tthis.fillRule(dataItem);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlet mask: AxisFill = dataItem.mask;\r\n\t\t\tif (mask) {\r\n\t\t\t\trenderer.updateFillElement(mask, position, endPosition);\r\n\t\t\t}\r\n\r\n\t\t\tlet label: AxisLabel = dataItem.label;\r\n\t\t\tif (label && !label.disabled) {\r\n\t\t\t\tlet location = label.location;\r\n\r\n\r\n\r\n\t\t\t\tif (location == 0) {\r\n\t\t\t\t\tif (this._gridInterval.count == 1 && this._gridInterval.timeUnit != \"week\" && !dataItem.isRange) {\r\n\t\t\t\t\t\tlocation = 0.5;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tlocation = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\trenderer.updateLabelElement(label, position, endPosition, location);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * A duration in milliseconds of the `baseInterval`.\r\n\t *\r\n\t * @return Duration (ms)\r\n\t */\r\n\tpublic get baseDuration(): number {\r\n\t\treturn $time.getDuration(this.baseInterval.timeUnit, this.baseInterval.count);\r\n\t}\r\n\r\n\t/**\r\n\t * Adjusts min/max values.\r\n\t *\r\n\t * @ignore Exclude from docs.\r\n\t * @todo Description (review)\r\n\t * @param min  Min timestamp\r\n\t * @param max  Max timestamp\r\n\t * @return Adjusted min/max step\r\n\t */\r\n\tpublic adjustMinMax(min: number, max: number): IMinMaxStep {\r\n\t\treturn { min: min, max: max, step: this.baseDuration };\r\n\t}\r\n\r\n\t/**\r\n\t * Adjusts the minimum timestamp as per cell start location.\r\n\t *\r\n\t * @param value  Value\r\n\t * @return Adjusted value\r\n\t */\r\n\tprotected fixMin(value: number) {\r\n\r\n\t\t// like this because months are not equal\r\n\t\tlet startTime = $time.round(new Date(value), this.baseInterval.timeUnit, this.baseInterval.count, this.getFirstWeekDay(), this.dateFormatter.utc).getTime();\r\n\t\tlet endTime = $time.add(new Date(startTime), this.baseInterval.timeUnit, this.baseInterval.count, this.dateFormatter.utc).getTime();\r\n\r\n\t\treturn startTime + (endTime - startTime) * this.startLocation;\r\n\t}\r\n\r\n\t/**\r\n\t * Adjusts the maximum timestamp as per cell start location.\r\n\t *\r\n\t * @param value  Value\r\n\t * @return Adjusted value\r\n\t */\r\n\tprotected fixMax(value: number) {\r\n\t\t// like this because months are not equal\r\n\t\tlet startTime = $time.round(new Date(value), this.baseInterval.timeUnit, this.baseInterval.count, this.getFirstWeekDay(), this.dateFormatter.utc).getTime();\r\n\t\tlet endTime = $time.add(new Date(startTime), this.baseInterval.timeUnit, this.baseInterval.count, this.dateFormatter.utc).getTime();\r\n\r\n\t\treturn startTime + (endTime - startTime) * this.endLocation;\r\n\t}\r\n\r\n\t/**\r\n\t * [chooseInterval description]\r\n\t *\r\n\t * @ignore Exclude from docs.\r\n\t * @todo Description\r\n\t * @param index      [description]\r\n\t * @param duration   [description]\r\n\t * @param gridCount  [description]\r\n\t * @return [description]\r\n\t */\r\n\tpublic chooseInterval(index: number, duration: number, gridCount: number): ITimeInterval {\r\n\t\tlet gridIntervals: List<ITimeInterval> = this.gridIntervals;\r\n\r\n\t\tlet gridInterval: ITimeInterval = gridIntervals.getIndex(index);\r\n\r\n\t\tlet intervalDuration: number = $time.getDuration(gridInterval.timeUnit, gridInterval.count);\r\n\r\n\t\tlet lastIndex: number = gridIntervals.length - 1;\r\n\t\tif (index >= lastIndex) {\r\n\t\t\treturn { ...gridIntervals.getIndex(lastIndex) };\r\n\t\t}\r\n\r\n\t\tlet count: number = Math.ceil(duration / intervalDuration);\r\n\r\n\t\tif (duration < intervalDuration && index > 0) {\r\n\t\t\treturn { ...gridIntervals.getIndex(index - 1) };\r\n\t\t}\r\n\r\n\t\tif (count <= gridCount) {\r\n\t\t\treturn { ...gridIntervals.getIndex(index) };\r\n\t\t} else {\r\n\t\t\tif (index + 1 < gridIntervals.length) {\r\n\t\t\t\treturn this.chooseInterval(index + 1, duration, gridCount);\r\n\t\t\t} else {\r\n\t\t\t\treturn { ...gridIntervals.getIndex(index) };\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Formats the value according to axis' own [[DateFormatter]].\r\n\t *\r\n\t * @param value  Source value\r\n\t * @return Formatted value\r\n\t */\r\n\tpublic formatLabel(value: number): string {\r\n\t\treturn this.dateFormatter.format(value);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a Date to an asbolute pixel position within Axis.\r\n\t *\r\n\t * @param date  Date\r\n\t * @return Position (px)\r\n\t */\r\n\tpublic dateToPosition(date: Date): number {\r\n\t\treturn this.valueToPosition(date.getTime());\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a numeric timestamp or a `Date` to a relative position on axis.\r\n\t *\r\n\t * @param date  Date or a timestamp\r\n\t * @return Relative position\r\n\t */\r\n\tpublic anyToPosition(date: Date | number): number {\r\n\t\tif (date instanceof Date) {\r\n\t\t\treturn this.dateToPosition(date);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.valueToPosition(date);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts date to orientation point (x, y, angle) on axis\r\n\t *\r\n\t * @param date Date\r\n\t * @return IOrientationPoint\r\n\t */\r\n\tpublic dateToPoint(date: Date): IOrientationPoint {\r\n\t\tlet position = this.dateToPosition(date);\r\n\t\tlet point = this.renderer.positionToPoint(position);\r\n\t\tlet angle = this.renderer.positionToAngle(position);\r\n\t\treturn { x: point.x, y: point.y, angle: angle };\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Converts a numeric value to orientation (x, y, angle) point on axis\r\n\t *\r\n\t * @param value  Value\r\n\t * @return Orientation point\r\n\t */\r\n\tpublic anyToPoint(date: Date | number): IOrientationPoint {\r\n\t\tif (date instanceof Date) {\r\n\t\t\treturn this.dateToPoint(date);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this.valueToPoint(date);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts pixel position within Axis to a corresponding Date.\r\n\t *\r\n\t * @param position  Position (px)\r\n\t * @return Date\r\n\t */\r\n\tpublic positionToDate(position: number): Date {\r\n\t\treturn new Date(this.positionToValue(position));\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the X coordinate for series' data item's value.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param dataItem  Data item\r\n\t * @param key       Data field to get value from\r\n\t * @param location  Location (0-1)\r\n\t * @return X coordinate (px)\r\n\t */\r\n\tpublic getX(dataItem: XYSeriesDataItem, key: string, location?: number): number {\r\n\t\tlet value: number = this.getTimeByLocation(dataItem, key, location);\r\n\t\t//let stack: number = dataItem.getValue(\"valueX\", \"stack\");\r\n\r\n\t\tif (!$type.isNumber(value)) {\r\n\t\t\tvalue = this.baseValue;\r\n\t\t}\r\n\r\n\t\treturn this.renderer.positionToPoint(this.valueToPosition(value)).x;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the Y coordinate for series' data item's value.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param dataItem  Data item\r\n\t * @param key       Data field to get value from\r\n\t * @param location  Location (0-1)\r\n\t * @return Y coordinate (px)\r\n\t */\r\n\tpublic getY(dataItem: XYSeriesDataItem, key: string, location?: number): number {\r\n\t\tlet value: number = this.getTimeByLocation(dataItem, key, location);\r\n\t\tlet stack: number = dataItem.getValue(\"valueX\", \"stack\");\r\n\r\n\t\tif (!$type.isNumber(value)) {\r\n\t\t\tvalue = this.baseValue;\r\n\t\t}\r\n\r\n\t\treturn this.renderer.positionToPoint(this.valueToPosition(value + stack)).y;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an angle for series data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param dataItem  Data item\r\n\t * @param key       Data field to get value from\r\n\t * @param location  Location (0-1)\r\n\t * @param stackKey  Stack ID\r\n\t * @return Angle\r\n\t */\r\n\tpublic getAngle(dataItem: XYSeriesDataItem, key: string, location?: number, stackKey?: string): number {\r\n\t\tlet value: number = this.getTimeByLocation(dataItem, key, location);\r\n\t\tlet stack: number = dataItem.getValue(stackKey, \"stack\");\r\n\r\n\t\tif (!$type.isNumber(value)) {\r\n\t\t\tvalue = this.baseValue;\r\n\t\t}\r\n\r\n\t\treturn this.positionToAngle(this.valueToPosition(value + stack));\r\n\t}\r\n\r\n\t/**\r\n\t * [getTimeByLocation description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param dataItem  [description]\r\n\t * @param key       [description]\r\n\t * @param location  [description]\r\n\t * @return [description]\r\n\t */\r\n\tprotected getTimeByLocation(dataItem: XYSeriesDataItem, key: string, location: number): number {\r\n\t\tif (!$type.hasValue(key)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (!$type.isNumber(location)) {\r\n\t\t\tlocation = dataItem.workingLocations[key];\r\n\r\n\t\t\tif (!$type.isNumber(location)) {\r\n\t\t\t\tlocation = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet startTime: number = dataItem.values[key][\"open\"];\r\n\t\tlet endTime: number = dataItem.values[key][\"close\"];\r\n\r\n\t\tif ($type.isNumber(startTime) && $type.isNumber(endTime)) {\r\n\t\t\treturn startTime + (endTime - startTime) * location;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Processes a related series' data item.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param dataItem  Data item\r\n\t */\r\n\tpublic processSeriesDataItem(dataItem: XYSeriesDataItem, axisLetter?: string): void {\r\n\r\n\t\tlet series = dataItem.component;\r\n\t\tlet time: number;\r\n\r\n\t\tlet date: Date = (<any>dataItem)[\"date\" + axisLetter];\r\n\t\tif (date) {\r\n\t\t\ttime = date.getTime();\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tlet openDate: Date = (<any>dataItem)[\"openDate\" + axisLetter];\r\n\t\tlet prevSeriesTime: number = this._prevSeriesTime;\r\n\r\n\r\n\t\tlet openTime: number;\r\n\t\tif (openDate) {\r\n\t\t\topenTime = openDate.getTime();\r\n\t\t}\r\n\r\n\t\tif ($type.isNumber(openTime)) {\r\n\t\t\tlet difference = Math.abs(time - openTime);\r\n\r\n\t\t\tif (this._minDifference[series.uid] > difference) {\r\n\t\t\t\tthis._minDifference[series.uid] = difference;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet differece: number = time - prevSeriesTime;\r\n\r\n\t\tif (differece > 0) {\r\n\t\t\tif (this._minDifference[series.uid] > differece) {\r\n\t\t\t\tthis._minDifference[series.uid] = differece;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._prevSeriesTime = time;\r\n\r\n\t\tif (series._baseInterval[this.uid]) {\r\n\t\t\tthis.postProcessSeriesDataItem(dataItem);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (this._baseInterval) {\r\n\t\t\t\tseries._baseInterval[this.uid] = this._baseInterval;\r\n\t\t\t\tthis.postProcessSeriesDataItem(dataItem);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [updateAxisBySeries description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t */\r\n\tpublic updateAxisBySeries() {\r\n\t\tsuper.updateAxisBySeries();\r\n\r\n\t\tlet baseInterval: ITimeInterval = this.chooseInterval(0, this.minDifference, 1);\r\n\t\t// handle short months\r\n\t\tif (this.minDifference >= $time.getDuration(\"day\", 27) && baseInterval.timeUnit == \"week\") {\r\n\t\t\tbaseInterval.timeUnit = \"month\";\r\n\t\t\tbaseInterval.count = 1;\r\n\t\t}\r\n\t\t// handle daylight saving\r\n\t\tif (this.minDifference >= $time.getDuration(\"hour\", 23) && baseInterval.timeUnit == \"hour\") {\r\n\t\t\tbaseInterval.timeUnit = \"day\";\r\n\t\t\tbaseInterval.count = 1;\r\n\t\t}\r\n\r\n\t\tif (this.minDifference >= $time.getDuration(\"week\", 1) - $time.getDuration(\"hour\", 1) && baseInterval.timeUnit == \"day\") {\r\n\t\t\tbaseInterval.timeUnit = \"week\";\r\n\t\t\tbaseInterval.count = 1;\r\n\t\t}\r\n\r\n\t\tif (this.minDifference >= $time.getDuration(\"year\", 1) - $time.getDuration(\"day\", 1.01) && baseInterval.timeUnit == \"month\") {\r\n\t\t\tbaseInterval.timeUnit = \"year\";\r\n\t\t\tbaseInterval.count = 1;\r\n\t\t}\r\n\r\n\t\tthis._baseIntervalReal = baseInterval;\r\n\t\t// no need to invalidate\r\n\t}\r\n\r\n\t/**\r\n\t * A base interval (granularity) of data.\r\n\t *\r\n\t * Used to indicate what are the base units of your data.\r\n\t *\r\n\t * For example, if you have a data set that has a data point every 5 minutes,\r\n\t * you may want to set this to `{ timeUnit: \"minute\", count: 5 }`.\r\n\t *\r\n\t * If not set, the Axis will try to determine the setting by its own, looking\r\n\t * at actual data.\r\n\t *\r\n\t * @param timeInterval base interval\r\n\t */\r\n\tpublic set baseInterval(timeInterval: ITimeInterval) {\r\n\t\tif (JSON.stringify(this._baseInterval) != JSON.stringify(timeInterval)) {\r\n\t\t\tthis._baseInterval = timeInterval;\r\n\t\t\tthis.invalidate();\r\n\t\t\tthis.postProcessSeriesDataItems();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Base interval\r\n\t */\r\n\tpublic get baseInterval(): ITimeInterval {\r\n\t\tif (this._baseInterval) {\r\n\t\t\treturn this._baseInterval;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this._baseIntervalReal;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * If enabled, axis will automatically collapse empty (without data points)\r\n\t * periods of time, i.e. weekends.\r\n\t *\r\n\t * An \"empty\" period is considered a stretch of time in the length of current\r\n\t * `baseInterval` without a single data point in it.\r\n\t *\r\n\t * For each such empty period, axis will automatically create an\r\n\t * [[AxisBreak]]. By default they will be invisible. You can still configure\r\n\t * them by accessing `axis.breaks.template`.\r\n\t *\r\n\t * [More info about breaks](https://www.amcharts.com/docs/v4/concepts/axes/#Breaks).\r\n\t *\r\n\t * Important notes:\r\n\t * * If you set this property to `true`, you can not add your custom axis breaks to this axis anymore.\r\n\t * * Using this feature affects performance. Use only if you need it.\r\n\t * * Setting this to `true` will reset appearance of breaks. If you want to modify appearance, do it *after* you set `skipEmptyPeriods`.\r\n\t *\r\n\t * @default false\r\n\t * @param value  Remove empty stretches of time?\r\n\t */\r\n\tpublic set skipEmptyPeriods(value: boolean) {\r\n\t\tif (this.setPropertyValue(\"skipEmptyPeriods\", value)) {\r\n\t\t\tthis.invalidateData();\r\n\t\t}\r\n\r\n\t\tif (value) {\r\n\t\t\tlet breakTemplate = this.axisBreaks.template;\r\n\t\t\tbreakTemplate.startLine.disabled = true;\r\n\t\t\tbreakTemplate.endLine.disabled = true;\r\n\t\t\tbreakTemplate.fillShape.disabled = true;\r\n\t\t\tbreakTemplate.breakSize = 0;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Remove empty stretches of time?\r\n\t */\r\n\tpublic get skipEmptyPeriods(): boolean {\r\n\t\treturn this.getPropertyValue(\"skipEmptyPeriods\");\r\n\t}\r\n\r\n\t/**\r\n\t * A special date format to apply axis tooltips.\r\n\t *\r\n\t * Will use same format as for labels, if not set.\r\n\t *\r\n\t * @param value  Date format\r\n\t */\r\n\tpublic set tooltipDateFormat(value: string) {\r\n\t\tthis.setPropertyValue(\"tooltipDateFormat\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Date format\r\n\t */\r\n\tpublic get tooltipDateFormat(): string {\r\n\t\treturn this.getPropertyValue(\"tooltipDateFormat\");\r\n\t}\r\n\r\n\t/**\r\n\t * Use `periodChangeDateFormats` to apply different formats to the first\r\n\t * label in bigger time unit.\r\n\t *\r\n\t * @default true\r\n\t * @param value  Use different format for period beginning?\r\n\t */\r\n\tpublic set markUnitChange(value: boolean) {\r\n\t\tif (this.setPropertyValue(\"markUnitChange\", value)) {\r\n\t\t\tthis.invalidateData();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Use different format for period beginning?\r\n\t */\r\n\tpublic get markUnitChange(): boolean {\r\n\t\treturn this.getPropertyValue(\"markUnitChange\");\r\n\t}\r\n\r\n\t/**\r\n\t * Returns text to show in a tooltip, based on specific relative position\r\n\t * within axis.\r\n\t *\r\n\t * The label will be formatted as per [[DateFormatter]] set for the whole\r\n\t * chart, or explicitly for this Axis.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param position  Position\r\n\t * @return Label (formatted date)\r\n\t */\r\n\tpublic getTooltipText(position: number): string {\r\n\t\tlet text: string;\r\n\t\tlet date = this.positionToDate(position);\r\n\t\tdate = $time.round(date, this.baseInterval.timeUnit, this.baseInterval.count, this.getFirstWeekDay(), this.dateFormatter.utc);\r\n\r\n\t\tif ($type.hasValue(this.tooltipDateFormat)) {\r\n\t\t\ttext = this.dateFormatter.format(date, this.tooltipDateFormat);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlet dateFormat = this.dateFormats.getKey(this.baseInterval.timeUnit);\r\n\t\t\tif (dateFormat) {\r\n\t\t\t\ttext = this.dateFormatter.format(date, dateFormat);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ttext = this.getPositionLabel(position);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.adapter.apply(\"getTooltipText\", text);\r\n\t}\r\n\r\n\t/**\r\n\t * Takes an absolute position within axis and adjust it to a specific position within base interval. (cell)\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param position Source position\r\n\t * @param location  Location in the cell\r\n\t * @return Adjusted position\r\n\t */\r\n\tpublic roundPosition(position: number, location?: AxisItemLocation): number {\r\n\t\tlet baseInterval = this.baseInterval;\r\n\t\tlet timeUnit = baseInterval.timeUnit;\r\n\t\tlet count = baseInterval.count;\r\n\r\n\t\tlet date: Date = this.positionToDate(position);\r\n\r\n\t\t$time.round(date, timeUnit, count, this.getFirstWeekDay(), this.dateFormatter.utc);\r\n\r\n\t\tif (location > 0) {\r\n\t\t\t$time.add(date, timeUnit, location * count, this.dateFormatter.utc);\r\n\t\t}\r\n\r\n\t\tif (this.isInBreak(date.getTime())) {\r\n\t\t\twhile (date.getTime() < this.max) {\r\n\t\t\t\t$time.add(date, timeUnit, count, this.dateFormatter.utc);\r\n\t\t\t\tif (!this.isInBreak(date.getTime())) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this.dateToPosition(date);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an relative position of the start of the cell (period), that specific position value falls into.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param position  Relative position\r\n\t * @return Cell start relative position\r\n\t */\r\n\tpublic getCellStartPosition(position: number): number {\r\n\t\treturn this.roundPosition(position, 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an relative position of the end of the cell (period), that specific position value falls into.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description (review)\r\n\t * @param position  Relative position\r\n\t * @return Cell end relative position\r\n\t */\r\n\tpublic getCellEndPosition(position: number): number {\r\n\t\treturn this.roundPosition(position, 1);\r\n\t\t//return this.dateToPosition($time.add(this.positionToDate(this.roundPosition(position, 1)), this.baseInterval.timeUnit, this.baseInterval.count));\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a Series data item that corresponds to the specific pixel position\r\n\t * of the Axis.\r\n\t *\r\n\t * If `findNearest` (third parameter) is set to `true`, the method will try\r\n\t * to locate nearest available data item if none is found directly under\r\n\t * `position`.\r\n\t *\r\n\t * @param series       Series\r\n\t * @param position     Position (px)\r\n\t * @param findNearest  Should axis try to find nearest tooltip if there is no data item at exact position\r\n\t * @return Data item\r\n\t */\r\n\tpublic getSeriesDataItem(series: XYSeries, position: number, findNearest?: boolean): XYSeriesDataItem {\r\n\r\n\t\tlet value: number = this.positionToValue(position);\r\n\t\tlet date: Date = $time.round(new Date(value), this.baseInterval.timeUnit, this.baseInterval.count, this.getFirstWeekDay(), this.dateFormatter.utc);\r\n\r\n\t\tlet dataItemsByAxis = series.dataItemsByAxis.getKey(this.uid);\r\n\r\n\t\tlet dataItem = dataItemsByAxis.getKey(date.getTime().toString());\r\n\r\n\t\t// todo:  alternatively we can find closiest here\r\n\t\tif (!dataItem && findNearest) {\r\n\r\n\t\t\tlet key: \"dateX\" | \"dateY\";\r\n\r\n\t\t\tif (this.axisLetter == \"Y\") {\r\n\t\t\t\tkey = \"dateY\";\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tkey = \"dateX\";\r\n\t\t\t}\r\n\r\n\t\t\tdataItem = series.dataItems.getIndex(series.dataItems.findClosestIndex(date.getTime(), (x) => {\r\n\t\t\t\tif (x[key]) {\r\n\t\t\t\t\treturn <number>x[key].getTime();\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\treturn -Infinity;\r\n\t\t\t\t}\r\n\t\t\t}, \"any\"));\r\n\t\t}\r\n\r\n\t\treturn dataItem;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a formatted date based on position in axis scale.\r\n\t *\r\n\t * Please note that `position` represents position within axis which may be\r\n\t * zoomed and not correspond to Cursor's `position`.\r\n\t *\r\n\t * To convert Cursor's `position` to Axis' `position` use `toAxisPosition()` method.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/tutorials/tracking-cursors-position-via-api/#Tracking_Cursor_s_position} For more information about cursor tracking.\r\n\t * @param position  Relative position on axis (0-1)\r\n\t * @return Position label\r\n\t */\r\n\tpublic getPositionLabel(position: number): string {\r\n\t\t// @todo Better format recognition\r\n\t\tlet date = this.positionToDate(position);\r\n\t\treturn this.dateFormatter.format(date, this.getCurrentLabelFormat());\r\n\t}\r\n\r\n\t/**\r\n\t * Returns label date format based on currently used time units\r\n\t *\r\n\t * @return Format\r\n\t */\r\n\tprotected getCurrentLabelFormat(): string {\r\n\t\treturn this.dateFormats.getKey(this._gridInterval ? this._gridInterval.timeUnit : \"day\");\r\n\t}\r\n\r\n\t/**\r\n\t * Initializes an Axis renderer.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic initRenderer(): void {\r\n\t\tsuper.initRenderer();\r\n\t\tlet renderer = this.renderer;\r\n\t\tif (renderer) {\r\n\t\t\t// Set defaults\r\n\t\t\trenderer.ticks.template.location = 0;\r\n\t\t\trenderer.grid.template.location = 0;\r\n\t\t\trenderer.labels.template.location = 0;\r\n\t\t\trenderer.baseGrid.disabled = true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Coordinates of the actual axis start.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Base point\r\n\t */\r\n\tpublic get basePoint(): IPoint {\r\n\t\treturn { x: 0, y: 0 };\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Zooms axis to specific Dates.\r\n\t *\r\n\t * @param startDate       Start date\r\n\t * @param endValue        End date\r\n\t * @param skipRangeEvent  Do not invoke events\r\n\t * @param instantly       Do not play zoom animations\r\n\t */\r\n\tpublic zoomToDates(startDate: Date, endDate: Date, skipRangeEvent?: boolean, instantly?: boolean): void {\r\n\t\tstartDate = this.dateFormatter.parse(startDate);\r\n\t\tendDate = this.dateFormatter.parse(endDate);\r\n\t\tthis.zoomToValues(startDate.getTime(), endDate.getTime(), skipRangeEvent, instantly);\r\n\t}\r\n\r\n\t/**\r\n\t * Adds `baseInterval` to \"as is\" fields.\r\n\t *\r\n\t * @param field  Field name\r\n\t * @return Assign as is?\r\n\t */\r\n\tprotected asIs(field: string): boolean {\r\n\t\treturn field == \"baseInterval\" || super.asIs(field);\r\n\t}\r\n\r\n\t/**\r\n\t * Copies all properties and related data from a different instance of Axis.\r\n\t *\r\n\t * @param source Source Axis\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\tsuper.copyFrom(source);\r\n\t\tthis.dateFormats = source.dateFormats;\r\n\t\tthis.periodChangeDateFormats = source.periodChangeDateFormats;\r\n\t\tif (source[\"_baseInterval\"]) {\r\n\t\t\tthis.baseInterval = source.baseInterval;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Shows Axis tooltip at specific relative position within Axis. (0-1)\r\n\t *\r\n\t * @param position Position (0-1)\r\n\t * @param local or global position\r\n\t */\r\n\tpublic showTooltipAtPosition(position: number, local?: boolean) {\r\n\r\n\t\tif (!local) {\r\n\t\t\tposition = this.toAxisPosition(position);\r\n\t\t}\r\n\r\n\t\tif (this.snapTooltip) {\r\n\t\t\tlet actualDate = $time.round(this.positionToDate(position), this.baseInterval.timeUnit, 1, this.getFirstWeekDay(), this.dateFormatter.utc);\r\n\r\n\t\t\tlet actualTime = actualDate.getTime();\r\n\t\t\tlet closestDate: Date;\r\n\r\n\t\t\tthis.series.each((series) => {\r\n\t\t\t\tif (series.baseAxis == this) {\r\n\t\t\t\t\tlet dataItem = this.getSeriesDataItem(series, position, true);\r\n\r\n\t\t\t\t\tif (dataItem) {\r\n\t\t\t\t\t\tlet date: Date;\r\n\t\t\t\t\t\tif (series.xAxis == this) {\r\n\t\t\t\t\t\t\tdate = dataItem.dateX;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (series.yAxis == this) {\r\n\t\t\t\t\t\t\tdate = dataItem.dateY;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (!closestDate) {\r\n\t\t\t\t\t\t\tclosestDate = date;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tif (Math.abs(closestDate.getTime() - actualTime) > Math.abs(date.getTime() - actualTime)) {\r\n\t\t\t\t\t\t\t\tclosestDate = date;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\r\n\t\t\tif (closestDate) {\r\n\t\t\t\tlet closestTime = closestDate.getTime();\r\n\t\t\t\tclosestDate = $time.round(new Date(closestTime), this.baseInterval.timeUnit, this.baseInterval.count, this.getFirstWeekDay(), this.dateFormatter.utc);\r\n\t\t\t\tclosestTime = closestDate.getTime();\r\n\t\t\t\tclosestDate = new Date(closestDate.getTime() + this.baseDuration * this.renderer.tooltipLocation);\r\n\t\t\t\tposition = this.dateToPosition(closestDate);\r\n\r\n\t\t\t\tthis.series.each((series) => {\r\n\r\n\t\t\t\t\tlet dataItem = series.dataItemsByAxis.getKey(this.uid).getKey(closestTime.toString());\r\n\t\t\t\t\tlet point = series.showTooltipAtDataItem(dataItem);\r\n\t\t\t\t\tif (point) {\r\n\t\t\t\t\t\tthis.chart._seriesPoints.push({ series: series, point: point });\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t// check, otherwise column tooltip will be hidden\r\n\t\t\t\t\t\tif (series.tooltipText || series.tooltipHTML) {\r\n\t\t\t\t\t\t\tseries.hideTooltip();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\r\n\t\t\t\t//this.chart.sortSeriesTooltips(seriesPoints);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsuper.showTooltipAtPosition(position, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Should the nearest tooltip be shown if no data item is found on the\r\n\t * current cursor position.\r\n\t *\r\n\t * @default true\r\n\t * @param value  Should snap?\r\n\t */\r\n\tpublic set snapTooltip(value: boolean) {\r\n\t\tthis.setPropertyValue(\"snapTooltip\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Should snap?\r\n\t */\r\n\tpublic get snapTooltip(): boolean {\r\n\t\treturn this.getPropertyValue(\"snapTooltip\");\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Current grid interval.\r\n\t *\r\n\t * @return Grid interval\r\n\t */\r\n\tpublic get gridInterval(): ITimeInterval {\r\n\t\treturn this._gridInterval;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic makeGap(dataItem: LineSeriesDataItem, previous: LineSeriesDataItem): boolean {\r\n\t\tlet series = dataItem.component;\r\n\t\tif (dataItem && previous) {\r\n\t\t\tif (!series.connect && $type.isNumber(series.autoGapCount)) {\r\n\t\t\t\tif (series.baseAxis == this) {\r\n\t\t\t\t\tlet time = dataItem.dates[\"date\" + this.axisLetter].getTime();\r\n\t\t\t\t\tlet prevTime = previous.dates[\"date\" + this.axisLetter].getTime();\r\n\r\n\t\t\t\t\tif (time - prevTime > series.autoGapCount * this.baseDuration) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"DateAxis\"] = DateAxis;\r\nregistry.registeredClasses[\"DateAxisDataItem\"] = DateAxisDataItem;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}