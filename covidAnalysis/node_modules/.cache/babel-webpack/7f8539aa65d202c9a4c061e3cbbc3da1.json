{"ast":null,"code":"/**\n * XY series module.\n */\nimport * as tslib_1 from \"tslib\";\n/**\n * ============================================================================\n * IMPORTS\n * ============================================================================\n * @hidden\n */\n\nimport { Series, SeriesDataItem } from \"./Series\";\nimport { Sprite } from \"../../core/Sprite\";\nimport { ValueAxis } from \"../axes/ValueAxis\";\nimport { Dictionary } from \"../../core/utils/Dictionary\";\nimport { MutableValueDisposer } from \"../../core/utils/Disposer\";\nimport { CategoryAxis } from \"../axes/CategoryAxis\";\nimport { DateAxis } from \"../axes/DateAxis\";\nimport { registry } from \"../../core/Registry\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $utils from \"../../core/utils/Utils\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $array from \"../../core/utils/Array\";\nimport * as $object from \"../../core/utils/Object\";\nimport * as $path from \"../../core/rendering/Path\";\n/**\n * ============================================================================\n * DATA ITEM\n * ============================================================================\n * @hidden\n */\n\n/**\n * Defines a [[DataItem]] for [[XYSeries]].\n *\n * @see {@link DataItem}\n */\n\nvar XYSeriesDataItem =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(XYSeriesDataItem, _super);\n  /**\n   * Constructor\n   */\n\n\n  function XYSeriesDataItem() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"XYSeriesDataItem\";\n    _this.values.valueX = {\n      stack: 0\n    };\n    _this.values.valueY = {\n      stack: 0\n    };\n    _this.values.openValueX = {};\n    _this.values.openValueY = {};\n    _this.values.dateX = {};\n    _this.values.dateY = {};\n    _this.values.openDateX = {};\n    _this.values.openDateY = {};\n\n    _this.setLocation(\"dateX\", 0.5, 0);\n\n    _this.setLocation(\"dateY\", 0.5, 0);\n\n    _this.setLocation(\"categoryX\", 0.5, 0);\n\n    _this.setLocation(\"categoryY\", 0.5, 0);\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  Object.defineProperty(XYSeriesDataItem.prototype, \"valueX\", {\n    /**\n     * @return Value\n     */\n    get: function get() {\n      return this.values.valueX.value;\n    },\n\n    /**\n     * Item's numeric value on X value axis.\n     *\n     * @param value  Value\n     */\n    set: function set(value) {\n      this.setValue(\"valueX\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeriesDataItem.prototype, \"valueY\", {\n    /**\n     * @return Value\n     */\n    get: function get() {\n      return this.values.valueY.value;\n    },\n\n    /**\n     * Item's numeric value on Y value axis.\n     *\n     * @param value  Value\n     */\n    set: function set(value) {\n      this.setValue(\"valueY\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeriesDataItem.prototype, \"dateX\", {\n    /**\n     * @return Date\n     */\n    get: function get() {\n      return this.getDate(\"dateX\");\n    },\n\n    /**\n     * Item's date value on X date-based axis.\n     *\n     * @param date  Date\n     */\n    set: function set(date) {\n      this.setDate(\"dateX\", date);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeriesDataItem.prototype, \"dateY\", {\n    /**\n     * @return Date\n     */\n    get: function get() {\n      return this.getDate(\"dateY\");\n    },\n\n    /**\n     * Item's date value on Y date-based axis.\n     *\n     * @param date  Date\n     */\n    set: function set(date) {\n      this.setDate(\"dateY\", date);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeriesDataItem.prototype, \"categoryX\", {\n    /**\n     * @return Category\n     */\n    get: function get() {\n      return this.categories.categoryX;\n    },\n\n    /**\n     * Item's category on X category axis.\n     *\n     * @param category  Category\n     */\n    set: function set(category) {\n      this.setCategory(\"categoryX\", category);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeriesDataItem.prototype, \"categoryY\", {\n    /**\n     * @return Category\n     */\n    get: function get() {\n      return this.categories.categoryY;\n    },\n\n    /**\n     * Item's category on Y category axis.\n     *\n     * @param category  Category\n     */\n    set: function set(category) {\n      this.setCategory(\"categoryY\", category);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeriesDataItem.prototype, \"openValueX\", {\n    /**\n     * @return Value\n     */\n    get: function get() {\n      return this.values.openValueX.value;\n    },\n\n    /**\n     * Item's open numeric value on X value axis.\n     *\n     * @param value  Value\n     */\n    set: function set(value) {\n      this.setValue(\"openValueX\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeriesDataItem.prototype, \"openValueY\", {\n    /**\n     * @return Value\n     */\n    get: function get() {\n      return this.values.openValueY.value;\n    },\n\n    /**\n     * Item's open numeric value on Y value axis.\n     *\n     * @param value  Value\n     */\n    set: function set(value) {\n      this.setValue(\"openValueY\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeriesDataItem.prototype, \"openDateX\", {\n    /**\n     * @return Date\n     */\n    get: function get() {\n      return this.getDate(\"openDateX\");\n    },\n\n    /**\n     * Item's open date value on X date-based axis.\n     *\n     * @param date  Date\n     */\n    set: function set(date) {\n      this.setDate(\"openDateX\", date);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeriesDataItem.prototype, \"openDateY\", {\n    /**\n     * @return Date\n     */\n    get: function get() {\n      return this.getDate(\"openDateY\");\n    },\n\n    /**\n     * Item's open date value on Y date-based axis.\n     *\n     * @param date  Date\n     */\n    set: function set(date) {\n      this.setDate(\"openDateY\", date);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeriesDataItem.prototype, \"openCategoryX\", {\n    /**\n     * @return Category\n     */\n    get: function get() {\n      return this.categories.openCategoryX;\n    },\n\n    /**\n     * Item's open category on X category axis.\n     *\n     * @param category  Category\n     */\n    set: function set(category) {\n      this.setProperty(\"openCategoryX\", category);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeriesDataItem.prototype, \"openCategoryY\", {\n    /**\n     * @return Category\n     */\n    get: function get() {\n      return this.categories.openCategoryY;\n    },\n\n    /**\n     * Item's open category on Y category axis.\n     *\n     * @param category  Category\n     */\n    set: function set(category) {\n      this.setProperty(\"openCategoryY\", category);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Return smallest value out of all item's value fields.\n   *\n   * @ignore Exclude from docs\n   * @param fields      Fields to check in\n   * @param working     Include working (temporary) values\n   * @param stackValue  If item is in a stack, the value item starts as\n   * @return Value\n   */\n\n  XYSeriesDataItem.prototype.getMin = function (fields, working, stackValue) {\n    var _this = this; //if (this.visible) {  // dumped because of non smooth zooming\n\n\n    var min;\n\n    if (!$type.isNumber(stackValue)) {\n      stackValue = 0;\n    }\n\n    $array.each(fields, function (field) {\n      var value;\n\n      if (working) {\n        value = _this.getWorkingValue(field);\n      } else {\n        value = _this.getValue(field);\n      }\n\n      value += stackValue;\n\n      if (value < min || !$type.isNumber(min)) {\n        min = value;\n      }\n    });\n    return min; //}\n  };\n  /**\n   * Return biggest value out of all item's value fields.\n   *\n   * @ignore Exclude from docs\n   * @param fields      Fields to check in\n   * @param working     Include working (temporary) values\n   * @param stackValue  If item is in a stack, the value item starts as\n   * @return Value\n   */\n\n\n  XYSeriesDataItem.prototype.getMax = function (fields, working, stackValue) {\n    var _this = this; //if (this.visible) { // dumped because of non smooth zooming\n\n\n    var max;\n\n    if (!$type.isNumber(stackValue)) {\n      stackValue = 0;\n    }\n\n    $array.each(fields, function (field) {\n      var value;\n\n      if (working) {\n        value = _this.getWorkingValue(field);\n      } else {\n        value = _this.getValue(field);\n      }\n\n      value += stackValue;\n\n      if (value > max || !$type.isNumber(max)) {\n        max = value;\n      }\n    });\n    return max; //}\n  };\n\n  return XYSeriesDataItem;\n}(SeriesDataItem);\n\nexport { XYSeriesDataItem };\n/**\n * ============================================================================\n * MAIN CLASS\n * ============================================================================\n * @hidden\n */\n\n/**\n * Defines Series for [[XYChart]].\n *\n * @see {@link IXYSeriesEvents} for a list of available Events\n * @see {@link IXYSeriesAdapters} for a list of available Adapters\n * @todo Example\n * @important\n */\n\nvar XYSeries =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(XYSeries, _super);\n  /**\n   * Constructor\n   */\n\n\n  function XYSeries() {\n    var _this = _super.call(this) || this;\n    /**\n     * X axis the series is attached to.\n     */\n\n\n    _this._xAxis = new MutableValueDisposer();\n    /**\n     * Y axis the series is attached to.\n     */\n\n    _this._yAxis = new MutableValueDisposer();\n    /**\n     * [_xValueFields description]\n     *\n     * @todo Description\n     */\n\n    _this._xValueFields = [];\n    /**\n     * [_yValueFields description]\n     *\n     * @todo Description\n     */\n\n    _this._yValueFields = [];\n    /**\n     * @ignore\n     */\n\n    _this._baseInterval = {};\n    _this.className = \"XYSeries\";\n    _this.isMeasured = false;\n    _this.cursorTooltipEnabled = true;\n    _this.cursorHoverEnabled = true;\n    _this.mainContainer.mask = new Sprite();\n\n    _this.mainContainer.mask.setElement(_this.paper.add(\"path\"));\n\n    _this.stacked = false;\n    _this.snapTooltip = false;\n    _this.tooltip.pointerOrientation = \"horizontal\";\n\n    _this.tooltip.events.on(\"hidden\", function () {\n      _this.returnBulletDefaultState();\n    }, undefined, false);\n\n    _this._disposers.push(_this._xAxis);\n\n    _this._disposers.push(_this._yAxis);\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\n   * Sets defaults that instantiate some objects that rely on parent, so they\n   * cannot be set in constructor.\n   */\n\n\n  XYSeries.prototype.applyInternalDefaults = function () {\n    _super.prototype.applyInternalDefaults.call(this);\n\n    if (!$type.hasValue(this.readerTitle)) {\n      this.readerTitle = this.language.translate(\"X/Y Series\");\n    }\n  };\n  /**\n   * Returns a new/empty DataItem of the type appropriate for this object.\n   *\n   * @see {@link DataItem}\n   * @return Data Item\n   */\n\n\n  XYSeries.prototype.createDataItem = function () {\n    return new XYSeriesDataItem();\n  };\n  /**\n   * @ignore\n   */\n\n\n  XYSeries.prototype.dataChangeUpdate = function () {\n    this._tmin.clear();\n\n    this._tmax.clear();\n\n    this._smin.clear();\n\n    this._smax.clear();\n\n    if (this.xAxis) {\n      this.xAxis.seriesDataChangeUpdate(this);\n    }\n\n    if (this.yAxis) {\n      this.yAxis.seriesDataChangeUpdate(this);\n    }\n  };\n  /**\n   * (Re)validates the series' data.\n   *\n   * @ignore Exclude from docs\n   */\n\n\n  XYSeries.prototype.validateData = function () {\n    this.defineFields();\n\n    if (this.data.length > 0) {\n      this.dataChangeUpdate();\n    }\n\n    _super.prototype.validateData.call(this);\n\n    this.updateItemReaderText();\n\n    if (!$type.hasValue(this.dataFields[this._xField]) || !$type.hasValue(this.dataFields[this._yField])) {\n      throw Error(\"Data fields for series \\\"\" + (this.name ? this.name : this.uid) + \"\\\" are not properly defined.\");\n    }\n  };\n  /**\n   * Processes data item.\n   *\n   * @param dataItem     Data item\n   * @param dataContext  Raw data\n   * @param index        Index of the data item\n   */\n\n\n  XYSeries.prototype.processDataItem = function (dataItem, dataContext) {\n    try {\n      _super.prototype.processDataItem.call(this, dataItem, dataContext);\n\n      dataItem.events.disable();\n      this.xAxis.processSeriesDataItem(dataItem, \"X\");\n      this.yAxis.processSeriesDataItem(dataItem, \"Y\");\n      dataItem.events.enable();\n      this.setInitialWorkingValues(dataItem);\n    } catch (e) {\n      this._chart.raiseCriticalError(e);\n    }\n  };\n  /**\n   *\n   * When validating raw data, instead of processing data item, we update it\n   *\n   * @ignore Exclude from docs\n   * @param item\n   */\n\n\n  XYSeries.prototype.updateDataItem = function (dataItem) {\n    _super.prototype.updateDataItem.call(this, dataItem); //dataItem.events.disable();\n\n\n    this.xAxis.processSeriesDataItem(dataItem, \"X\");\n    this.yAxis.processSeriesDataItem(dataItem, \"Y\"); //dataItem.events.enable();\t\t\n  };\n  /**\n   * Inits data item's working values.\n   *\n   * @param dataItem  Data item\n   * @param index     Data item's index\n   */\n\n\n  XYSeries.prototype.setInitialWorkingValues = function (dataItem) {};\n  /**\n   * @ignore\n   */\n\n\n  XYSeries.prototype.disposeData = function () {\n    _super.prototype.disposeData.call(this);\n\n    if (this.xAxis) {\n      var dataItemsX = this.dataItemsByAxis.getKey(this.xAxis.uid);\n\n      if (dataItemsX) {\n        dataItemsX.clear();\n      }\n\n      if (this.xAxis instanceof CategoryAxis) {\n        this.clearCatAxis(this.xAxis);\n      }\n    }\n\n    if (this.yAxis) {\n      var dataItemsY = this.dataItemsByAxis.getKey(this.yAxis.uid);\n\n      if (dataItemsY) {\n        dataItemsY.clear();\n      }\n\n      if (this.yAxis instanceof CategoryAxis) {\n        this.clearCatAxis(this.yAxis);\n      }\n    }\n  };\n  /**\n   * @ignore\n   */\n\n\n  XYSeries.prototype.clearCatAxis = function (axis) {\n    var uid = this.uid;\n    axis.dataItems.each(function (dataItem) {\n      if (dataItem.seriesDataItems[uid]) {\n        dataItem.seriesDataItems[uid] = [];\n      }\n    });\n  };\n  /**\n   * Sets up which data fields to use for data access.\n   */\n\n\n  XYSeries.prototype.defineFields = function () {\n    var xAxis = this.xAxis;\n    var yAxis = this.yAxis;\n    var xAxisFieldName = xAxis.axisFieldName;\n    var xField = xAxisFieldName + \"X\";\n    var xOpenField = \"open\" + $utils.capitalize(xAxisFieldName) + \"X\";\n    var yAxisFieldName = yAxis.axisFieldName;\n    var yField = yAxisFieldName + \"Y\";\n    var yOpenField = \"open\" + $utils.capitalize(yAxisFieldName) + \"Y\";\n    this._xField = xField;\n    this._yField = yField;\n\n    if (this.dataFields[xOpenField]) {\n      this._xOpenField = xOpenField;\n    }\n\n    if (this.dataFields[yOpenField]) {\n      this._yOpenField = yOpenField;\n    }\n\n    if (!this.dataFields[yOpenField] && this.baseAxis == this.yAxis) {\n      this._yOpenField = yField;\n    }\n\n    if (!this.dataFields[xOpenField] && this.baseAxis == this.xAxis) {\n      this._xOpenField = xField;\n    }\n\n    if (this.stacked && this.baseAxis == this.xAxis) {\n      this._xOpenField = xField;\n    }\n\n    if (this.stacked && this.baseAxis == this.yAxis) {\n      this._yOpenField = yField;\n    }\n\n    if (this.xAxis instanceof CategoryAxis && this.yAxis instanceof CategoryAxis) {\n      if (!this._yOpenField) {\n        this._yOpenField = yField;\n      }\n    }\n\n    this._xValueFields = [];\n    this._yValueFields = [];\n    this.addValueField(this.xAxis, this._xValueFields, this._xField);\n    this.addValueField(this.xAxis, this._xValueFields, this._xOpenField);\n    this.addValueField(this.yAxis, this._yValueFields, this._yField);\n    this.addValueField(this.yAxis, this._yValueFields, this._yOpenField);\n  };\n  /**\n   * [axis description]\n   *\n   * @todo Description\n   * @param axis    Axis\n   * @param fields  Fields (?)\n   * @param field   Field\n   */\n\n\n  XYSeries.prototype.addValueField = function (axis, fields, field) {\n    if (axis instanceof ValueAxis) {\n      if ($type.hasValue(this.dataFields[field]) && fields.indexOf(field) == -1) {\n        fields.push(field);\n      }\n    }\n  };\n  /**\n   * Sets category field from the category axis.\n   *\n   * User might set field for category axis only, but not for series. In such\n   * case, we take field value from axis and set it for series.\n   *\n   * @param field  Field\n   * @param axis   Axis\n   */\n\n\n  XYSeries.prototype.setCategoryAxisField = function (field, axis) {\n    if (!$type.hasValue(this.dataFields[field])) {\n      this.dataFields[field] = axis.dataFields.category;\n    }\n  };\n  /**\n   * Sets date field from the date axis.\n   *\n   * User might set field for category axis only, but not for series. In such\n   * case, we take field value from axis and set it for series.\n   *\n   * @param field  Field\n   * @param axis   Axis\n   */\n\n\n  XYSeries.prototype.setDateAxisField = function (field, axis) {\n    if (!$type.hasValue(this.dataFields[field])) {\n      this.dataFields[field] = axis.dataFields.date;\n    }\n  };\n  /**\n   * Performs after-draw tasks, e.g. creates masks.\n   */\n\n\n  XYSeries.prototype.afterDraw = function () {\n    _super.prototype.afterDraw.call(this);\n\n    this.createMask();\n  };\n  /**\n   * Create a mask for the series.\n   *\n   * @ignore Exclude from docs\n   */\n\n\n  XYSeries.prototype.createMask = function () {\n    // this mask from which we cut out ranges. does not work well if ranges overlap.\n    if (this.mainContainer.mask) {\n      var path_1 = this.getMaskPath(); // @todo: this approach won't work well on circluar or other non x/y axes\n\n      $iter.each(this.axisRanges.iterator(), function (range) {\n        if (range.axisFill.fillPath) {\n          range.axisFill.validate();\n          path_1 += range.axisFill.fillPath;\n        }\n      });\n      this.mainContainer.mask.path = path_1;\n    }\n  };\n  /**\n   * Returns an SVG path to use as series mask.\n   *\n   * @return SVG path\n   */\n\n\n  XYSeries.prototype.getMaskPath = function () {\n    return $path.rectToPath({\n      x: 0,\n      y: 0,\n      width: this.xAxis.axisLength,\n      height: this.yAxis.axisLength\n    });\n  };\n  /**\n   * Returns axis data field to use.\n   *\n   * @param axis  Axis\n   * @return Field name\n   */\n\n\n  XYSeries.prototype.getAxisField = function (axis) {\n    if (axis == this.xAxis) {\n      return this.xField;\n    }\n\n    if (axis == this.yAxis) {\n      return this.yField;\n    }\n  };\n  /**\n   * Validates data items.\n   *\n   * @ignore Exclude from docs\n   */\n\n\n  XYSeries.prototype.validateDataItems = function () {\n    // this helps date axis to check which baseInterval we should use\n    this.xAxis.updateAxisBySeries();\n    this.yAxis.updateAxisBySeries();\n\n    _super.prototype.validateDataItems.call(this);\n\n    this.xAxis.postProcessSeriesDataItems();\n    this.yAxis.postProcessSeriesDataItems();\n  };\n  /**\n   * Validates data range.\n   *\n   * @ignore Exclude from docs\n   */\n\n\n  XYSeries.prototype.validateDataRange = function () {\n    if (this.xAxis.dataRangeInvalid) {\n      this.xAxis.validateDataRange();\n    }\n\n    if (this.yAxis.dataRangeInvalid) {\n      this.yAxis.validateDataRange();\n    }\n\n    _super.prototype.validateDataRange.call(this);\n  };\n  /**\n   * (Re)validates the whole series, effectively causing it to redraw.\n   *\n   * @ignore Exclude from docs\n   */\n\n\n  XYSeries.prototype.validate = function () {\n    if (this.xAxis.invalid) {\n      this.xAxis.validate();\n    }\n\n    if (this.yAxis.invalid) {\n      this.yAxis.validate();\n    }\n\n    this.y = this.yAxis.pixelY;\n    this.x = this.xAxis.pixelX;\n    this._showBullets = true;\n    var minBulletDistance = this.minBulletDistance;\n\n    if ($type.isNumber(minBulletDistance)) {\n      if (this.baseAxis.axisLength / (this.endIndex - this.startIndex) < minBulletDistance) {\n        this._showBullets = false;\n      }\n    }\n\n    _super.prototype.validate.call(this);\n  };\n\n  Object.defineProperty(XYSeries.prototype, \"xAxis\", {\n    /**\n     * @return Axis\n     */\n    get: function get() {\n      if (this.chart) {\n        if (!this._xAxis.get()) {\n          var axis = this.chart.xAxes.getIndex(0);\n\n          if (!axis) {\n            throw Error(\"There are no X axes on chart.\");\n          }\n\n          this.xAxis = axis;\n        }\n\n        return this._xAxis.get();\n      }\n    },\n\n    /**\n     * X axis the series is attached to.\n     *\n     * @param axis  Axis\n     */\n    set: function set(axis) {\n      var oldAxis = this._xAxis.get();\n\n      if (oldAxis != axis) {\n        if (oldAxis) {\n          this.dataItemsByAxis.removeKey(oldAxis.uid); // TODO why is this here ?\n\n          this._xAxis.dispose(); // temp @todo: why it is not disposed?\n\n\n          oldAxis.series.removeValue(this);\n        }\n\n        this._xAxis.set(axis, axis.registerSeries(this));\n\n        this.dataItemsByAxis.setKey(axis.uid, new Dictionary());\n        this.invalidateData();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeries.prototype, \"yAxis\", {\n    /**\n     * @return Axis\n     */\n    get: function get() {\n      if (this.chart) {\n        if (!this._yAxis.get()) {\n          var axis = this.chart.yAxes.getIndex(0);\n\n          if (!axis) {\n            throw Error(\"There are no Y axes on chart.\");\n          }\n\n          this.yAxis = axis;\n        }\n\n        return this._yAxis.get();\n      }\n    },\n\n    /**\n     * Y axis the series is attached to.\n     *\n     * @param axis  Axis\n     */\n    set: function set(axis) {\n      var oldAxis = this._yAxis.get();\n\n      if (oldAxis != axis) {\n        if (oldAxis) {\n          this.dataItemsByAxis.removeKey(oldAxis.uid); // TODO why is this here ?\n\n          this._yAxis.dispose(); // temp @todo: why it is not disposed?\n\n\n          oldAxis.series.removeValue(this);\n        }\n\n        this._yAxis.set(axis, axis.registerSeries(this));\n\n        this.dataItemsByAxis.setKey(axis.uid, new Dictionary());\n        this.invalidateData();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeries.prototype, \"baseAxis\", {\n    /**\n     * @return Axis\n     */\n    get: function get() {\n      if (!this._baseAxis) {\n        if (this.yAxis instanceof DateAxis) {\n          this._baseAxis = this.yAxis;\n        }\n\n        if (this.xAxis instanceof DateAxis) {\n          this._baseAxis = this.xAxis;\n        }\n\n        if (this.yAxis instanceof CategoryAxis) {\n          this._baseAxis = this.yAxis;\n        }\n\n        if (this.xAxis instanceof CategoryAxis) {\n          this._baseAxis = this.xAxis;\n        }\n\n        if (!this._baseAxis) {\n          this._baseAxis = this.xAxis;\n        }\n      }\n\n      return this._baseAxis;\n    },\n\n    /**\n     * The main (base) axis.\n     *\n     * This is the axis that series fills will go to, or grow animations will\n     * happen from.\n     *\n     * @param value  Axis\n     */\n    set: function set(value) {\n      if (this._baseAxis != value) {\n        this._baseAxis = value;\n        this.invalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Processes values after data items' were added.\n   *\n   * @ignore Exclude from docs\n   * @param dataItems  Data items\n   */\n\n  XYSeries.prototype.processValues = function (working) {\n    _super.prototype.processValues.call(this, working);\n\n    var dataItems = this.dataItems;\n    var minX = Infinity;\n    var maxX = -Infinity;\n    var minY = Infinity;\n    var maxY = -Infinity;\n    var startIndex = this.startIndex;\n    var endIndex = this.endIndex;\n\n    if (!working) {\n      startIndex = 0;\n      endIndex = this.dataItems.length;\n    }\n\n    for (var i = startIndex; i < endIndex; i++) {\n      var dataItem = dataItems.getIndex(i);\n      this.getStackValue(dataItem, working);\n      var stackX = dataItem.getValue(\"valueX\", \"stack\");\n      var stackY = dataItem.getValue(\"valueY\", \"stack\");\n      minX = $math.min(dataItem.getMin(this._xValueFields, working, stackX), minX);\n      minY = $math.min(dataItem.getMin(this._yValueFields, working, stackY), minY);\n      maxX = $math.max(dataItem.getMax(this._xValueFields, working, stackX), maxX);\n      maxY = $math.max(dataItem.getMax(this._yValueFields, working, stackY), maxY); // if it's stacked, pay attention to stack value\n\n      if (this.stacked) {\n        if (this.baseAxis == this.xAxis) {\n          minY = $math.min(minY, stackY);\n        }\n\n        if (this.baseAxis == this.yAxis) {\n          minX = $math.min(minX, stackX);\n        }\n      }\n    } // this is mainly for value axis to calculate total and perecent.total of each series category\n\n\n    this.xAxis.processSeriesDataItems();\n    this.yAxis.processSeriesDataItems();\n    var xAxisId = this.xAxis.uid;\n    var yAxisId = this.yAxis.uid;\n\n    if (!working) {\n      if (this._tmin.getKey(xAxisId) != minX || this._tmax.getKey(xAxisId) != maxX || this._tmin.getKey(yAxisId) != minY || this._tmax.getKey(yAxisId) != maxY) {\n        this._tmin.setKey(xAxisId, minX);\n\n        this._tmax.setKey(xAxisId, maxX);\n\n        this._tmin.setKey(yAxisId, minY);\n\n        this._tmax.setKey(yAxisId, maxY);\n\n        if (this.stackedSeries) {\n          this.stackedSeries.processValues(false);\n        }\n\n        this.dispatchImmediately(\"extremeschanged\");\n      }\n    }\n\n    if (this._smin.getKey(xAxisId) != minX || this._smax.getKey(xAxisId) != maxX || this._smin.getKey(yAxisId) != minY || this._smax.getKey(yAxisId) != maxY) {\n      this._smin.setKey(xAxisId, minX);\n\n      this._smax.setKey(xAxisId, maxX);\n\n      this._smin.setKey(yAxisId, minY);\n\n      this._smax.setKey(yAxisId, maxY);\n\n      if (this.appeared || this.start != 0 || this.end != 1) {\n        this.dispatchImmediately(\"selectionextremeschanged\");\n      }\n    }\n\n    if (!working && this.stacked) {\n      this.processValues(true);\n    }\n  };\n  /**\n   * Hides element's [[Tooltip]].\n   *\n   * @see {@link Tooltip}\n   */\n\n\n  XYSeries.prototype.hideTooltip = function () {\n    _super.prototype.hideTooltip.call(this);\n\n    this.returnBulletDefaultState();\n    this._prevTooltipDataItem = undefined;\n  };\n  /**\n   * Shows series tooltip at specific position.\n   *\n   * @param xPosition  X\n   * @param yPosition  Y\n   */\n\n\n  XYSeries.prototype.showTooltipAtPosition = function (xPosition, yPosition) {\n    var dataItem;\n\n    if (this.visible && !this.isHiding && !this.isShowing) {\n      var xAxis = this._xAxis.get();\n\n      var yAxis = this._yAxis.get();\n\n      if (xAxis == this.baseAxis) {\n        dataItem = xAxis.getSeriesDataItem(this, xAxis.toAxisPosition(xPosition), this.snapTooltip);\n      }\n\n      if (yAxis == this.baseAxis) {\n        dataItem = yAxis.getSeriesDataItem(this, yAxis.toAxisPosition(yPosition), this.snapTooltip);\n      }\n\n      var point = this.showTooltipAtDataItem(dataItem);\n\n      if (point) {\n        return point;\n      } // so that if tooltip is shown on columns or bullets for it not to be hidden\n\n\n      if (!this.tooltipText) {\n        return;\n      }\n    }\n\n    this.hideTooltip();\n  };\n  /**\n   * Shows series tooltip at specific dataItem.\n   *\n   * @param dataItem\n   */\n\n\n  XYSeries.prototype.showTooltipAtDataItem = function (dataItem) {\n    this.returnBulletDefaultState(dataItem);\n\n    if (dataItem && dataItem.visible) {\n      this.updateLegendValue(dataItem);\n\n      if (this.cursorTooltipEnabled) {\n        this.tooltipDataItem = dataItem; // todo: add tooltipXField and tooltipYField.\n\n        var tooltipXField = this.tooltipXField;\n        var tooltipYField = this.tooltipYField;\n\n        if ($type.hasValue(dataItem[tooltipXField]) && $type.hasValue(dataItem[tooltipYField])) {\n          var tooltipPoint = this.getPoint(dataItem, tooltipXField, tooltipYField, dataItem.locations[tooltipXField], dataItem.locations[tooltipYField]);\n\n          if (tooltipPoint) {\n            this.tooltipX = tooltipPoint.x;\n            this.tooltipY = tooltipPoint.y;\n\n            if (this._prevTooltipDataItem != dataItem) {\n              this.dispatchImmediately(\"tooltipshownat\", {\n                type: \"tooltipshownat\",\n                target: this,\n                dataItem: dataItem\n              });\n              this._prevTooltipDataItem = dataItem;\n            }\n\n            if (this.cursorHoverEnabled) {\n              try {\n                for (var _a = tslib_1.__values(dataItem.sprites), _b = _a.next(); !_b.done; _b = _a.next()) {\n                  var sprite = _b.value;\n\n                  if (!sprite.parent.visible || sprite.isHidden || sprite.__disabled || sprite.disabled || sprite.isHiding) {} else {\n                    sprite.isHover = true;\n                  }\n                }\n              } catch (e_1_1) {\n                e_1 = {\n                  error: e_1_1\n                };\n              } finally {\n                try {\n                  if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n                } finally {\n                  if (e_1) throw e_1.error;\n                }\n              }\n            }\n\n            if (this.showTooltip()) {\n              return $utils.spritePointToSvg({\n                x: tooltipPoint.x,\n                y: tooltipPoint.y\n              }, this);\n            }\n\n            return;\n          }\n        }\n      }\n    }\n\n    var e_1, _c;\n  };\n  /**\n   * returns default state to bullets when tooltip is shown at some other data item or hidden\n   *\n   * @ignore Exclude from docs\n   */\n\n\n  XYSeries.prototype.returnBulletDefaultState = function (dataItem) {\n    if (this._prevTooltipDataItem && this._prevTooltipDataItem != dataItem) {\n      try {\n        for (var _a = tslib_1.__values(this._prevTooltipDataItem.sprites), _b = _a.next(); !_b.done; _b = _a.next()) {\n          var sprite = _b.value;\n\n          if (!sprite.isDisposed()) {\n            sprite.isHover = false;\n          } else {\n            this._prevTooltipDataItem = undefined;\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n\n    var e_2, _c;\n  };\n\n  XYSeries.prototype.shouldCreateBullet = function (dataItem, bulletTemplate) {\n    // use series xField/yField if bullet doesn't have fields set\n    var xField = bulletTemplate.xField;\n\n    if (!$type.hasValue(xField)) {\n      xField = this.xField;\n    }\n\n    var yField = bulletTemplate.yField;\n\n    if (!$type.hasValue(yField)) {\n      yField = this.yField;\n    }\n\n    if (this.xAxis instanceof ValueAxis && !dataItem.hasValue([xField]) || this.yAxis instanceof ValueAxis && !dataItem.hasValue([yField])) {\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Positions series bullet.\n   *\n   * @ignore Exclude from docs\n   * @param bullet  Bullet\n   */\n\n\n  XYSeries.prototype.positionBullet = function (bullet) {\n    _super.prototype.positionBullet.call(this, bullet);\n\n    var dataItem = bullet.dataItem; // use series xField/yField if bullet doesn't have fields set\n\n    var xField = bullet.xField;\n\n    if (!$type.hasValue(xField)) {\n      xField = this.xField;\n    }\n\n    var yField = bullet.yField;\n\n    if (!$type.hasValue(yField)) {\n      yField = this.yField;\n    }\n\n    if (this.xAxis instanceof ValueAxis && !dataItem.hasValue([xField]) || this.yAxis instanceof ValueAxis && !dataItem.hasValue([yField])) {\n      bullet.visible = false;\n    } else {\n      var bulletLocationX = this.getBulletLocationX(bullet, xField);\n      var bulletLocationY = this.getBulletLocationY(bullet, yField);\n      var point = this.getPoint(dataItem, xField, yField, bulletLocationX, bulletLocationY);\n\n      if (point) {\n        var x = point.x;\n        var y = point.y;\n\n        if ($type.isNumber(bullet.locationX) && this.xOpenField != this.xField) {\n          var openX = this.xAxis.getX(dataItem, this.xOpenField);\n          x = x - (x - openX) * bullet.locationX;\n        }\n\n        if ($type.isNumber(bullet.locationY) && this.yOpenField != this.yField) {\n          var openY = this.yAxis.getY(dataItem, this.yOpenField);\n          y = y - (y - openY) * bullet.locationY;\n        }\n\n        bullet.moveTo({\n          x: x,\n          y: y\n        });\n        bullet.visible = true;\n      } else {\n        bullet.visible = false;\n      }\n    }\n  };\n  /**\n  * returns bullet x location\n  * @ignore\n  */\n\n\n  XYSeries.prototype.getBulletLocationX = function (bullet, field) {\n    var bulletLocation = bullet.locationX;\n    var dataItem = bullet.dataItem;\n\n    if (!$type.isNumber(bulletLocation)) {\n      bulletLocation = dataItem.workingLocations[field];\n    }\n\n    return bulletLocation;\n  };\n  /**\n  * returns bullet x location\n  * @ignore\n  */\n\n\n  XYSeries.prototype.getBulletLocationY = function (bullet, field) {\n    var bulletLocation = bullet.locationY;\n    var dataItem = bullet.dataItem;\n\n    if (!$type.isNumber(bulletLocation)) {\n      bulletLocation = dataItem.workingLocations[field];\n    }\n\n    return bulletLocation;\n  };\n\n  Object.defineProperty(XYSeries.prototype, \"stacked\", {\n    /**\n     * @return Can be stacked?\n     */\n    get: function get() {\n      return this.getPropertyValue(\"stacked\");\n    },\n\n    /**\n     * Can items from this series be included into stacks?\n     *\n     * Note: proper stacking is only possible if series have the same number\n     * of data items. To ensure this, don't set data directly on series\n     * but do this on chart instead.\n     *\n     * @default false\n     * @param stacked  Can be stacked?\n     */\n    set: function set(stacked) {\n      this.setPropertyValue(\"stacked\", stacked, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeries.prototype, \"snapTooltip\", {\n    /**\n     * @return Should snap?\n     */\n    get: function get() {\n      return this.getPropertyValue(\"snapTooltip\");\n    },\n\n    /**\n     * Should the nearest tooltip be shown if no data item is found on the\n     * current cursor position?\n     *\n     * @default false\n     * @param value  Should snap?\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"snapTooltip\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Shows hidden series.\n   *\n   * @param duration  Duration of reveal animation (ms)\n   * @return Animation\n   */\n\n  XYSeries.prototype.show = function (duration) {\n    var _this = this;\n\n    var fields;\n\n    if (this.xAxis instanceof ValueAxis && this.xAxis != this.baseAxis) {\n      fields = this._xValueFields;\n    }\n\n    if (this.yAxis instanceof ValueAxis && this.yAxis != this.baseAxis) {\n      fields = this._yValueFields;\n    }\n\n    var startIndex = this.startIndex;\n    var endIndex = this.endIndex;\n    var delay = 0;\n    var interpolationDuration = this.defaultState.transitionDuration;\n\n    if ($type.isNumber(duration)) {\n      interpolationDuration = duration;\n    }\n\n    var anim;\n    $iter.each($iter.indexed(this.dataItems.iterator()), function (a) {\n      var i = a[0];\n      var dataItem = a[1];\n\n      if (_this.sequencedInterpolation && interpolationDuration > 0) {\n        delay = _this.sequencedInterpolationDelay * i + interpolationDuration * (i - startIndex) / (endIndex - startIndex);\n      }\n\n      anim = dataItem.show(interpolationDuration, delay, fields);\n    });\n\n    var animation = _super.prototype.show.call(this, duration);\n\n    if (anim && !anim.isFinished()) {\n      animation = anim;\n    }\n\n    return animation;\n  };\n  /**\n   * Hides series.\n   *\n   * @param duration  Duration of hiding animation (ms)\n   * @return Animation\n   */\n\n\n  XYSeries.prototype.hide = function (duration) {\n    var _this = this;\n\n    var fields;\n    var value;\n    var xAxis = this.xAxis;\n\n    if (xAxis instanceof ValueAxis && xAxis != this.baseAxis) {\n      fields = this._xValueFields; // animate to zero if 0 is within zoomMin/zoomMax\n\n      if (this.stacked || xAxis.minZoomed < 0 && xAxis.maxZoomed > 0 || this.stackedSeries) {\n        value = 0;\n      } else {\n        value = xAxis.min;\n      }\n    }\n\n    var yAxis = this.yAxis;\n\n    if (yAxis instanceof ValueAxis && yAxis != this.baseAxis) {\n      fields = this._yValueFields; // animate to zero if 0 is within zoomMin/zoomMax\n\n      if (this.stacked || yAxis.minZoomed < 0 && yAxis.maxZoomed > 0 || this.stackedSeries) {\n        value = 0;\n      } else {\n        value = yAxis.min;\n      }\n    } //if ($type.hasValue(fields)) {\n\n\n    var startIndex = this.startIndex;\n    var endIndex = this.endIndex;\n    var interpolationDuration = this.hiddenState.transitionDuration;\n\n    if ($type.isNumber(duration)) {\n      interpolationDuration = duration;\n    }\n\n    var delay = 0;\n    var anim;\n    $iter.each($iter.indexed(this.dataItems.iterator()), function (a) {\n      var i = a[0];\n      var dataItem = a[1];\n\n      if (interpolationDuration == 0) {\n        dataItem.hide(0, 0, value, fields);\n      } else {\n        if (_this.sequencedInterpolation && interpolationDuration > 0) {\n          delay = _this.sequencedInterpolationDelay * i + interpolationDuration * (i - startIndex) / (endIndex - startIndex);\n        }\n\n        anim = dataItem.hide(interpolationDuration, delay, value, fields);\n      }\n    });\n\n    var animation = _super.prototype.hide.call(this, interpolationDuration);\n\n    if (animation && !animation.isFinished()) {\n      animation.delay(delay);\n    }\n\n    if (anim && !anim.isFinished()) {\n      animation = anim;\n    } // helps to avoid flicker. otherwise columns will show up at full size and only on next frame will animate from 0\n\n\n    this.validateDataElements(); //}\n\n    return animation;\n  };\n  /**\n   * [handleDataItemWorkingValueChange description]\n   *\n   * @ignore Exclude from docs\n   */\n\n\n  XYSeries.prototype.handleDataItemWorkingValueChange = function (dataItem, name) {\n    _super.prototype.handleDataItemWorkingValueChange.call(this, dataItem, name); // to calculate stack values\n\n\n    var axisSeries = this.baseAxis.series;\n    $iter.each(axisSeries.iterator(), function (series) {\n      if (series.stacked) {\n        series.invalidateProcessedData();\n      }\n    });\n  };\n  /**\n   * [getStackValue description]\n   *\n   * @ignore Exclude from docs\n   * @todo Description\n   * @param dataItem  Data item\n   */\n\n\n  XYSeries.prototype.getStackValue = function (dataItem, working) {\n    // todo: here wer stack x and y values only. question is - what should we do with other values, like openX, openY?\n    // if this series is not stacked or new stack begins, return.\n    var _this = this;\n\n    if (!this.stacked) {\n      return;\n    } else {\n      // it might seem that it's better to go through base axis series, but we do not maintain the same order as in chart.series there.\n      var chart = this.chart;\n      var index = chart.series.indexOf(this);\n      var field_1;\n\n      if (this.xAxis != this.baseAxis && this.xAxis instanceof ValueAxis) {\n        field_1 = this.xField;\n      }\n\n      if (this.yAxis != this.baseAxis && this.yAxis instanceof ValueAxis) {\n        field_1 = this.yField;\n      } //this is good for removing series, otherwise stack values will remain the same and chart won't pay atention when adding/removing series\n\n\n      dataItem.setCalculatedValue(field_1, 0, \"stack\");\n      $iter.eachContinue(chart.series.range(0, index).backwards().iterator(), function (prevSeries) {\n        // stacking is only possible if both axes are the same\n        if (prevSeries.xAxis == _this.xAxis && prevSeries.yAxis == _this.yAxis) {\n          // saving value\n          prevSeries.stackedSeries = _this;\n          var prevDataItem = prevSeries.dataItems.getIndex(dataItem.index); // indexes should match\n\n          if (prevDataItem && prevDataItem.hasValue(_this._xValueFields) && prevDataItem.hasValue(_this._yValueFields)) {\n            var value = dataItem.getValue(field_1);\n            var prevValue = void 0;\n\n            if (working) {\n              prevValue = prevDataItem.getWorkingValue(field_1) + prevDataItem.getValue(field_1, \"stack\");\n            } else {\n              prevValue = prevDataItem.getValue(field_1) + prevDataItem.getValue(field_1, \"stack\");\n            }\n\n            if (value >= 0 && prevValue >= 0 || value < 0 && prevValue < 0) {\n              //dataItem.events.disable();\n              dataItem.setCalculatedValue(field_1, prevValue, \"stack\"); //dataItem.events.enable();\n\n              return false;\n            }\n          } else if (!prevSeries.stacked) {\n            return false;\n          }\n        }\n\n        return true;\n      });\n    }\n  };\n\n  Object.defineProperty(XYSeries.prototype, \"xField\", {\n    /**\n     * [xField description]\n     *\n     * @ignore Exclude from docs\n     * @todo Description\n     * @return [description]\n     */\n    get: function get() {\n      return this._xField;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeries.prototype, \"yField\", {\n    /**\n     * [yField description]\n     *\n     * @ignore Exclude from docs\n     * @todo Description\n     * @return [description]\n     */\n    get: function get() {\n      return this._yField;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeries.prototype, \"xOpenField\", {\n    /**\n     * [xOpenField description]\n     *\n     * @ignore Exclude from docs\n     * @todo Description\n     * @return [description]\n     */\n    get: function get() {\n      return this._xOpenField;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeries.prototype, \"yOpenField\", {\n    /**\n     * [yOpenField description]\n     *\n     * @ignore Exclude from docs\n     * @todo Description\n     * @return [description]\n     */\n    get: function get() {\n      return this._yOpenField;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeries.prototype, \"tooltipXField\", {\n    /**\n     * @ignore Exclude from docs\n     * @todo Description\n     * @return [description]\n     */\n    get: function get() {\n      if (this._tooltipXField) {\n        return this._tooltipXField;\n      }\n\n      return this._xField;\n    },\n\n    /**\n     * [tooltipXField description]\n     *\n     * @ignore Exclude from docs\n     * @todo Description\n     * @param value [description]\n     */\n    set: function set(value) {\n      this._tooltipXField = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeries.prototype, \"tooltipYField\", {\n    /**\n     * @ignore Exclude from docs\n     * @todo Description\n     * @return [description]\n     */\n    get: function get() {\n      if (this._tooltipYField) {\n        return this._tooltipYField;\n      }\n\n      return this._yField;\n    },\n\n    /**\n     * [tooltipYField description]\n     *\n     * @ignore Exclude from docs\n     * @todo Description\n     * @param value [description]\n     */\n    set: function set(value) {\n      this._tooltipYField = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Returns lowest value in the series for the specific axis.\n   *\n   * @ignore Exclude from docs\n   * @param axis  Axis\n   * @return value\n   */\n\n  XYSeries.prototype.min = function (axis) {\n    return this._tmin.getKey(axis.uid);\n  };\n  /**\n   * Returns highest value in the series for the specific axis.\n   *\n   * @ignore Exclude from docs\n   * @param axis  Axis\n   * @return value\n   */\n\n\n  XYSeries.prototype.max = function (axis) {\n    return this._tmax.getKey(axis.uid);\n  };\n  /**\n   * Returns lowest value in the series for the specific axis within current\n   * selection.\n   *\n   * @ignore Exclude from docs\n   * @param axis  Axis\n   * @return value\n   */\n\n\n  XYSeries.prototype.selectionMin = function (axis) {\n    var value = this._smin.getKey(axis.uid);\n\n    if (!$type.isNumber(value)) {\n      value = this.min(axis);\n    }\n\n    return value;\n  };\n  /**\n   * Returns highest value in the series for the specific axis within current\n   * selection.\n   *\n   * @ignore Exclude from docs\n   * @param axis  Axis\n   * @return value\n   */\n\n\n  XYSeries.prototype.selectionMax = function (axis) {\n    var value = this._smax.getKey(axis.uid);\n\n    if (!$type.isNumber(value)) {\n      value = this.max(axis);\n    }\n\n    return value;\n  };\n  /**\n   * Processes JSON-based config before it is applied to the object.\n   *\n   * @ignore Exclude from docs\n   * @param config  Config\n   */\n\n\n  XYSeries.prototype.processConfig = function (config) {\n    if (config) {\n      // Set up axes\n      if ($type.hasValue(config.xAxis) && $type.isString(config.xAxis)) {\n        if (this.map.hasKey(config.xAxis)) {\n          config.xAxis = this.map.getKey(config.xAxis);\n        } else {\n          this.processingErrors.push(\"[XYSeries (\" + (this.name || \"unnamed\") + \")] No axis with id \\\"\" + config.xAxis + \"\\\" found for `xAxis`.\");\n          delete config.xAxis;\n        }\n      }\n\n      if ($type.hasValue(config.yAxis) && $type.isString(config.yAxis)) {\n        if (this.map.hasKey(config.yAxis)) {\n          config.yAxis = this.map.getKey(config.yAxis);\n        } else {\n          this.processingErrors.push(\"[XYSeries (\" + (this.name || \"unnamed\") + \")] No axis with id \\\"\" + config.yAxis + \"\\\" found for `yAxis`.\");\n          delete config.yAxis;\n        }\n      } // Set up axis ranges\n\n\n      if ($type.hasValue(config.axisRanges) && $type.isArray(config.axisRanges)) {\n        for (var i = 0, len = config.axisRanges.length; i < len; i++) {\n          var range = config.axisRanges[i];\n\n          if (!$type.hasValue(range.type)) {\n            range.type = \"AxisDataItem\";\n          }\n\n          if ($type.hasValue(range.axis) && $type.isString(range.axis) && this.map.hasKey(range.axis)) {\n            range.component = this.map.getKey(range.axis);\n          } else if ($type.hasValue(range.component) && $type.isString(range.component) && this.map.hasKey(range.component)) {\n            range.component = this.map.getKey(range.component);\n          }\n        }\n      } // Parse date fields based on the series fields\n\n\n      if (!$type.hasValue(config.dataFields) || !$type.isObject(config.dataFields)) {\n        this.processingErrors.push(\"`dataFields` is not set for series [\" + (this.name || \"unnamed\") + \"]\");\n      }\n    }\n\n    _super.prototype.processConfig.call(this, config);\n  };\n  /**\n   * Returns an [[IPoint]] coordinates of the specific Serie's data point.\n   *\n   * @param    dataItem   Data item\n   * @param    xKey       Name of X data field\n   * @param    yKey       Name of Y data field\n   * @param    locationX  X location\n   * @param    locationY  Y location\n   * @param    stackKeyX  ?\n   * @param    stackKeyY  ?\n   * @returns             Coordinates\n   */\n\n\n  XYSeries.prototype.getPoint = function (dataItem, xKey, yKey, locationX, locationY, stackKeyX, stackKeyY) {\n    var x = this.xAxis.getX(dataItem, xKey, locationX);\n    var y = this.yAxis.getY(dataItem, yKey, locationY);\n    x = $math.fitToRange(x, -20000, 20000); // from geometric point of view this is not right, but practically it's ok. this is done to avoid too big objects.\n\n    y = $math.fitToRange(y, -20000, 20000); // from geometric point of view this is not right, but practically it's ok. this is done to avoid too big objects.\n\n    return {\n      x: x,\n      y: y\n    };\n  };\n  /**\n   * Updates item reader text based on the type and set up of axis.\n   */\n\n\n  XYSeries.prototype.updateItemReaderText = function () {\n    var text = \"\";\n    $object.each(this.dataFields, function (key, val) {\n      text += \"{\" + key + \"} \";\n    });\n    this.itemReaderText = text;\n  };\n\n  Object.defineProperty(XYSeries.prototype, \"cursorTooltipEnabled\", {\n    /**\n     * @return Display tooltip?\n     */\n    get: function get() {\n      return this.getPropertyValue(\"cursorTooltipEnabled\");\n    },\n\n    /**\n     * Indicates if series should display a tooltip for chart's cursor.\n     *\n     * If set to `true` (default), the tooltips set for all series item's\n     * elements like columns and bullets will be automatically shown\n     * when [[XYCursor]] passes over category/date, even if its not hovered\n     * directly over the item.\n     *\n     * Set this to `false` to disable such behavior and display item-specific\n     * tooltips only when hovered directly over them\n     *\n     * @default true\n     * @param value Display tooltip?\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"cursorTooltipEnabled\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(XYSeries.prototype, \"cursorHoverEnabled\", {\n    /**\n     * @return Hover enabled?\n     */\n    get: function get() {\n      return this.getPropertyValue(\"cursorHoverEnabled\");\n    },\n\n    /**\n     * Indicates if series should apply hover state on bullets/columns/etc when\n     * cursor is over the data item.\n     *\n     * If set to `true` (default) and chart cursor is enabled on th chart,\n     * hovering over date/category will trigger hover states on related Series\n     * items like bullets and columns.\n     *\n     * @default true\n     * @since 4.2.2\n     * @param  value  Hover enabled?\n     */\n    set: function set(value) {\n      this.setPropertyValue(\"cursorHoverEnabled\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return XYSeries;\n}(Series);\n\nexport { XYSeries };\n/**\n * Register class in system, so that it can be instantiated using its name from\n * anywhere.\n *\n * @ignore\n */\n\nregistry.registeredClasses[\"XYSeries\"] = XYSeries;\nregistry.registeredClasses[\"XYSeriesDataItem\"] = XYSeriesDataItem;","map":{"version":3,"sources":["../../../../../src/.internal/charts/series/XYSeries.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * XY series module.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Series, SeriesDataItem, ISeriesProperties, ISeriesDataFields, ISeriesAdapters, ISeriesEvents } from \"./Series\";\r\nimport { Sprite } from \"../../core/Sprite\";\r\nimport { Axis } from \"../axes/Axis\";\r\nimport { AxisRenderer } from \"../axes/AxisRenderer\";\r\nimport { ValueAxis } from \"../axes/ValueAxis\";\r\nimport { Dictionary } from \"../../core/utils/Dictionary\";\r\nimport { List } from \"../../core/utils/List\";\r\nimport { MutableValueDisposer } from \"../../core/utils/Disposer\";\r\nimport { XYChart } from \"../types/XYChart\";\r\nimport { CategoryAxis } from \"../axes/CategoryAxis\";\r\nimport { IPoint } from \"../../core/defs/IPoint\";\r\nimport { DateAxis } from \"../axes/DateAxis\";\r\nimport { Bullet } from \"../elements/Bullet\";\r\nimport { CalculatedValue } from \"../../core/Component\";\r\nimport { Animation } from \"../../core/utils/Animation\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $utils from \"../../core/utils/Utils\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $array from \"../../core/utils/Array\";\r\nimport * as $object from \"../../core/utils/Object\";\r\nimport * as $path from \"../../core/rendering/Path\";\r\nimport { ITimeInterval } from \"../../core/defs/ITimeInterval\";\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines a [[DataItem]] for [[XYSeries]].\r\n *\r\n * @see {@link DataItem}\r\n */\r\nexport class XYSeriesDataItem extends SeriesDataItem {\r\n\r\n\t/**\r\n\t * [_minX description]\r\n\t *\r\n\t * @todo Descripion\r\n\t */\r\n\tprotected _minX: number;\r\n\r\n\t/**\r\n\t * [_maxX description]\r\n\t *\r\n\t * @todo Descripion\r\n\t */\r\n\tprotected _maxX: number;\r\n\r\n\t/**\r\n\t * [_minY description]\r\n\t *\r\n\t * @todo Descripion\r\n\t */\r\n\tprotected _minY: number;\r\n\r\n\t/**\r\n\t * [_maxY description]\r\n\t *\r\n\t * @todo Descripion\r\n\t */\r\n\tprotected _maxY: number;\r\n\r\n\t/**\r\n\t * Defines a type of [[Component]] this data item is used for.\r\n\t */\r\n\tpublic _component!: XYSeries;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\r\n\t\tthis.className = \"XYSeriesDataItem\";\r\n\r\n\t\tthis.values.valueX = { stack: 0 };\r\n\t\tthis.values.valueY = { stack: 0 };\r\n\t\tthis.values.openValueX = {};\r\n\t\tthis.values.openValueY = {};\r\n\r\n\t\tthis.values.dateX = {};\r\n\t\tthis.values.dateY = {};\r\n\t\tthis.values.openDateX = {};\r\n\t\tthis.values.openDateY = {};\r\n\r\n\t\tthis.setLocation(\"dateX\", 0.5, 0);\r\n\t\tthis.setLocation(\"dateY\", 0.5, 0);\r\n\r\n\t\tthis.setLocation(\"categoryX\", 0.5, 0);\r\n\t\tthis.setLocation(\"categoryY\", 0.5, 0);\r\n\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Item's numeric value on X value axis.\r\n\t *\r\n\t * @param value  Value\r\n\t */\r\n\tpublic set valueX(value: number) {\r\n\t\tthis.setValue(\"valueX\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Value\r\n\t */\r\n\tpublic get valueX(): number {\r\n\t\treturn this.values.valueX.value;\r\n\t}\r\n\r\n\t/**\r\n\t * Item's numeric value on Y value axis.\r\n\t *\r\n\t * @param value  Value\r\n\t */\r\n\tpublic set valueY(value: number) {\r\n\t\tthis.setValue(\"valueY\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Value\r\n\t */\r\n\tpublic get valueY(): number {\r\n\t\treturn this.values.valueY.value;\r\n\t}\r\n\r\n\t/**\r\n\t * Item's date value on X date-based axis.\r\n\t *\r\n\t * @param date  Date\r\n\t */\r\n\tpublic set dateX(date: Date) {\r\n\t\tthis.setDate(\"dateX\", date);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Date\r\n\t */\r\n\tpublic get dateX(): Date {\r\n\t\treturn this.getDate(\"dateX\");\r\n\t}\r\n\r\n\t/**\r\n\t * Item's date value on Y date-based axis.\r\n\t *\r\n\t * @param date  Date\r\n\t */\r\n\tpublic set dateY(date: Date) {\r\n\t\tthis.setDate(\"dateY\", date);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Date\r\n\t */\r\n\tpublic get dateY(): Date {\r\n\t\treturn this.getDate(\"dateY\");\r\n\t}\r\n\r\n\t/**\r\n\t * Item's category on X category axis.\r\n\t *\r\n\t * @param category  Category\r\n\t */\r\n\tpublic set categoryX(category: string) {\r\n\t\tthis.setCategory(\"categoryX\", category);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Category\r\n\t */\r\n\tpublic get categoryX(): string {\r\n\t\treturn this.categories.categoryX;\r\n\t}\r\n\r\n\t/**\r\n\t * Item's category on Y category axis.\r\n\t *\r\n\t * @param category  Category\r\n\t */\r\n\tpublic set categoryY(category: string) {\r\n\t\tthis.setCategory(\"categoryY\", category);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Category\r\n\t */\r\n\tpublic get categoryY(): string {\r\n\t\treturn this.categories.categoryY;\r\n\t}\r\n\r\n\t/**\r\n\t * Item's open numeric value on X value axis.\r\n\t *\r\n\t * @param value  Value\r\n\t */\r\n\tpublic set openValueX(value: number) {\r\n\t\tthis.setValue(\"openValueX\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Value\r\n\t */\r\n\tpublic get openValueX(): number {\r\n\t\treturn this.values.openValueX.value;\r\n\t}\r\n\r\n\t/**\r\n\t * Item's open numeric value on Y value axis.\r\n\t *\r\n\t * @param value  Value\r\n\t */\r\n\tpublic set openValueY(value: number) {\r\n\t\tthis.setValue(\"openValueY\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Value\r\n\t */\r\n\tpublic get openValueY(): number {\r\n\t\treturn this.values.openValueY.value;\r\n\t}\r\n\r\n\t/**\r\n\t * Item's open date value on X date-based axis.\r\n\t *\r\n\t * @param date  Date\r\n\t */\r\n\tpublic set openDateX(date: Date) {\r\n\t\tthis.setDate(\"openDateX\", date);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Date\r\n\t */\r\n\tpublic get openDateX(): Date {\r\n\t\treturn this.getDate(\"openDateX\");\r\n\t}\r\n\r\n\t/**\r\n\t * Item's open date value on Y date-based axis.\r\n\t *\r\n\t * @param date  Date\r\n\t */\r\n\tpublic set openDateY(date: Date) {\r\n\t\tthis.setDate(\"openDateY\", date);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Date\r\n\t */\r\n\tpublic get openDateY(): Date {\r\n\t\treturn this.getDate(\"openDateY\");\r\n\t}\r\n\r\n\t/**\r\n\t * Item's open category on X category axis.\r\n\t *\r\n\t * @param category  Category\r\n\t */\r\n\tpublic set openCategoryX(category: string) {\r\n\t\tthis.setProperty(\"openCategoryX\", category);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Category\r\n\t */\r\n\tpublic get openCategoryX(): string {\r\n\t\treturn this.categories.openCategoryX;\r\n\t}\r\n\r\n\t/**\r\n\t * Item's open category on Y category axis.\r\n\t *\r\n\t * @param category  Category\r\n\t */\r\n\tpublic set openCategoryY(category: string) {\r\n\t\tthis.setProperty(\"openCategoryY\", category);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Category\r\n\t */\r\n\tpublic get openCategoryY(): string {\r\n\t\treturn this.categories.openCategoryY;\r\n\t}\r\n\r\n\t/**\r\n\t * Return smallest value out of all item's value fields.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param fields      Fields to check in\r\n\t * @param working     Include working (temporary) values\r\n\t * @param stackValue  If item is in a stack, the value item starts as\r\n\t * @return Value\r\n\t */\r\n\tpublic getMin(fields: string[], working?: boolean, stackValue?: number): number {\r\n\t\t//if (this.visible) {  // dumped because of non smooth zooming\r\n\t\tlet min: number;\r\n\r\n\t\tif (!$type.isNumber(stackValue)) {\r\n\t\t\tstackValue = 0;\r\n\t\t}\r\n\r\n\t\t$array.each(fields, (field) => {\r\n\t\t\tlet value: number;\r\n\r\n\t\t\tif (working) {\r\n\t\t\t\tvalue = this.getWorkingValue(field);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvalue = this.getValue(field);\r\n\t\t\t}\r\n\r\n\t\t\tvalue += stackValue;\r\n\r\n\t\t\tif (value < min || !$type.isNumber(min)) {\r\n\t\t\t\tmin = value;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn min;\r\n\t\t//}\r\n\t}\r\n\r\n\t/**\r\n\t * Return biggest value out of all item's value fields.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param fields      Fields to check in\r\n\t * @param working     Include working (temporary) values\r\n\t * @param stackValue  If item is in a stack, the value item starts as\r\n\t * @return Value\r\n\t */\r\n\tpublic getMax(fields: string[], working?: boolean, stackValue?: number): number {\r\n\t\t//if (this.visible) { // dumped because of non smooth zooming\r\n\t\tlet max: number;\r\n\r\n\t\tif (!$type.isNumber(stackValue)) {\r\n\t\t\tstackValue = 0;\r\n\t\t}\r\n\r\n\t\t$array.each(fields, (field) => {\r\n\t\t\tlet value: number;\r\n\r\n\t\t\tif (working) {\r\n\t\t\t\tvalue = this.getWorkingValue(field);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvalue = this.getValue(field);\r\n\t\t\t}\r\n\r\n\t\t\tvalue += stackValue;\r\n\r\n\t\t\tif (value > max || !$type.isNumber(max)) {\r\n\t\t\t\tmax = value;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn max;\r\n\t\t//}\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * Defines property set for a [[XYSeries]] tooltip event that contains information about dataItem\r\n */\r\nexport type XYSeriesTooltipEvent = {\r\n\r\n\t/**\r\n\t * Shift in coordinates after dragging.\r\n\t */\r\n\tdataItem: XYSeriesDataItem;\r\n};\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines data fields for [[XYSeries]].\r\n */\r\nexport interface IXYSeriesDataFields extends ISeriesDataFields {\r\n\r\n\t/**\r\n\t * Name of the field in data that holds numeric value for horizontal axis.\r\n\t */\r\n\tvalueX?: string;\r\n\r\n\t/**\r\n\t * Name of the field in data that holds numeric value for vertical axis.\r\n\t */\r\n\tvalueY?: string;\r\n\r\n\t/**\r\n\t * Name of the field in data that holds category for horizontal axis.\r\n\t */\r\n\tcategoryX?: string;\r\n\r\n\t/**\r\n\t * Name of the field in data that holds category for vertical axis.\r\n\t */\r\n\tcategoryY?: string;\r\n\r\n\t/**\r\n\t * Name of the field in data that holds date for horizontal axis.\r\n\t */\r\n\tdateX?: string;\r\n\r\n\t/**\r\n\t * Name of the field in data that holds date for vertical axis.\r\n\t */\r\n\tdateY?: string;\r\n\r\n\t/**\r\n\t * Name of the field in data that holds open numeric value for horizontal\r\n\t * axis.\r\n\t */\r\n\topenValueX?: string;\r\n\r\n\t/**\r\n\t * Name of the field in data that holds open numeric value for vertical\r\n\t * axis.\r\n\t */\r\n\topenValueY?: string;\r\n\r\n\t/**\r\n\t * Name of the field in data that holds open category for horizontal axis.\r\n\t */\r\n\topenCategoryX?: string;\r\n\r\n\t/**\r\n\t * Name of the field in data that holds open category for vertical axis.\r\n\t */\r\n\topenCategoryY?: string;\r\n\r\n\t/**\r\n\t * Name of the field in data that holds open date for horizontal axis.\r\n\t */\r\n\topenDateX?: string;\r\n\r\n\t/**\r\n\t * Name of the field in data that holds open date for vertical axis.\r\n\t */\r\n\topenDateY?: string;\r\n\r\n\t/**\r\n\t * Which calculated field to use to use as a horizontal axis value for the\r\n\t * item.\r\n\t */\r\n\tvalueXShow?: CalculatedValue;\r\n\r\n\t/**\r\n\t * Which calculated field to use to use as a vertical axis value for the\r\n\t * item.\r\n\t */\r\n\tvalueYShow?: CalculatedValue;\r\n\r\n\t/**\r\n\t * Which calculated field to use to use as a horizontal axis open value for\r\n\t * the item.\r\n\t */\r\n\topenValueXShow?: CalculatedValue;\r\n\r\n\t/**\r\n\t * Which calculated field to use to use as a vertical axis open value for\r\n\t * the item.\r\n\t */\r\n\topenValueYShow?: CalculatedValue;\r\n\r\n}\r\n\r\n/**\r\n * Defines properties for [[XYSeries]].\r\n */\r\nexport interface IXYSeriesProperties extends ISeriesProperties {\r\n\r\n\t/**\r\n\t * Can items from this series be included into stacks?\r\n\t *\r\n\t * @default false\r\n\t */\r\n\tstacked?: boolean;\r\n\r\n\t/**\r\n\t * Should the nearest tooltip be shown if no data item is found on the\r\n\t * current cursor position\r\n\t *\r\n\t * @default false\r\n\t */\r\n\tsnapTooltip?: boolean;\r\n\r\n\t/**\r\n\t * Indicates if series should display a tooltip for chart's cursor.\r\n\t *\r\n\t * @default true\r\n\t */\r\n\tcursorTooltipEnabled?: boolean;\r\n\r\n\t/**\r\n\t * Indicates if series should apply hover state on bullets/columns/etc when\r\n\t * cursor is over the data item.\r\n\t * \r\n\t * @default true\r\n\t */\r\n\tcursorHoverEnabled?: boolean;\r\n}\r\n\r\n/**\r\n * Defines events for [[XYSeries]].\r\n */\r\nexport interface IXYSeriesEvents extends ISeriesEvents {\r\n\t/**\r\n\t * Invoked when series tooltip was shown on some particular data item\r\n\t */\r\n\ttooltipshownat: XYSeriesTooltipEvent;\r\n}\r\n\r\n/**\r\n * Defines adapters for [[XYSeries]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IXYSeriesAdapters extends ISeriesAdapters, IXYSeriesProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines Series for [[XYChart]].\r\n *\r\n * @see {@link IXYSeriesEvents} for a list of available Events\r\n * @see {@link IXYSeriesAdapters} for a list of available Adapters\r\n * @todo Example\r\n * @important\r\n */\r\nexport class XYSeries extends Series {\r\n\r\n\t/**\r\n\t * Defines the type of data fields used for the series.\r\n\t */\r\n\tpublic _dataFields: IXYSeriesDataFields;\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IXYSeriesProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IXYSeriesAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IXYSeriesEvents;\r\n\r\n\t/**\r\n\t * Defines the type of data item.\r\n\t */\r\n\tpublic _dataItem: XYSeriesDataItem;\r\n\r\n\t/**\r\n\t * X axis the series is attached to.\r\n\t */\r\n\tprotected _xAxis = new MutableValueDisposer<Axis<AxisRenderer>>();\r\n\r\n\t/**\r\n\t * Y axis the series is attached to.\r\n\t */\r\n\tprotected _yAxis = new MutableValueDisposer<Axis<AxisRenderer>>();\r\n\r\n\t/**\r\n\t * A chart series belongs to.\r\n\t */\r\n\tpublic _chart: XYChart;\r\n\r\n\t/**\r\n\t * The main (base) axis.\r\n\t *\r\n\t * This is the axis that series fills will go to, or grow animations will\r\n\t * happen from.\r\n\t */\r\n\tprotected _baseAxis: Axis;\r\n\r\n\t/**\r\n\t * Total data item count.\r\n\t */\r\n\tprotected _count: Dictionary<string, number>;\r\n\r\n\t/**\r\n\t * Data item count in current selection.\r\n\t */\r\n\tprotected _scount: Dictionary<string, number>;\r\n\r\n\t/**\r\n\t * [_xField description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _xField: string;\r\n\r\n\t/**\r\n\t * [_yField description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _yField: string;\r\n\r\n\t/**\r\n\t * [_xOpenField description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _xOpenField: string;\r\n\r\n\t/**\r\n\t * [_yOpenField description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _yOpenField: string;\r\n\r\n\t/**\r\n\t * [_tooltipXField description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _tooltipXField: string;\r\n\r\n\t/**\r\n\t * [_tooltipYField description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _tooltipYField: string;\r\n\r\n\t/**\r\n\t * [_xValueFields description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _xValueFields: Array<string> = [];\r\n\r\n\t/**\r\n\t * [_yValueFields description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _yValueFields: Array<string> = [];\r\n\r\n\t/**\r\n\t * Series which is stacked on top of this series, if any.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic stackedSeries: XYSeries;\r\n\r\n\t/**\r\n\t * dataitem of previously shown tooltip, used to avoid multiple tooltipshownat dispatches\r\n\t * @ignore\r\n\t */\r\n\tprotected _prevTooltipDataItem: XYSeriesDataItem;\r\n\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic _baseInterval: { [index: string]: ITimeInterval } = {};\r\n\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"XYSeries\";\r\n\t\tthis.isMeasured = false;\r\n\r\n\t\tthis.cursorTooltipEnabled = true;\r\n\r\n\t\tthis.cursorHoverEnabled = true;\r\n\r\n\t\tthis.mainContainer.mask = new Sprite();\r\n\t\tthis.mainContainer.mask.setElement(this.paper.add(\"path\"));\r\n\r\n\t\tthis.stacked = false;\r\n\t\tthis.snapTooltip = false;\r\n\r\n\t\tthis.tooltip.pointerOrientation = \"horizontal\";\r\n\r\n\t\tthis.tooltip.events.on(\"hidden\", () => {\r\n\t\t\tthis.returnBulletDefaultState();\r\n\t\t}, undefined, false)\r\n\r\n\t\tthis._disposers.push(this._xAxis);\r\n\t\tthis._disposers.push(this._yAxis);\r\n\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Sets defaults that instantiate some objects that rely on parent, so they\r\n\t * cannot be set in constructor.\r\n\t */\r\n\tprotected applyInternalDefaults(): void {\r\n\t\tsuper.applyInternalDefaults();\r\n\t\tif (!$type.hasValue(this.readerTitle)) {\r\n\t\t\tthis.readerTitle = this.language.translate(\"X/Y Series\");\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty DataItem of the type appropriate for this object.\r\n\t *\r\n\t * @see {@link DataItem}\r\n\t * @return Data Item\r\n\t */\r\n\tprotected createDataItem(): this[\"_dataItem\"] {\r\n\t\treturn new XYSeriesDataItem();\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic dataChangeUpdate() {\r\n\t\tthis._tmin.clear();\r\n\t\tthis._tmax.clear();\r\n\r\n\t\tthis._smin.clear();\r\n\t\tthis._smax.clear();\r\n\r\n\r\n\t\tif (this.xAxis) {\r\n\t\t\tthis.xAxis.seriesDataChangeUpdate(this);\r\n\t\t}\r\n\r\n\t\tif (this.yAxis) {\r\n\t\t\tthis.yAxis.seriesDataChangeUpdate(this);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)validates the series' data.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validateData(): void {\r\n\t\tthis.defineFields();\r\n\r\n\t\tif (this.data.length > 0) {\r\n\t\t\tthis.dataChangeUpdate();\r\n\t\t}\r\n\r\n\t\tsuper.validateData();\r\n\r\n\t\tthis.updateItemReaderText();\r\n\r\n\t\tif (!$type.hasValue(this.dataFields[<keyof this[\"_dataFields\"]>this._xField]) || !$type.hasValue(this.dataFields[<keyof this[\"_dataFields\"]>this._yField])) {\r\n\t\t\tthrow Error(\"Data fields for series \\\"\" + (this.name ? this.name : this.uid) + \"\\\" are not properly defined.\");\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Processes data item.\r\n\t *\r\n\t * @param dataItem     Data item\r\n\t * @param dataContext  Raw data\r\n\t * @param index        Index of the data item\r\n\t */\r\n\tprotected processDataItem(dataItem: this[\"_dataItem\"], dataContext?: Object): void {\r\n\t\ttry {\r\n\t\t\tsuper.processDataItem(dataItem, dataContext);\r\n\r\n\t\t\tdataItem.events.disable();\r\n\t\t\tthis.xAxis.processSeriesDataItem(dataItem, \"X\");\r\n\t\t\tthis.yAxis.processSeriesDataItem(dataItem, \"Y\");\r\n\t\t\tdataItem.events.enable();\r\n\r\n\t\t\tthis.setInitialWorkingValues(dataItem);\r\n\t\t}\r\n\t\tcatch (e) {\r\n\t\t\tthis._chart.raiseCriticalError(e);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * When validating raw data, instead of processing data item, we update it\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param item\r\n\t */\r\n\tprotected updateDataItem(dataItem: this[\"_dataItem\"]): void {\r\n\t\tsuper.updateDataItem(dataItem);\r\n\t\t\r\n\t\t//dataItem.events.disable();\r\n\t\tthis.xAxis.processSeriesDataItem(dataItem, \"X\");\r\n\t\tthis.yAxis.processSeriesDataItem(dataItem, \"Y\");\r\n\t\t//dataItem.events.enable();\t\t\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Inits data item's working values.\r\n\t *\r\n\t * @param dataItem  Data item\r\n\t * @param index     Data item's index\r\n\t */\r\n\r\n\tprotected setInitialWorkingValues(dataItem: this[\"_dataItem\"]): void {\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic disposeData() {\r\n\t\tsuper.disposeData();\r\n\t\tif (this.xAxis) {\r\n\t\t\tlet dataItemsX = this.dataItemsByAxis.getKey(this.xAxis.uid);\r\n\t\t\tif (dataItemsX) {\r\n\t\t\t\tdataItemsX.clear();\r\n\t\t\t}\r\n\t\t\tif(this.xAxis instanceof CategoryAxis){\r\n\t\t\t\tthis.clearCatAxis(this.xAxis);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (this.yAxis) {\r\n\t\t\tlet dataItemsY = this.dataItemsByAxis.getKey(this.yAxis.uid);\r\n\t\t\tif (dataItemsY) {\r\n\t\t\t\tdataItemsY.clear();\r\n\t\t\t}\r\n\t\t\tif(this.yAxis instanceof CategoryAxis){\r\n\t\t\t\tthis.clearCatAxis(this.yAxis);\r\n\t\t\t}\t\t\t\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected clearCatAxis(axis:CategoryAxis){\r\n\t\tlet uid = this.uid;\r\n\t\taxis.dataItems.each((dataItem)=>{\r\n\t\t\tif(dataItem.seriesDataItems[uid]){\r\n\t\t\t\tdataItem.seriesDataItems[uid] = [];\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Sets up which data fields to use for data access.\r\n\t */\r\n\tprotected defineFields() {\r\n\t\tlet xAxis: Axis = this.xAxis;\r\n\t\tlet yAxis: Axis = this.yAxis;\r\n\r\n\t\tlet xAxisFieldName: string = xAxis.axisFieldName;\r\n\t\tlet xField: $type.Keyof<this[\"_dataFields\"]> = <$type.Keyof<this[\"_dataFields\"]>>(xAxisFieldName + \"X\");\r\n\t\tlet xOpenField: $type.Keyof<this[\"_dataFields\"]> = <$type.Keyof<this[\"_dataFields\"]>>(\"open\" + $utils.capitalize(xAxisFieldName) + \"X\");\r\n\r\n\t\tlet yAxisFieldName: string = yAxis.axisFieldName;\r\n\t\tlet yField: $type.Keyof<this[\"_dataFields\"]> = <$type.Keyof<this[\"_dataFields\"]>>(yAxisFieldName + \"Y\");\r\n\t\tlet yOpenField: $type.Keyof<this[\"_dataFields\"]> = <$type.Keyof<this[\"_dataFields\"]>>(\"open\" + $utils.capitalize(yAxisFieldName) + \"Y\");\r\n\r\n\t\tthis._xField = xField;\r\n\t\tthis._yField = yField;\r\n\r\n\t\tif (this.dataFields[xOpenField]) {\r\n\t\t\tthis._xOpenField = xOpenField;\r\n\t\t}\r\n\r\n\t\tif (this.dataFields[yOpenField]) {\r\n\t\t\tthis._yOpenField = yOpenField;\r\n\t\t}\r\n\r\n\t\tif (!this.dataFields[yOpenField] && this.baseAxis == this.yAxis) {\r\n\t\t\tthis._yOpenField = yField;\r\n\t\t}\r\n\r\n\t\tif (!this.dataFields[xOpenField] && this.baseAxis == this.xAxis) {\r\n\t\t\tthis._xOpenField = xField;\r\n\t\t}\r\n\r\n\t\tif (this.stacked && this.baseAxis == this.xAxis) {\r\n\t\t\tthis._xOpenField = xField;\r\n\t\t}\r\n\r\n\t\tif (this.stacked && this.baseAxis == this.yAxis) {\r\n\t\t\tthis._yOpenField = yField;\r\n\t\t}\r\n\r\n\t\tif ((this.xAxis instanceof CategoryAxis) && (this.yAxis instanceof CategoryAxis)) {\r\n\t\t\tif (!this._yOpenField) {\r\n\t\t\t\tthis._yOpenField = yField;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._xValueFields = [];\r\n\t\tthis._yValueFields = [];\r\n\r\n\t\tthis.addValueField(this.xAxis, <any>this._xValueFields, <any>this._xField);\r\n\t\tthis.addValueField(this.xAxis, <any>this._xValueFields, <any>this._xOpenField);\r\n\r\n\t\tthis.addValueField(this.yAxis, <any>this._yValueFields, <any>this._yField);\r\n\t\tthis.addValueField(this.yAxis, <any>this._yValueFields, <any>this._yOpenField);\r\n\t}\r\n\r\n\t/**\r\n\t * [axis description]\r\n\t *\r\n\t * @todo Description\r\n\t * @param axis    Axis\r\n\t * @param fields  Fields (?)\r\n\t * @param field   Field\r\n\t */\r\n\tprotected addValueField<Key extends keyof this[\"_dataFields\"]>(axis: Axis, fields: Array<Key>, field: Key): void {\r\n\t\tif (axis instanceof ValueAxis) {\r\n\t\t\tif ($type.hasValue(this.dataFields[field]) && fields.indexOf(field) == -1) {\r\n\t\t\t\tfields.push(field);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sets category field from the category axis.\r\n\t *\r\n\t * User might set field for category axis only, but not for series. In such\r\n\t * case, we take field value from axis and set it for series.\r\n\t *\r\n\t * @param field  Field\r\n\t * @param axis   Axis\r\n\t */\r\n\tprotected setCategoryAxisField<Key extends keyof this[\"_dataFields\"]>(field: Key, axis: CategoryAxis): void {\r\n\t\tif (!$type.hasValue(this.dataFields[field])) {\r\n\t\t\tthis.dataFields[field] = <any>axis.dataFields.category;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sets date field from the date axis.\r\n\t *\r\n\t * User might set field for category axis only, but not for series. In such\r\n\t * case, we take field value from axis and set it for series.\r\n\t *\r\n\t * @param field  Field\r\n\t * @param axis   Axis\r\n\t */\r\n\tprotected setDateAxisField<Key extends keyof this[\"_dataFields\"]>(field: Key, axis: DateAxis): void {\r\n\t\tif (!$type.hasValue(this.dataFields[field])) {\r\n\t\t\tthis.dataFields[field] = <any>axis.dataFields.date;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Performs after-draw tasks, e.g. creates masks.\r\n\t */\r\n\tprotected afterDraw(): void {\r\n\t\tsuper.afterDraw();\r\n\t\tthis.createMask();\r\n\t}\r\n\r\n\t/**\r\n\t * Create a mask for the series.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic createMask(): void {\r\n\t\t// this mask from which we cut out ranges. does not work well if ranges overlap.\r\n\t\tif (this.mainContainer.mask) {\r\n\t\t\tlet path: string = this.getMaskPath();\r\n\r\n\t\t\t// @todo: this approach won't work well on circluar or other non x/y axes\r\n\t\t\t$iter.each(this.axisRanges.iterator(), (range) => {\r\n\t\t\t\tif (range.axisFill.fillPath) {\r\n\t\t\t\t\trange.axisFill.validate();\r\n\t\t\t\t\tpath += range.axisFill.fillPath;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\tthis.mainContainer.mask.path = path;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an SVG path to use as series mask.\r\n\t *\r\n\t * @return SVG path\r\n\t */\r\n\tprotected getMaskPath(): string {\r\n\t\treturn $path.rectToPath({\r\n\t\t\tx: 0,\r\n\t\t\ty: 0,\r\n\t\t\twidth: this.xAxis.axisLength,\r\n\t\t\theight: this.yAxis.axisLength\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Returns axis data field to use.\r\n\t *\r\n\t * @param axis  Axis\r\n\t * @return Field name\r\n\t */\r\n\tpublic getAxisField(axis: Axis): string {\r\n\t\tif (axis == this.xAxis) {\r\n\t\t\treturn this.xField;\r\n\t\t}\r\n\t\tif (axis == this.yAxis) {\r\n\t\t\treturn this.yField;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Validates data items.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validateDataItems() {\r\n\r\n\t\t// this helps date axis to check which baseInterval we should use\r\n\t\tthis.xAxis.updateAxisBySeries();\r\n\t\tthis.yAxis.updateAxisBySeries();\r\n\r\n\t\tsuper.validateDataItems();\r\n\r\n\t\tthis.xAxis.postProcessSeriesDataItems();\r\n\t\tthis.yAxis.postProcessSeriesDataItems();\r\n\t}\r\n\r\n\t/**\r\n\t * Validates data range.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validateDataRange() {\r\n\t\tif (this.xAxis.dataRangeInvalid) {\r\n\t\t\tthis.xAxis.validateDataRange();\r\n\t\t}\r\n\r\n\t\tif (this.yAxis.dataRangeInvalid) {\r\n\t\t\tthis.yAxis.validateDataRange();\r\n\t\t}\r\n\r\n\t\tsuper.validateDataRange();\r\n\t}\r\n\r\n\t/**\r\n\t * (Re)validates the whole series, effectively causing it to redraw.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validate(): void {\r\n\t\tif (this.xAxis.invalid) {\r\n\t\t\tthis.xAxis.validate();\r\n\t\t}\r\n\r\n\t\tif (this.yAxis.invalid) {\r\n\t\t\tthis.yAxis.validate();\r\n\t\t}\r\n\r\n\t\tthis.y = this.yAxis.pixelY;\r\n\t\tthis.x = this.xAxis.pixelX;\r\n\r\n\r\n\t\tthis._showBullets = true;\r\n\t\tlet minBulletDistance: number = this.minBulletDistance;\r\n\t\tif ($type.isNumber(minBulletDistance)) {\r\n\t\t\tif (this.baseAxis.axisLength / (this.endIndex - this.startIndex) < minBulletDistance) {\r\n\t\t\t\tthis._showBullets = false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsuper.validate();\r\n\t}\r\n\r\n\t/**\r\n\t * X axis the series is attached to.\r\n\t *\r\n\t * @param axis  Axis\r\n\t */\r\n\tpublic set xAxis(axis: Axis) {\r\n\t\tlet oldAxis = this._xAxis.get();\r\n\t\tif (oldAxis != axis) {\r\n\t\t\tif (oldAxis) {\r\n\t\t\t\tthis.dataItemsByAxis.removeKey(oldAxis.uid);\r\n\t\t\t\t// TODO why is this here ?\r\n\t\t\t\tthis._xAxis.dispose();\r\n\t\t\t\t// temp @todo: why it is not disposed?\r\n\t\t\t\toldAxis.series.removeValue(this);\r\n\t\t\t}\r\n\r\n\t\t\tthis._xAxis.set(axis, axis.registerSeries(this));\r\n\r\n\t\t\tthis.dataItemsByAxis.setKey(axis.uid, new Dictionary<string, this[\"_dataItem\"]>());\r\n\t\t\tthis.invalidateData();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Axis\r\n\t */\r\n\tpublic get xAxis(): Axis {\r\n\t\tif (this.chart) {\r\n\t\t\tif (!this._xAxis.get()) {\r\n\t\t\t\tconst axis = this.chart.xAxes.getIndex(0);\r\n\r\n\t\t\t\tif (!axis) {\r\n\t\t\t\t\tthrow Error(\"There are no X axes on chart.\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.xAxis = axis;\r\n\t\t\t}\r\n\t\t\treturn this._xAxis.get();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Y axis the series is attached to.\r\n\t *\r\n\t * @param axis  Axis\r\n\t */\r\n\tpublic set yAxis(axis: Axis) {\r\n\t\tlet oldAxis = this._yAxis.get();\r\n\t\tif (oldAxis != axis) {\r\n\t\t\tif (oldAxis) {\r\n\t\t\t\tthis.dataItemsByAxis.removeKey(oldAxis.uid);\r\n\t\t\t\t// TODO why is this here ?\r\n\t\t\t\tthis._yAxis.dispose();\r\n\t\t\t\t// temp @todo: why it is not disposed?\r\n\t\t\t\toldAxis.series.removeValue(this);\r\n\t\t\t}\r\n\r\n\t\t\tthis._yAxis.set(axis, axis.registerSeries(this));\r\n\r\n\t\t\tthis.dataItemsByAxis.setKey(axis.uid, new Dictionary<string, this[\"_dataItem\"]>());\r\n\t\t\tthis.invalidateData();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Axis\r\n\t */\r\n\tpublic get yAxis(): Axis {\r\n\t\tif (this.chart) {\r\n\t\t\tif (!this._yAxis.get()) {\r\n\t\t\t\tconst axis = this.chart.yAxes.getIndex(0);\r\n\r\n\t\t\t\tif (!axis) {\r\n\t\t\t\t\tthrow Error(\"There are no Y axes on chart.\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.yAxis = axis;\r\n\t\t\t}\r\n\r\n\t\t\treturn this._yAxis.get();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * The main (base) axis.\r\n\t *\r\n\t * This is the axis that series fills will go to, or grow animations will\r\n\t * happen from.\r\n\t *\r\n\t * @param value  Axis\r\n\t */\r\n\tpublic set baseAxis(value: Axis) {\r\n\t\tif (this._baseAxis != value) {\r\n\t\t\tthis._baseAxis = value;\r\n\t\t\tthis.invalidate();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Axis\r\n\t */\r\n\tpublic get baseAxis(): Axis {\r\n\t\tif (!this._baseAxis) {\r\n\t\t\tif (this.yAxis instanceof DateAxis) {\r\n\t\t\t\tthis._baseAxis = this.yAxis;\r\n\t\t\t}\r\n\r\n\t\t\tif (this.xAxis instanceof DateAxis) {\r\n\t\t\t\tthis._baseAxis = this.xAxis;\r\n\t\t\t}\r\n\r\n\t\t\tif (this.yAxis instanceof CategoryAxis) {\r\n\t\t\t\tthis._baseAxis = this.yAxis;\r\n\t\t\t}\r\n\r\n\t\t\tif (this.xAxis instanceof CategoryAxis) {\r\n\t\t\t\tthis._baseAxis = this.xAxis;\r\n\t\t\t}\r\n\r\n\t\t\tif (!this._baseAxis) {\r\n\t\t\t\tthis._baseAxis = this.xAxis;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this._baseAxis;\r\n\t}\r\n\r\n\t/**\r\n\t * Processes values after data items' were added.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param dataItems  Data items\r\n\t */\r\n\tpublic processValues(working: boolean): void {\r\n\r\n\t\tsuper.processValues(working);\r\n\r\n\t\tlet dataItems = this.dataItems;\r\n\r\n\t\tlet minX = Infinity;\r\n\t\tlet maxX = - Infinity;\r\n\r\n\t\tlet minY = Infinity;\r\n\t\tlet maxY = - Infinity;\r\n\r\n\t\tlet startIndex = this.startIndex;\r\n\t\tlet endIndex = this.endIndex;\r\n\r\n\t\tif (!working) {\r\n\t\t\tstartIndex = 0;\r\n\t\t\tendIndex = this.dataItems.length;\r\n\t\t}\r\n\r\n\t\tfor (let i = startIndex; i < endIndex; i++) {\r\n\t\t\tlet dataItem = dataItems.getIndex(i);\r\n\r\n\t\t\tthis.getStackValue(dataItem, working);\r\n\r\n\t\t\tlet stackX = dataItem.getValue(\"valueX\", \"stack\");\r\n\t\t\tlet stackY = dataItem.getValue(\"valueY\", \"stack\");\r\n\r\n\t\t\tminX = $math.min(dataItem.getMin(this._xValueFields, working, stackX), minX);\r\n\t\t\tminY = $math.min(dataItem.getMin(this._yValueFields, working, stackY), minY);\r\n\r\n\t\t\tmaxX = $math.max(dataItem.getMax(this._xValueFields, working, stackX), maxX);\r\n\t\t\tmaxY = $math.max(dataItem.getMax(this._yValueFields, working, stackY), maxY);\r\n\r\n\t\t\t// if it's stacked, pay attention to stack value\r\n\t\t\tif (this.stacked) {\r\n\t\t\t\tif (this.baseAxis == this.xAxis) {\r\n\t\t\t\t\tminY = $math.min(minY, stackY);\r\n\t\t\t\t}\r\n\t\t\t\tif (this.baseAxis == this.yAxis) {\r\n\t\t\t\t\tminX = $math.min(minX, stackX);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// this is mainly for value axis to calculate total and perecent.total of each series category\r\n\t\tthis.xAxis.processSeriesDataItems();\r\n\t\tthis.yAxis.processSeriesDataItems();\r\n\r\n\t\tlet xAxisId: string = this.xAxis.uid;\r\n\t\tlet yAxisId: string = this.yAxis.uid;\r\n\r\n\t\tif (!working) {\r\n\t\t\tif (this._tmin.getKey(xAxisId) != minX || this._tmax.getKey(xAxisId) != maxX || this._tmin.getKey(yAxisId) != minY || this._tmax.getKey(yAxisId) != maxY) {\r\n\t\t\t\tthis._tmin.setKey(xAxisId, minX);\r\n\t\t\t\tthis._tmax.setKey(xAxisId, maxX);\r\n\t\t\t\tthis._tmin.setKey(yAxisId, minY);\r\n\t\t\t\tthis._tmax.setKey(yAxisId, maxY);\r\n\r\n\t\t\t\tif (this.stackedSeries) {\r\n\t\t\t\t\tthis.stackedSeries.processValues(false);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.dispatchImmediately(\"extremeschanged\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this._smin.getKey(xAxisId) != minX || this._smax.getKey(xAxisId) != maxX || this._smin.getKey(yAxisId) != minY || this._smax.getKey(yAxisId) != maxY) {\r\n\t\t\tthis._smin.setKey(xAxisId, minX);\r\n\t\t\tthis._smax.setKey(xAxisId, maxX);\r\n\t\t\tthis._smin.setKey(yAxisId, minY);\r\n\t\t\tthis._smax.setKey(yAxisId, maxY);\r\n\r\n\t\t\tif (this.appeared || this.start != 0 || this.end != 1) {\r\n\t\t\t\tthis.dispatchImmediately(\"selectionextremeschanged\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(!working && this.stacked){\r\n\t\t\tthis.processValues(true);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Hides element's [[Tooltip]].\r\n\t *\r\n\t * @see {@link Tooltip}\r\n\t */\r\n\tpublic hideTooltip() {\r\n\t\tsuper.hideTooltip();\r\n\t\tthis.returnBulletDefaultState();\r\n\t\tthis._prevTooltipDataItem = undefined;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Shows series tooltip at specific position.\r\n\t *\r\n\t * @param xPosition  X\r\n\t * @param yPosition  Y\r\n\t */\r\n\tpublic showTooltipAtPosition(xPosition: number, yPosition: number): IPoint {\r\n\r\n\t\tlet dataItem: this[\"_dataItem\"];\r\n\r\n\t\tif (this.visible && !this.isHiding && !this.isShowing) {\r\n\r\n\t\t\tlet xAxis: Axis = this._xAxis.get();\r\n\t\t\tlet yAxis: Axis = this._yAxis.get();\r\n\r\n\t\t\tif (xAxis == this.baseAxis) {\r\n\t\t\t\tdataItem = <this[\"_dataItem\"]>xAxis.getSeriesDataItem(this, xAxis.toAxisPosition(xPosition), this.snapTooltip);\r\n\t\t\t}\r\n\t\t\tif (yAxis == this.baseAxis) {\r\n\t\t\t\tdataItem = <this[\"_dataItem\"]>yAxis.getSeriesDataItem(this, yAxis.toAxisPosition(yPosition), this.snapTooltip);\r\n\t\t\t}\r\n\r\n\t\t\tlet point = this.showTooltipAtDataItem(dataItem);\r\n\r\n\t\t\tif (point) {\r\n\t\t\t\treturn point;\r\n\t\t\t}\r\n\r\n\t\t\t// so that if tooltip is shown on columns or bullets for it not to be hidden\r\n\t\t\tif (!this.tooltipText) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.hideTooltip();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Shows series tooltip at specific dataItem.\r\n\t *\r\n\t * @param dataItem\r\n\t */\r\n\tpublic showTooltipAtDataItem(dataItem: this[\"_dataItem\"]): IPoint {\r\n\t\tthis.returnBulletDefaultState(dataItem);\r\n\t\tif (dataItem && dataItem.visible) {\r\n\t\t\tthis.updateLegendValue(dataItem);\r\n\t\t\tif (this.cursorTooltipEnabled) {\r\n\t\t\t\tthis.tooltipDataItem = dataItem;\r\n\r\n\t\t\t\t// todo: add tooltipXField and tooltipYField.\r\n\t\t\t\tlet tooltipXField = this.tooltipXField;\r\n\t\t\t\tlet tooltipYField = this.tooltipYField;\r\n\r\n\t\t\t\tif ($type.hasValue((<any>dataItem)[tooltipXField]) && $type.hasValue((<any>dataItem)[tooltipYField])) {\r\n\r\n\t\t\t\t\tlet tooltipPoint = this.getPoint(dataItem, tooltipXField, tooltipYField, dataItem.locations[tooltipXField], dataItem.locations[tooltipYField]);\r\n\r\n\t\t\t\t\tif (tooltipPoint) {\r\n\r\n\t\t\t\t\t\tthis.tooltipX = tooltipPoint.x;\r\n\t\t\t\t\t\tthis.tooltipY = tooltipPoint.y;\r\n\r\n\t\t\t\t\t\tif (this._prevTooltipDataItem != dataItem) {\r\n\t\t\t\t\t\t\tthis.dispatchImmediately(\"tooltipshownat\", {\r\n\t\t\t\t\t\t\t\ttype: \"tooltipshownat\",\r\n\t\t\t\t\t\t\t\ttarget: this,\r\n\t\t\t\t\t\t\t\tdataItem: dataItem\r\n\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\tthis._prevTooltipDataItem = dataItem;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (this.cursorHoverEnabled) {\r\n\t\t\t\t\t\t\tfor (let sprite of dataItem.sprites) {\r\n\t\t\t\t\t\t\t\tif (!sprite.parent.visible || sprite.isHidden || sprite.__disabled || sprite.disabled || sprite.isHiding) {\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\tsprite.isHover = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (this.showTooltip()) {\r\n\t\t\t\t\t\t\treturn $utils.spritePointToSvg({ x: tooltipPoint.x, y: tooltipPoint.y }, this);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t/**\r\n\t * returns default state to bullets when tooltip is shown at some other data item or hidden\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected returnBulletDefaultState(dataItem?: XYSeriesDataItem) {\r\n\t\tif (this._prevTooltipDataItem && this._prevTooltipDataItem != dataItem) {\r\n\t\t\tfor (let sprite of this._prevTooltipDataItem.sprites) {\r\n\t\t\t\tif (!sprite.isDisposed()) {\r\n\t\t\t\t\tsprite.isHover = false;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis._prevTooltipDataItem = undefined;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprotected shouldCreateBullet(dataItem: this[\"_dataItem\"], bulletTemplate:Bullet): boolean {\r\n\t\t// use series xField/yField if bullet doesn't have fields set\r\n\t\tlet xField: string = bulletTemplate.xField;\r\n\t\tif (!$type.hasValue(xField)) {\r\n\t\t\txField = this.xField;\r\n\t\t}\r\n\r\n\t\tlet yField: string = bulletTemplate.yField;\r\n\t\tif (!$type.hasValue(yField)) {\r\n\t\t\tyField = this.yField;\r\n\t\t}\r\n\r\n\t\tif ((this.xAxis instanceof ValueAxis && !dataItem.hasValue([xField])) || (this.yAxis instanceof ValueAxis && !dataItem.hasValue([yField]))) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\t\r\n\r\n\r\n\r\n\t/**\r\n\t * Positions series bullet.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param bullet  Bullet\r\n\t */\r\n\tpublic positionBullet(bullet: Bullet) {\r\n\t\tsuper.positionBullet(bullet);\r\n\r\n\t\tlet dataItem: XYSeriesDataItem = <XYSeriesDataItem>bullet.dataItem;\r\n\r\n\t\t// use series xField/yField if bullet doesn't have fields set\r\n\t\tlet xField: string = bullet.xField;\r\n\t\tif (!$type.hasValue(xField)) {\r\n\t\t\txField = this.xField;\r\n\t\t}\r\n\r\n\t\tlet yField: string = bullet.yField;\r\n\t\tif (!$type.hasValue(yField)) {\r\n\t\t\tyField = this.yField;\r\n\t\t}\r\n\r\n\t\tif ((this.xAxis instanceof ValueAxis && !dataItem.hasValue([xField])) || (this.yAxis instanceof ValueAxis && !dataItem.hasValue([yField]))) {\r\n\t\t\tbullet.visible = false;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlet bulletLocationX: number = this.getBulletLocationX(bullet, xField);\r\n\t\t\tlet bulletLocationY: number = this.getBulletLocationY(bullet, yField);\r\n\r\n\t\t\tlet point = this.getPoint(dataItem, xField, yField, bulletLocationX, bulletLocationY);\r\n\t\t\tif (point) {\r\n\t\t\t\tlet x: number = point.x;\r\n\t\t\t\tlet y: number = point.y;\r\n\r\n\t\t\t\tif ($type.isNumber(bullet.locationX) && this.xOpenField != this.xField) {\r\n\t\t\t\t\tlet openX: number = this.xAxis.getX(dataItem, this.xOpenField);\r\n\t\t\t\t\tx = x - (x - openX) * bullet.locationX;\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif ($type.isNumber(bullet.locationY) && this.yOpenField != this.yField) {\r\n\t\t\t\t\tlet openY: number = this.yAxis.getY(dataItem, this.yOpenField);\r\n\t\t\t\t\ty = y - (y - openY) * bullet.locationY;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbullet.moveTo({ x: x, y: y });\r\n\r\n\t\t\t\tbullet.visible = true;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tbullet.visible = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* returns bullet x location\r\n\t* @ignore\r\n\t*/\r\n\tprotected getBulletLocationX(bullet: Bullet, field: string): number {\r\n\t\tlet bulletLocation: number = bullet.locationX;\r\n\t\tlet dataItem = bullet.dataItem;\r\n\t\tif (!$type.isNumber(bulletLocation)) {\r\n\t\t\tbulletLocation = dataItem.workingLocations[field];\r\n\t\t}\r\n\t\treturn bulletLocation;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t* returns bullet x location\r\n\t* @ignore\r\n\t*/\r\n\tprotected getBulletLocationY(bullet: Bullet, field: string): number {\r\n\t\tlet bulletLocation: number = bullet.locationY;\r\n\t\tlet dataItem = bullet.dataItem;\r\n\t\tif (!$type.isNumber(bulletLocation)) {\r\n\t\t\tbulletLocation = dataItem.workingLocations[field];\r\n\t\t}\r\n\t\treturn bulletLocation;\r\n\t}\r\n\r\n\t/**\r\n\t * Can items from this series be included into stacks?\r\n\t * \r\n\t * Note: proper stacking is only possible if series have the same number\r\n\t * of data items. To ensure this, don't set data directly on series\r\n\t * but do this on chart instead.\r\n\t *\r\n\t * @default false\r\n\t * @param stacked  Can be stacked?\r\n\t */\r\n\tpublic set stacked(stacked: boolean) {\r\n\t\tthis.setPropertyValue(\"stacked\", stacked, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Can be stacked?\r\n\t */\r\n\tpublic get stacked(): boolean {\r\n\t\treturn this.getPropertyValue(\"stacked\");\r\n\t}\r\n\r\n\t/**\r\n\t * Should the nearest tooltip be shown if no data item is found on the\r\n\t * current cursor position?\r\n\t *\r\n\t * @default false\r\n\t * @param value  Should snap?\r\n\t */\r\n\tpublic set snapTooltip(value: boolean) {\r\n\t\tthis.setPropertyValue(\"snapTooltip\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Should snap?\r\n\t */\r\n\tpublic get snapTooltip(): boolean {\r\n\t\treturn this.getPropertyValue(\"snapTooltip\");\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Shows hidden series.\r\n\t *\r\n\t * @param duration  Duration of reveal animation (ms)\r\n\t * @return Animation\r\n\t */\r\n\tpublic show(duration?: number): Animation {\r\n\r\n\t\tlet fields: string[];\r\n\t\tif (this.xAxis instanceof ValueAxis && this.xAxis != this.baseAxis) {\r\n\t\t\tfields = this._xValueFields;\r\n\t\t}\r\n\r\n\t\tif (this.yAxis instanceof ValueAxis && this.yAxis != this.baseAxis) {\r\n\t\t\tfields = this._yValueFields;\r\n\t\t}\r\n\r\n\t\tlet startIndex: number = this.startIndex;\r\n\t\tlet endIndex: number = this.endIndex;\r\n\t\tlet delay: number = 0;\r\n\r\n\t\tlet interpolationDuration = this.defaultState.transitionDuration;\r\n\t\tif ($type.isNumber(duration)) {\r\n\t\t\tinterpolationDuration = duration;\r\n\t\t}\r\n\r\n\t\tlet anim: Animation;\r\n\t\t$iter.each($iter.indexed(this.dataItems.iterator()), (a) => {\r\n\t\t\tlet i = a[0];\r\n\t\t\tlet dataItem = a[1];\r\n\r\n\t\t\tif (this.sequencedInterpolation && interpolationDuration > 0) {\r\n\t\t\t\tdelay = this.sequencedInterpolationDelay * i + interpolationDuration * (i - startIndex) / (endIndex - startIndex);\r\n\t\t\t}\r\n\t\t\tanim = dataItem.show(interpolationDuration, delay, fields);\r\n\t\t});\r\n\r\n\t\tlet animation = super.show(duration);\r\n\r\n\t\tif (anim && !anim.isFinished()) {\r\n\t\t\tanimation = anim;\r\n\t\t}\r\n\r\n\t\treturn animation;\r\n\t}\r\n\r\n\t/**\r\n\t * Hides series.\r\n\t *\r\n\t * @param duration  Duration of hiding animation (ms)\r\n\t * @return Animation\r\n\t */\r\n\tpublic hide(duration?: number): Animation {\r\n\r\n\t\tlet fields: string[];\r\n\t\tlet value: number;\r\n\t\tlet xAxis: Axis = this.xAxis;\r\n\r\n\t\tif (xAxis instanceof ValueAxis && xAxis != this.baseAxis) {\r\n\t\t\tfields = this._xValueFields;\r\n\t\t\t// animate to zero if 0 is within zoomMin/zoomMax\r\n\t\t\tif (this.stacked || (xAxis.minZoomed < 0 && xAxis.maxZoomed > 0) || this.stackedSeries) {\r\n\t\t\t\tvalue = 0;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvalue = xAxis.min;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet yAxis: Axis = this.yAxis;\r\n\t\tif (yAxis instanceof ValueAxis && yAxis != this.baseAxis) {\r\n\t\t\tfields = this._yValueFields;\r\n\t\t\t// animate to zero if 0 is within zoomMin/zoomMax\r\n\t\t\tif (this.stacked || (yAxis.minZoomed < 0 && yAxis.maxZoomed > 0) || this.stackedSeries) {\r\n\t\t\t\tvalue = 0;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvalue = yAxis.min;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//if ($type.hasValue(fields)) {\r\n\t\tlet startIndex: number = this.startIndex;\r\n\t\tlet endIndex: number = this.endIndex;\r\n\r\n\t\tlet interpolationDuration = this.hiddenState.transitionDuration;\r\n\t\tif ($type.isNumber(duration)) {\r\n\t\t\tinterpolationDuration = duration;\r\n\t\t}\r\n\r\n\t\tlet delay: number = 0;\r\n\t\tlet anim: Animation;\r\n\r\n\t\t$iter.each($iter.indexed(this.dataItems.iterator()), (a) => {\r\n\t\t\tlet i = a[0];\r\n\t\t\tlet dataItem = a[1];\r\n\r\n\t\t\tif (interpolationDuration == 0) {\r\n\t\t\t\tdataItem.hide(0, 0, value, fields);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (this.sequencedInterpolation && interpolationDuration > 0) {\r\n\t\t\t\t\tdelay = this.sequencedInterpolationDelay * i + interpolationDuration * (i - startIndex) / (endIndex - startIndex);\r\n\t\t\t\t}\r\n\t\t\t\tanim = dataItem.hide(interpolationDuration, delay, value, fields);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tlet animation = super.hide(interpolationDuration);\r\n\t\tif (animation && !animation.isFinished()) {\r\n\t\t\tanimation.delay(delay);\r\n\t\t}\r\n\r\n\t\tif (anim && !anim.isFinished()) {\r\n\t\t\tanimation = anim;\r\n\t\t}\r\n\r\n\t\t// helps to avoid flicker. otherwise columns will show up at full size and only on next frame will animate from 0\r\n\t\tthis.validateDataElements();\r\n\t\t//}\r\n\t\treturn animation;\r\n\t}\r\n\r\n\t/**\r\n\t * [handleDataItemWorkingValueChange description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic handleDataItemWorkingValueChange(dataItem?: this[\"_dataItem\"], name?: string): void {\r\n\t\tsuper.handleDataItemWorkingValueChange(dataItem, name);\r\n\r\n\t\t// to calculate stack values\r\n\t\tlet axisSeries: List<XYSeries> = <List<XYSeries>>this.baseAxis.series;\r\n\r\n\t\t$iter.each(axisSeries.iterator(), (series) => {\r\n\t\t\tif (series.stacked) {\r\n\t\t\t\tseries.invalidateProcessedData();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * [getStackValue description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param dataItem  Data item\r\n\t */\r\n\tpublic getStackValue(dataItem: this[\"_dataItem\"], working?: boolean): void {\r\n\t\t// todo: here wer stack x and y values only. question is - what should we do with other values, like openX, openY?\r\n\t\t// if this series is not stacked or new stack begins, return.\r\n\r\n\t\tif (!this.stacked) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// it might seem that it's better to go through base axis series, but we do not maintain the same order as in chart.series there.\r\n\t\t\tlet chart: XYChart = this.chart;\r\n\t\t\tlet index: number = chart.series.indexOf(this);\r\n\r\n\t\t\tlet field: string;\r\n\r\n\t\t\tif (this.xAxis != this.baseAxis && this.xAxis instanceof ValueAxis) {\r\n\t\t\t\tfield = this.xField;\r\n\t\t\t}\r\n\t\t\tif (this.yAxis != this.baseAxis && this.yAxis instanceof ValueAxis) {\r\n\t\t\t\tfield = this.yField;\r\n\t\t\t}\r\n\r\n\t\t\t//this is good for removing series, otherwise stack values will remain the same and chart won't pay atention when adding/removing series\r\n\t\t\tdataItem.setCalculatedValue(field, 0, \"stack\");\r\n\r\n\t\t\t$iter.eachContinue(chart.series.range(0, index).backwards().iterator(), (prevSeries) => {\r\n\t\t\t\t// stacking is only possible if both axes are the same\r\n\t\t\t\tif (prevSeries.xAxis == this.xAxis && prevSeries.yAxis == this.yAxis) {\r\n\t\t\t\t\t// saving value\r\n\t\t\t\t\tprevSeries.stackedSeries = this;\r\n\r\n\t\t\t\t\tlet prevDataItem = prevSeries.dataItems.getIndex(dataItem.index); // indexes should match\r\n\r\n\t\t\t\t\tif (prevDataItem && prevDataItem.hasValue(this._xValueFields) && prevDataItem.hasValue(this._yValueFields)) {\r\n\r\n\t\t\t\t\t\tlet value = dataItem.getValue(field);\r\n\t\t\t\t\t\tlet prevValue: number;\r\n\r\n\t\t\t\t\t\tif (working) {\r\n\t\t\t\t\t\t\tprevValue = prevDataItem.getWorkingValue(field) + prevDataItem.getValue(field, \"stack\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tprevValue = prevDataItem.getValue(field) + prevDataItem.getValue(field, \"stack\");\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ((value >= 0 && prevValue >= 0) || (value < 0 && prevValue < 0)) {\r\n\t\t\t\t\t\t\t//dataItem.events.disable();\r\n\t\t\t\t\t\t\tdataItem.setCalculatedValue(field, prevValue, \"stack\");\r\n\t\t\t\t\t\t\t//dataItem.events.enable();\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (!prevSeries.stacked) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [xField description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @return [description]\r\n\t */\r\n\tpublic get xField(): string {\r\n\t\treturn this._xField;\r\n\t}\r\n\r\n\t/**\r\n\t * [yField description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @return [description]\r\n\t */\r\n\tpublic get yField(): string {\r\n\t\treturn this._yField;\r\n\t}\r\n\r\n\t/**\r\n\t * [xOpenField description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @return [description]\r\n\t */\r\n\tpublic get xOpenField(): string {\r\n\t\treturn this._xOpenField;\r\n\t}\r\n\r\n\t/**\r\n\t * [yOpenField description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @return [description]\r\n\t */\r\n\tpublic get yOpenField(): string {\r\n\t\treturn this._yOpenField;\r\n\t}\r\n\r\n\t/**\r\n\t * [tooltipXField description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param value [description]\r\n\t */\r\n\tpublic set tooltipXField(value: string) {\r\n\t\tthis._tooltipXField = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @return [description]\r\n\t */\r\n\tpublic get tooltipXField(): string {\r\n\t\tif (this._tooltipXField) {\r\n\t\t\treturn this._tooltipXField;\r\n\t\t}\r\n\t\treturn this._xField;\r\n\t}\r\n\r\n\t/**\r\n\t * [tooltipYField description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param value [description]\r\n\t */\r\n\tpublic set tooltipYField(value: string) {\r\n\t\tthis._tooltipYField = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @return [description]\r\n\t */\r\n\tpublic get tooltipYField(): string {\r\n\t\tif (this._tooltipYField) {\r\n\t\t\treturn this._tooltipYField;\r\n\t\t}\r\n\t\treturn this._yField;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns lowest value in the series for the specific axis.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param axis  Axis\r\n\t * @return value\r\n\t */\r\n\tpublic min(axis: ValueAxis): number {\r\n\t\treturn this._tmin.getKey(axis.uid);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns highest value in the series for the specific axis.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param axis  Axis\r\n\t * @return value\r\n\t */\r\n\tpublic max(axis: ValueAxis): number {\r\n\t\treturn this._tmax.getKey(axis.uid);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns lowest value in the series for the specific axis within current\r\n\t * selection.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param axis  Axis\r\n\t * @return value\r\n\t */\r\n\tpublic selectionMin(axis: ValueAxis): number {\r\n\t\tlet value = this._smin.getKey(axis.uid);\r\n\t\tif (!$type.isNumber(value)) {\r\n\t\t\tvalue = this.min(axis);\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns highest value in the series for the specific axis within current\r\n\t * selection.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param axis  Axis\r\n\t * @return value\r\n\t */\r\n\tpublic selectionMax(axis: ValueAxis): number {\r\n\t\tlet value = this._smax.getKey(axis.uid);\r\n\t\tif (!$type.isNumber(value)) {\r\n\t\t\tvalue = this.max(axis);\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\r\n\t/**\r\n\t * Processes JSON-based config before it is applied to the object.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param config  Config\r\n\t */\r\n\tpublic processConfig(config?: { [index: string]: any }): void {\r\n\r\n\t\tif (config) {\r\n\r\n\t\t\t// Set up axes\r\n\t\t\tif ($type.hasValue(config.xAxis) && $type.isString(config.xAxis)) {\r\n\t\t\t\tif (this.map.hasKey(config.xAxis)) {\r\n\t\t\t\t\tconfig.xAxis = this.map.getKey(config.xAxis);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.processingErrors.push(\"[XYSeries (\" + (this.name || \"unnamed\") + \")] No axis with id \\\"\" + config.xAxis + \"\\\" found for `xAxis`.\");\r\n\t\t\t\t\tdelete config.xAxis;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif ($type.hasValue(config.yAxis) && $type.isString(config.yAxis)) {\r\n\t\t\t\tif (this.map.hasKey(config.yAxis)) {\r\n\t\t\t\t\tconfig.yAxis = this.map.getKey(config.yAxis);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.processingErrors.push(\"[XYSeries (\" + (this.name || \"unnamed\") + \")] No axis with id \\\"\" + config.yAxis + \"\\\" found for `yAxis`.\");\r\n\t\t\t\t\tdelete config.yAxis;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Set up axis ranges\r\n\t\t\tif ($type.hasValue(config.axisRanges) && $type.isArray(config.axisRanges)) {\r\n\t\t\t\tfor (let i = 0, len = config.axisRanges.length; i < len; i++) {\r\n\t\t\t\t\tlet range = config.axisRanges[i];\r\n\t\t\t\t\tif (!$type.hasValue(range.type)) {\r\n\t\t\t\t\t\trange.type = \"AxisDataItem\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ($type.hasValue(range.axis) && $type.isString(range.axis) && this.map.hasKey(range.axis)) {\r\n\t\t\t\t\t\trange.component = this.map.getKey(range.axis);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if ($type.hasValue(range.component) && $type.isString(range.component) && this.map.hasKey(range.component)) {\r\n\t\t\t\t\t\trange.component = this.map.getKey(range.component);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Parse date fields based on the series fields\r\n\t\t\tif (!$type.hasValue(config.dataFields) || !$type.isObject(config.dataFields)) {\r\n\t\t\t\tthis.processingErrors.push(\"`dataFields` is not set for series [\" + (this.name || \"unnamed\") + \"]\");\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tsuper.processConfig(config);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an [[IPoint]] coordinates of the specific Serie's data point.\r\n\t *\r\n\t * @param    dataItem   Data item\r\n\t * @param    xKey       Name of X data field\r\n\t * @param    yKey       Name of Y data field\r\n\t * @param    locationX  X location\r\n\t * @param    locationY  Y location\r\n\t * @param    stackKeyX  ?\r\n\t * @param    stackKeyY  ?\r\n\t * @returns             Coordinates\r\n\t */\r\n\tpublic getPoint(dataItem: XYSeriesDataItem, xKey: string, yKey: string, locationX?: number, locationY?: number, stackKeyX?: string, stackKeyY?: string): IPoint {\r\n\t\tlet x: number = this.xAxis.getX(dataItem, xKey, locationX);\r\n\t\tlet y: number = this.yAxis.getY(dataItem, yKey, locationY);\r\n\r\n\t\tx = $math.fitToRange(x, -20000, 20000); // from geometric point of view this is not right, but practically it's ok. this is done to avoid too big objects.\r\n\t\ty = $math.fitToRange(y, -20000, 20000); // from geometric point of view this is not right, but practically it's ok. this is done to avoid too big objects.\r\n\r\n\t\treturn { x: x, y: y };\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Updates item reader text based on the type and set up of axis.\r\n\t */\r\n\tprotected updateItemReaderText(): void {\r\n\t\tlet text = \"\"\r\n\t\t$object.each(this.dataFields, (key, val) => {\r\n\t\t\ttext += \"{\" + key + \"} \";\r\n\t\t});\r\n\t\tthis.itemReaderText = text;\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates if series should display a tooltip for chart's cursor.\r\n\t *\r\n\t * If set to `true` (default), the tooltips set for all series item's\r\n\t * elements like columns and bullets will be automatically shown\r\n\t * when [[XYCursor]] passes over category/date, even if its not hovered\r\n\t * directly over the item.\r\n\t *\r\n\t * Set this to `false` to disable such behavior and display item-specific\r\n\t * tooltips only when hovered directly over them\r\n\t *\r\n\t * @default true\r\n\t * @param value Display tooltip?\r\n\t */\r\n\tpublic set cursorTooltipEnabled(value: boolean) {\r\n\t\tthis.setPropertyValue(\"cursorTooltipEnabled\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Display tooltip?\r\n\t */\r\n\tpublic get cursorTooltipEnabled(): boolean {\r\n\t\treturn this.getPropertyValue(\"cursorTooltipEnabled\");\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates if series should apply hover state on bullets/columns/etc when\r\n\t * cursor is over the data item.\r\n\t *\r\n\t * If set to `true` (default) and chart cursor is enabled on th chart,\r\n\t * hovering over date/category will trigger hover states on related Series\r\n\t * items like bullets and columns.\r\n\t *\r\n\t * @default true\r\n\t * @since 4.2.2\r\n\t * @param  value  Hover enabled?\r\n\t */\r\n\tpublic set cursorHoverEnabled(value: boolean) {\r\n\t\tthis.setPropertyValue(\"cursorHoverEnabled\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Hover enabled?\r\n\t */\r\n\tpublic get cursorHoverEnabled(): boolean {\r\n\t\treturn this.getPropertyValue(\"cursorHoverEnabled\");\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"XYSeries\"] = XYSeries;\r\nregistry.registeredClasses[\"XYSeriesDataItem\"] = XYSeriesDataItem;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}